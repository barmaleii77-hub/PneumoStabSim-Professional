Анализ графических проблем PneumoStabSim Professional
Общий обзор графической системы

Проект PneumoStabSim Professional использует движок Qt Quick 3D (через PySide6) для 3D-визуализации
GitHub
. Сцена описана в QML с использованием PBR-материалов (класс PrincipledMaterial) и рендерится через Direct3D 11. Графическая панель приложения позволяет настраивать множество параметров – от освещения (трёхточечная схема света) и материалов до эффектов постобработки (Bloom, SSAO, DOF и т.д.)
GitHub
GitHub
. Ниже рассмотрены выявленные проблемы, их причины и пути решения, а также проверены настройки камеры, материалов, освещения и пост-эффектов. В конце приведены максимальные значения ключевых графических параметров согласно документации Qt Quick 3D.

1. Не работает сглаживание (Antialiasing)

Признаки проблемы: Несмотря на наличие настроек сглаживания (antialiasing) в коде, на изображении видны «рваные» края моделей, то есть сглаживание не проявляется визуально.

Как реализовано сглаживание в коде: В QML-сцене определены свойства antialiasingMode и antialiasingQuality, которые могут переключаться между режимами MSAA (мультисемплинг), SSAA (суперсемплинг) и ProgressiveAA (прогрессивное сглаживание), а также уровнями качества (Low, Medium, High)
GitHub
GitHub
. В обновлённой версии сцены используется расширенный Environment (ExtendedSceneEnvironment) с явным назначением режима AA: например, значение 2 означает MSAA, 1 – SSAA, 3 – ProgressiveAA
GitHub
. Также включены дополнительные методы сглаживания: FXAA (быстрый пост-эффект) и TAA (временное сглаживание) для движущихся объектов
GitHub
.

// Фрагмент настройки AA (ExtendedSceneEnvironment)
antialiasingMode: antialiasingMode === 3 ? SceneEnvironment.ProgressiveAA :
                 antialiasingMode === 2 ? SceneEnvironment.MSAA :
                 antialiasingMode === 1 ? SceneEnvironment.SSAA :
                 SceneEnvironment.NoAA
antialiasingQuality: (antialiasingQuality === 2 ? SceneEnvironment.High :
                      antialiasingQuality === 1 ? SceneEnvironment.Medium :
                      SceneEnvironment.Low)
fxaaEnabled: true   // включен FXAA
temporalAAEnabled: isRunning  // TAA задействован во время анимации
specularAAEnabled: true      // сглаживание бликов
:contentReference[oaicite:7]{index=7}:contentReference[oaicite:8]{index=8}


Причины отсутствия эффекта сглаживания:

Несоответствие настроек старой версии: В ранней реализации параметры сглаживания могли не применяться из-за неправильного сопоставления значений. Например, если antialiasingMode был жёстко задан как ProgressiveAA без учёта пользовательского выбора, то переключение режимов через панель не приводило к изменениям. Отчёт по исправлению ExtendedSceneEnvironment указывает, что были неверно заданы enum для сглаживания и это исправлено в актуальной версии
GitHub
GitHub
. Иными словами, ранее приложение могло всегда работать в одном режиме (или вовсе в NoAA), игнорируя настройки пользователя.

Использование прогрессивного сглаживания при движении сцены: ProgressiveAA накапливает изображение за несколько кадров при условии статичной сцены. Если же камера или объекты постоянно движутся, прогрессивное сглаживание не успевает проявиться – каждый кадр отличается, и накопление не даёт улучшения
codebrowser.dev
. В документации Qt отмечено, что ProgressiveAA не даёт эффекта при каких-либо визуальных изменениях в кадре
codebrowser.dev
. В нашем случае сцена анимирована (подвижные цилиндры, автоповорот камеры и т.п.), поэтому режим ProgressiveAA фактически бесполезен – визуально сглаживание отсутствует. Это объясняет жалобу: если по умолчанию стоял режим 3 (ProgressiveAA), пользователь не видел улучшений.

Отсутствие мультисемплинга окна: Qt Quick 3D обычно сам управляет MSAA через SceneEnvironment, но на некоторых платформах для MSAA может требоваться задать формат поверхности (например, QSurfaceFormat.samples). В проекте не наблюдается явной установки формата окна, однако Qt Quick 3D при SceneEnvironment.MSAA должен сам создать рендер-буфер с нужным числом сэмплов. Тем не менее, важно убедиться, что antialiasingQuality установлен в High (или VeryHigh) для максимального числа сэмплов. Если качество оставалось на Low, MSAA мог быть недостаточно заметен.

Рекомендации по устранению:

Применить исправленную конфигурацию AA: Убедиться, что используется ExtendedSceneEnvironment с правильным маппингом режима и качества сглаживания (как в актуальной версии кода выше). Это позволит переключать NoAA/MSAA/SSAA/Progressive корректно
GitHub
. Также, если ProgressiveAA не даёт эффекта из-за постоянного движения, разумно по умолчанию ставить MSAA для интерактивного режима, а ProgressiveAA – опционально для статических снимков.

Увеличить качество MSAA: Максимальный уровень MSAA в Qt Quick 3D – 8x при качестве VeryHigh
codebrowser.dev
. В коде сейчас High соответствует 4x MSAA
codebrowser.dev
. Имеет смысл добавить в панель значение VeryHigh (если поддерживается версией Qt) или хотя бы убедиться, что при выборе High используется 4 сэмпла. Это улучшит сглаживание геометрии.

FXAA и TAA: Дополнительное сглаживание уже включено (FXAA=true)
GitHub
. FXAA сглаживает края пиксельным шейдером и даёт небольшой выигрыш без серьёзной нагрузки. Temporal AA задействован при анимации (temporalAAEnabled: isRunning)
GitHub
, что помогает сгладить дрожание при движении. Эти опции следует оставить включёнными.

Итого, проблема решается сочетанием правильной настройки режима (например, MSAA 8x на максимум) и учётом особенностей ProgressiveAA. После исправлений сглаживание должно заработать – как указано в отчёте, антиалиасинг теперь настроен правильно
GitHub
.

2. Низкое качество теней

Признаки проблемы: Тени от объектов выглядят «размытыми» или зернистыми, с неровными ступенчатыми краями. Возможны артефакты вроде пикселизации контура тени или дрожания при движении камеры. Пользователь отметил низкое качество, несмотря на настройки.

Как реализованы тени в коде: Используется DirectionalLight (ключевой свет) с включёнными тенями (castsShadow: true). В QML-параметрах есть shadowQuality (0=Low, 1=Medium, 2=High) и shadowSoftness. В старой версии эти параметры применялись так: качество тени выбиралось из набора Low/Medium/High, а shadowSoftness влиял на shadowBias (смещение тени)
GitHub
. В обновлённом коде улучшена конфигурация: качество по-прежнему 0–2 (High = максимальное из предустановленных), а вот «мягкость» теперь используется для фильтрации (расширения PCF) вместо прямого смещения:

DirectionalLight {
    castsShadow: shadowsEnabled
    shadowMapQuality: shadowQuality === 2 ? Light.ShadowMapQualityHigh :
                     shadowQuality === 1 ? Light.ShadowMapQualityMedium :
                     Light.ShadowMapQualityLow
    shadowFactor: 75        // интенсивность затемнения (0-100%)
    shadowBias: 0.0015      // небольшое смещение для борьбы с ацнею
    shadowFilter: 4 + Math.max(0, shadowSoftness) * 28   // размер PCF-фильтра
}
:contentReference[oaicite:20]{index=20}


Здесь shadowMapQualityHigh соответствует размеру карты ~1024×1024
doc.qt.io
. shadowFilter – это количество выборок для PCF (percentage-closer filtering), интерполирующего тень. При shadowSoftness = 0 фильтр = 4 (жёсткие тени, 4 выборки), при 1.0 – 32 выборки (размытие контура).

Причины низкого качества теней:

Ограниченное разрешение карты теней: При High качестве используется текстура 1024×1024
doc.qt.io
. Для большой сцены (несколько метров) этого может быть мало – тень от мелких деталей получится зубчатой. Qt Quick 3D поддерживает уровни VeryHigh (2048²) и Ultra (4096²) для карт теней
doc.qt.io
, но в коде эти уровни не были задействованы (маскимум – High=1024²). Таким образом, даже максимум “High” мог давать недостаточное разрешение тени. Это проявляется как «лесенка» по краям.

Недостаточная фильтрация (размытие): Первоначально в коде не было прямого управления качеством мягких теней – shadowSoftness ошибочно влиял на bias (что только предотвращает самозатенение, но не размывает тень)
GitHub
. Без достаточного PCF фильтра тени имеют жёсткие пиксельные края. Исправление добавило настройку shadowFilter – фактически количество сэмплов PCF
GitHub
. До исправления тени рендерились с дефолтным минимальным фильтром (4 сэмпла, PCF4), отсюда зернистость. Документация указывает, что по умолчанию используется PCF4 (4-семпловый фильтр)
doc.qt.io
, а для более гладких теней можно увеличить до PCF16, 32, 64. В старой конфигурации этого не делали.

Неправильный баланс bias и factor: В старом коде shadowBias вычислялся как shadowSoftness * 0.001
GitHub
. Например, при softness=0.5 bias=0.0005, что могло быть либо слишком мало (появляется ацне – тёмные пятна от самозатенения), либо слишком много (тени «отрываются» от объекта). Хотя bias не влияет напрямую на резкость, слишком большой bias ухудшает контакт тени с объектом, создавая впечатление низкого качества (тень как будто парит отдельно). В новом коде bias фиксирован в 0.0015, а softness задействован иначе. То есть ранее “softness” не приводил к ожидаемому размытому эффекту, вместо этого он незаметно смещал тень.

Рекомендации по улучшению качества теней:

Повысить разрешение карт теней: Разрешить в настройках значение VeryHigh и Ultra. В Qt Quick 3D VeryHigh = 2048×2048, Ultra = 4096×4096
doc.qt.io
. При 4096² пикселизация существенно снизится. Возможно, движок не предлагал эти опции в используемой версии, но Qt 6.10 уже имеет Ultra
doc.qt.io
. Если обновление Qt возможно, стоит задействовать Ultra в качестве “качественного” режима для презентаций, сохраняя High для среднего уровня.

Использовать продвинутое размытие теней: Воспользоваться параметром softShadowQuality, появившимся с Qt 6.8. Он позволяет выбирать PCF4, PCF8, PCF16, PCF32, PCF64
doc.qt.io
. Максимум – 64 выборки (самые мягкие тени). В текущем коде аналог достигнут при shadowSoftness=1 => фильтр=32 (PCF32). Можно расширить диапазон softness до 2, тогда фильтр станет 60 (~PCF64). Либо напрямую добавить переключатель режимов (Hard, Soft PCFx). Гладкие тени без резких пикселей получаются при PCF32-64, но это увеличит нагрузку. Важно отметить, что pcfFactor (радиус фильтра в мире) тоже можно настроить
doc.qt.io
 – сейчас он по умолчанию 2.0. Если тени всё еще резкие, стоит слегка увеличить pcfFactor, чтобы расширить радиус размытия.

Ограничить дальность и интенсивность тени: Убедиться, что параметр shadowMapFar установлен оптимально. По умолчанию тени считаются до 5000 единиц
doc.qt.io
. Если сцена компактная (в пределах, скажем, 10 м), имеет смысл снизить shadowMapFar до ~2000 или даже 1000, чтобы повысить локальную детализацию тени (меньше распределение глубины, выше точность). В примерах Qt используется 2000
doc.qt.io
. Кроме того, можно увеличить shadowFactor до 100 для максимально контрастных теней
doc.qt.io
, если сейчас они кажутся бледными. В коде стоит 75%
GitHub
, т.е. тени слегка подсвечены. 100% даст более чёткий силуэт.

После этих изменений тени станут качественнее: более ровные края и чёткая форма. Уже реализованное исправление – добавление shadowFilter – должно заметно сгладить пикселизацию при повышенной softness. Пользователю можно рекомендовать выставлять качество теней = High и мягкость = 1.0 для наилучшего результата (это даст ~PCF32).

3. Не работает коэффициент преломления (Refraction)

Описание проблемы: В сцене есть прозрачные материалы (например, стеклянный корпус цилиндра подвески). Ожидается эффект преломления – искажение изображения позади объекта в соответствии с показателем преломления (IOR). Однако пользователь не наблюдает заметного преломления. Объект либо полностью прозрачный без искажений, либо просто затемнённый.

Как задан IOR в коде: Преломление настраивается через свойство indexOfRefraction в материале PrincipledMaterial. В QML для корпуса цилиндра видим:

PrincipledMaterial {
    baseColor: cylinderBodyColor
    metalness: cylinderMetalness
    roughness: cylinderRoughness
    opacity: glassOpacity               // прозрачность (<1)
    indexOfRefraction: glassIOR         // коэффициент преломления (например ~1.5)
    alphaMode: PrincipledMaterial.Blend // режим прозрачности – смешивание
}
:contentReference[oaicite:36]{index=36}


Значение glassIOR задаётся извне (скорее всего ~1.5 для стекла по умолчанию). Таким образом, материал полу-прозрачный (opacity < 1) с заданным IOR.

Почему эффект преломления не проявляется:

Ограниченная модель преломления в Qt Quick 3D: В рендерере Qt преломление реализовано не как физически корректный лучевой прогиб, а как окружное преломление с помощью карты окружения (LightProbe). То есть объект с IOR>1 и прозрачностью будет преломлять исключительно фон (skybox/LightProbe), но не искажает объекты позади себя в сцene. Движок не выполняет полноценный рейтрейсинг через прозрачный объект для того, чтобы «изгибать» лучи от других моделей. Вместо этого рассчитывается эффект на основе кубической карты окружения и закона Снеллиуса для этого IOR. Практически это значит: если за стеклянным объектом находится другой геометрический объект, вы будете видеть его напрямую (через прозрачность), без заломления. А вот фоновые отражения/проброс света могут смещаться. Поэтому пользователь мог ожидать, что внутренний поршень или рама за стеклом будут искажаться, но этого не происходит – Qt Quick 3D не поддерживает преломление объектов в реальном времени, только окружения.

Отсутствие заметного окружения для преломления: Эффект преломления более очевиден, когда есть контрастный фон или карта окружающей среды. В нашем проекте используется HDR-текстура студии в качестве LightProbe (IBL)
GitHub
. Также рисуется SkyBox (если включен)
GitHub
. Если skybox отключён, фон – однотонный цвет
GitHub
. В таком случае преломлять нечего – однотонный фон через стекло останется однотонным. Даже с HDR-картой студии эффект может быть subtle: показатель 1.5 даёт лишь небольшое отклонение луча. Если сцена внутри и снаружи освещена равномерно, глаз может не уловить разницы. Таким образом, одна из причин – невысокий контраст окружения.

Неиспользование параметров Transmission: В версии Qt 6.8+ PBR-материалы ввели свойства для физически корректной прозрачности: transmissionFactor и thickness. По сути, вместо манипуляции непрозрачностью, рекомендуется для стекла устанавливать transmissionFactor = 1.0 (100% проход света) и opacity = 1.0 (не ослаблять луч), а степень прозрачности контролировать через Transmission + IOR. В нашем коде же применяется классический подход – понижение opacity и Blend-режим. Это приводит к тому, что свет внутри материала не преломляется, а просто линейно ослабляется. Engine игнорирует IOR, если объект полупрозрачный? На самом деле, Qt Quick 3D учитывает IOR при расчёте отражения/пропускания (Fresnel), но полный эффект проявляется при использовании модели прозрачности (transmission). Поскольку transmissionFactor не задан (по умолчанию 0.0 – материал не передаёт свет
doc.qt.io
), наш материал действует как просто прозрачный мешок с коеффициентом преломления, который влияет лишь на соотношение отражения/пропускания. В итоге преломление почти не видно: отражения могут слегка смещаться по IOR, но прозрачный объект показывает то, что за ним, практически напрямую.

Визуальное восприятие и толщина стекла: Преломление заметно, когда луч проходит значительное расстояние в среде с другим IOR (например, толстая линза). Наш «стеклянный» цилиндр сравнительно тонкостенный (предположительно, просто стенка корпуса). Преломление тонкой стенки минимально – луч почти не отклоняется выйдя с противоположной стороны. Без моделирования толщины (а PrincipledMaterial позволяет указать thicknessFactor для расчёта attenuationColor, но не явно преломления), эффект слабый.

Рекомендации по активации эффекта преломления:

Включить физическую прозрачность (Transmission): Переключить материал стекла на использование transmissionFactor. Установить transmissionFactor: 1.0 и opacity: 1.0 (чтобы движок не просто делал blend), attenuationDistance и attenuationColor при необходимости для окраски толстой среды. Тогда Qt Quick 3D будет считать материал как физически прозрачный, и параметр indexOfRefraction начнёт влиять на раскладку Fresnel: сколько света отражается, сколько проходит
doc.qt.io
doc.qt.io
. Это не заставит геометрию за стеклом искажаться, но по крайней мере скорректирует яркость/блики по IOR, делая стекло реалистичнее. Порог, когда IOR заметен, – отражающие углы. При IOR=1.5 на границе стекло сильнее отражает окружение.

Использовать ReflectionProbe для локального окружения: В старой версии кода была попытка добавить ReflectionProbe (кубическую карту) внутри сцены
GitHub
, обновляющуюся каждый кадр. Это теоретически позволяет видеть в отражении и преломлении не только skybox, но и объекты сцены. Однако, Weighted Blended OIT (метод прозрачности, используемый в Qt) не обеспечивает настоящего отражения геометрии. ReflectionProbe мог бы захватить окружающие объекты, но с ограничениями. Если очень нужен эффект, можно попробовать оставить ReflectionProbe.refreshMode: EveryFrame
GitHub
 и убедиться, что материал использует эту probe (в Qt6.10 lightProbe можно привязать к модели или автоматически берётся ближайший). Но это дорого и всё равно не даст настоящего преломления близких объектов.

Повысить контраст окружения: Чтобы подчеркнуть преломление, можно добавить фон с чётким узором (например, сетка или полосы). Тогда через цилиндр они будут видны искаженными, демонстрируя коэффициент преломления. В рамках текущей сцены – возможно, включить SkyBox с чёткой HDR (студийная окружение уже подключено
GitHub
). Также, убедитесь, что iblEnabled и skybox включены одновременно, иначе фон однотонный
GitHub
.

Проверить значения IOR: Убедиться, что glassIOR задан верно. Для стекла обычно ~1.5
doc.qt.io
. Большее значение (например 2.4 – “алмаз”) дало бы сильный эффект, но физически неправдоподобно. Документация отмечает, что реалистичные материалы имеют IOR 1.0–3.0
doc.qt.io
. Так что 1.5 – норм. Визуально можно попробовать 1.2–1.3 (плексиглас/вода) или 1.7 (кристалл), чтобы увидеть разницу. Но ожидаемого «линзирования» не будет без трассировки лучей.

Таким образом, «неработающий» коэффициент преломления обусловлен особенностями рендеринга. Это не баг кода, а ограничение движка: рефракция в реальном времени упрощена. Рекомендуется настроить материал согласно PBR-требованиям (transmission вместо прозрачности) и обеспечить богатое окружение. Тогда преломление проявится как реалистичные отблески и небольшое искажение фона. Если же требуются настоящие искажения объектов, единственный выход – использовать рейтрейсинг либо screen-space refraction (не реализовано в Qt Quick 3D на 2025 год).

4. Дёргается фон при вращении орбитальной камеры

Суть проблемы: При вращении модели с помощью орбитальной камеры фон (например, skybox) ведёт себя дергано. Возможно, наблюдается прыжок изображения в момент начала или во время поворота.

Как устроена орбитальная камера: В приложении реализована кастомная орбитальная камера с возможностью вращения (LMB), панорамирования (RMB) и зума (колесо)
GitHub
. В QML камера представлена узлом cameraRig с дочерним узлом panNode и камерой внутри
GitHub
GitHub
. Такой подход (Rig + Pan) выбран специально: pivot (ось вращения) фиксирован в центре модели, а смещение камеры по XY плоскости делается отдельным узлом pan, чтобы pivot не «уезжал»
GitHub
GitHub
. В коде указано, что это исправление проблемы смещения pivot при панорамировании
GitHub
. Также на движения камеры добавлены небольшие плавные анимации (easing) для сглаживания
GitHub
.

Причины дергания фона:

Смещение центра вращения (pivot) при панорамировании: Если до фикса пользователель смещал камеру (RMB-драг), то pivot камеры мог сместиться из центра сцены. В старой реализации, вероятно, панорамирование перемещало сам pivot. В результате при следующем вращении (LMB) камера начинала вращаться вокруг уже другого центра, что вызывало скачок – фон мог «подёргиваться», поскольку сцена вращалась не вокруг собственного центра, а по сложной траектории. Исправление решило это: теперь pivot всегда в центре рамы, и панорамирование не влияет на него, а только сдвигает камеру параллельно
GitHub
. Это обеспечивает стабильное орбитальное вращение. Если фон (skybox) привязан к камере, то при чистом вращении он должен оставаться статичным относительно сцены (потому что камера по сути только поворачивается вокруг центра, не двигаясь линейно). Таким образом, до фикса происходил паразитный сдвиг камеры, воспринимаемый как дёрганье.

Ошибка инициализации позиции мыши: В коде обнаружена и исправлена проблема, вызывавшая резкий рывок камеры при начале драга. При нажатии мыши теперь сохраняется текущая позиция как lastX/Y
GitHub
. Ранее этого не делалось, и при первом событии onPositionChanged вычислялся большой дельта (lastX был старым, возможно от прошлого кадра или 0). В логе даже добавлена проверка на слишком большой δ с игнорированием его
GitHub
. Именно этот момент давал дергание в начале вращения – камера могла сразу дернуться на несколько градусов. Теперь при нажатии координаты сбрасываются, и вращение начинается плавно
GitHub
.

Отсутствие привязки фона к камере: Ещё одна возможная причина – если фон реализован не как skybox в SceneEnvironment, а, например, как плоский rect позади, то при движении камеры фон должен оставаться неподвижным. В Qt Quick 3D skybox автоматически вращается с камерой (имитируя бесконечное расстояние)
codebrowser.dev
. Если же фон был цветным и камера смещалась неправильно, могло создаться ощущение дёрганья градиента. Судя по коду, фон задаётся либо цветом, либо skyboxом
GitHub
, так что это вряд ли проблема. Основные причины именно в логике камеры.

Решения (большинство уже реализовано):

Использовать исправленную систему орбитальной камеры: В актуальной версии pivot фиксирован, разделены узлы вращения/панорамирования, что устраняет геометрическое дрожание
GitHub
. Необходимо убедиться, что приложение действительно использует этот код (файл main.qml версии 4.3). При панорамировании pivot не смещается, и фон больше не дёргается при последующем вращении – камера крутится вокруг центра сцены.

Инициализация при захвате мыши: Код уже поправлен – установка lastX=mouse.x и lastY=mouse.y при onPressed предотвращает скачок
GitHub
. Важно сохранить эту логику. Кроме того, введён throttling событий (ограничение 120 FPS для обработки мыши)
GitHub
 и отсеивание аномально больших дельт
GitHub
. Это всё направлено на плавность. Следует оставить эти проверки, чтобы при лаге кадров или резком движении мыши не было рывков.

Плавное затухание движения: Уже добавлены Behavior on yawDeg/pitchDeg/cameraDistance – небольшая интерполяция на 90 мс
GitHub
. За счёт этого даже при резком вводе вращение чуть сглаживается по инерции. Это улучшает восприятие фона при вращении – он движется более непрерывно. Пользователю можно порекомендовать также использовать автоповорот (AutoRotate) при демонстрации, который вращает камеру равномерно.

В результате, после вышеописанных исправлений фон (skybox) должен вращаться равномерно и без рывков. По сути, проблема дёрганья камеры была связана с неправильной матемatikой pivot и обработкой ввода – разработчики её уже устранили
GitHub
GitHub
. Не лишним будет протестировать на разных FPS, чтобы убедиться в отсутствии микро-подёргиваний (TAA сгладит мелкие, но если будет систематическая ошибка, её нужно ловить).

Проверка настроек камеры, материалов, освещения и эффектов

В ходе анализа кода проекта выявлено следующее:

Камера: Орбитальная камера задаётся как PerspectiveCamera с углом обзора 50° по умолчанию
GitHub
GitHub
. Ближняя и дальняя плоскости обрезки установлены в 2.0 и 50000.0 соответственно
GitHub
, что адекватно покрывает сцену рамы (~метры) без ближних артефактов (near 2.0мм – достаточно маленькое значение). Настройки камеры (FOV, near/far) управляются через панель GraphicsPanel, как видно из свойств cameraFov, cameraNear и т.д. в QML
GitHub
. Эти параметры используются непосредственно в камере
GitHub
. Вывод: Настройки камеры выбраны разумно; угол 50° даёт натуральную перспективу без сильных искажений. FOV можно менять – в разумных пределах 30–90°. Максимально допустимое значение – ~180° (теоретически, но практически >120° даст выраженный fish-eye). В целом, конфигурация камеры корректна, её проблемы решены фиксом орбиты.

Материалы: В проекте активно используются PBR-материалы (PrincipledMaterial) для всех объектов: рама, рычаги, цилиндры, поршни и т.д. Это видно по множественным блокам PrincipledMaterial { ... } в QML
GitHub
GitHub
. Настройки материалов параметризированы: цвета (baseColor) задаются через переменные (например, frameBaseColor), металлическость (metalness) и шероховатость (roughness) тоже управляются переменными, которые можно менять из UI (панель материалов)
GitHub
GitHub
. Так, рама – металлическая (metalness 0.8) с умеренно гладкой поверхностью (roughness 0.3)
GitHub
, рычаги окрашены в оранжевый с металличностью 0.9 и roughness 0.2 (более блестящие)
GitHub
. Стекло цилиндра – низкая непрозрачность (glassOpacity, вероятно ~0.25–0.5) и IOR ~1.5, металл=0 (диэлектрик), roughness настроена (возможно ~0.1–0.2 для блеска)
GitHub
. Вывод: материалы настроены правдоподобно. PBR-параметры находятся в допустимых диапазонах 0–1 (как и должно быть: metalness, roughness ∈ [0,1]
doc.qt.io
). Предельные значения: metalness 1.0 = идеальный металл, roughness 0.0 = совершенно гладкое зеркало. В коде таких экстремальных не задано, но пользователь может выставить. Документация подтверждает эти диапазоны
doc.qt.io
. Дополнительно, используются свойства ClearCoat для рамы (имитация лака)
GitHub
GitHub
 – они тоже в 0–1. В целом, ограничения материалов соблюдены, проблем тут нет.

Освещение: Сцена освещается по классической схеме 3-point lighting плюс точечный акцент. В QML объявлены: Key Light (направленный, тени от него включены), Fill Light (направленный без теней, заполняющий) и Rim Light (подсветка сзади)
GitHub
GitHub
. Кроме того, PointLight над центром (имитирует возможно рассеянный верхний свет)
GitHub
. Яркости света: key ~2.8, fill 0.8, rim 1.2 (в коде есть keyLightBrightness, fillLightBrightness, rimLightBrightness – значения нужно уточнить, в snippet видим 2.8, 0.8, rim не показан но возможно ~1.0)
GitHub
GitHub
. Цвета близки к белому. Тени включены только у Key Light. Вывод: освещение настроено грамотно. Максимальные возможные значения: яркость света не ограничена (реально может быть >100, хотя обычно 1–10 достаточно). Текущие ~2–3 вполне нормальны. Цветовая температура не моделируется отдельно, но можно менять цвет. ShadowMapFar не указан, значит 5000 (достаточно). ShadowFactor 75% – тени не абсолютные, немного света заполняет (можно до 100%, но это стилистика). Рекомендация: при необходимости сделать тени более жёсткими – повысить factor до 100
doc.qt.io
. Но это уже вкусовщина. Освещение в целом не вызывает графических артефактов.

Эффекты постобработки: Проект включает несколько пост-эффектов через ExtendedSceneEnvironment: Bloom (Glow), SSAO, Tone Mapping, Vignette, Depth of Field, Lens Flare и др.
GitHub
GitHub
. Согласно коду, по умолчанию bloomEnabled=true (эффект свечения ярких областей), ssaoEnabled=true (окружающее затенение), tonemapEnabled=true (тонирование в Filmic), vignetteEnabled=true (виньетка)
GitHub
. Многие из них настроены по дефолту: например, bloomThreshold=1.0, bloomIntensity=0.6–0.8
GitHub
GitHub
, SSAO radius ~8.0, intensity 0.6 (позже масштабируется x100)
GitHub
GitHub
, DOF выключен (depthOfFieldEnabled=false) по умолчанию. Вывод: эффекты включены, но параметры умеренные, проблем не заметно. Например, bloomIntensity 0.8 – это довольно мягкий эффект (диапазон в Qt, формально не ограничен, обычно 0–1 как разумный). SSAO intensity 0.6 (в коде умножается на 100 => 60%)
GitHub
 – тоже средний эффект, radius 8 достаточно локальный. Максимумы: SSAO strength 100% (если >1, смысла нет – параметр в Qt нормирован на 0–100)
GitHub
. BloomIntensity можно повысить до 1.0 или более, но >1 может засветить картинку (документация прямой предел не даёт, но обычно 0–2). Важный момент – antialiasingQuality также относится к постпроцессу: в коде используются значения Low/Med/High (High = максимальное из предусмотренных, но Qt6 добавляет VeryHigh)
codebrowser.dev
. Сейчас стоит 2 (High) по умолчанию
GitHub
, то есть все эффекты рендерятся в высоком качестве.

В целом, настройки пост-эффектов сбалансированы. Ни один из них не объясняет выявленные проблемы напрямую (например, MotionBlur отключён, так что фон дёргался не из-за него). Разве что тонемаппинг: режим Filmic сглаживает контраст, что могло сделать тени бледнее (отчасти влиять на восприятие «низкого качества теней»). Но это скорее художественный эффект. Максимальные режимы – Filmic (он и выбран), можно выключить тонемаппинг для чистого Linear, но тогда блики могут выбиваться. Это на усмотрение – Filmic обычно предпочтителен.

Итог проверки: Камера, материалы, свет и эффекты настроены правильно, серьезных ошибок не обнаружено кроме уже обсуждавшихся. Большинство проблем решалось тонкой настройкой и знанием ограничений движка. Далее приведём сводку максимальных значений ключевых графических параметров (согласно документации Qt Quick 3D), чтобы понимать границы улучшения качества.

Максимальные значения параметров, влияющих на графику (согласно документации)

Ниже перечислены основные графические параметры движка Qt Quick 3D, используемые в проекте, и их диапазоны/максимумы:

Antialiasing (сглаживание): Qt Quick 3D поддерживает режимы NoAA, MSAA, SSAA, Progressive.

AntialiasingQuality имеет уровни Low, Medium, High, VeryHigh. При разных режимах эти уровни означают:

MSAA: Low=2×, Medium=4×, High=4× (в Qt6.9 High стал 4×), VeryHigh=8× MSAA (максимум – 8 выборок на пиксель)
codebrowser.dev
.

SSAA: Low≈1.2× масштаб, Medium≈1.5×, High≈1.5×, VeryHigh=2.0× рендер-разрешение
codebrowser.dev
.

ProgressiveAA: Low=2 кадра накопления, Medium=2, High=4, VeryHigh=8 кадров (максимум 8)
codebrowser.dev
.

Temporal AA (TAA): отдельного градуируемого параметра нет, просто вкл/выкл. В нашем проекте TAA активен при анимации.

FXAA: тоже бинарный – либо включён, либо нет. Он всегда работает в экранном разрешении.

Вывод: наивысшее качество сглаживания достигается при SceneEnvironment.VeryHigh и выборе режима MSAA или ProgressiveAA. Например, MSAA 8x даст сглаживание в один проход, ProgressiveAA 8 накопит несколько кадров (но только на статичной картинке)
codebrowser.dev
.

Тени (Shadow Mapping): Качество теней настраивается параметром shadowMapQuality:

Low – 256×256 карта теней
doc.qt.io
.

Medium – 512×512.

High – 1024×1024.

VeryHigh – 2048×2048.

Ultra – 4096×4096 (максимально доступное качество)
doc.qt.io
.

Кроме разрешения, есть softShadowQuality (с Qt 6.8):

Значения: Hard (без размытия), PCF4, PCF8, PCF16, PCF32, PCF64 – количество выборок фильтра тени
doc.qt.io
.

Максимум – PCF64 (64 выборки), дающий самый мягкий контур тени.

shadowFactor определяет максимальную насыщенность тени: 100 означает абсолютно чёрная тень при полном перекрытии света
doc.qt.io
. (0 – тени нет вовсе).

shadowBias подбирается в зависимости от сцены, нет фиксированного максимума – обычно доли единицы (десятые или тысячные).

Вывод: максимально чёткие и детальные тени – при Ultra 4096² и Hard (но будут резкие пиксели), максимально мягкие – при PCF64 (с небольшой потерей резкости). Можно комбинировать Ultra + PCF64 для качества (но это очень ресурсозатратно).

Материалы (PBR): Основные параметры PrincipledMaterial ограничены физическими диапазонами:

Металличность (metalness): от 0.0 (диэлектрик) до 1.0 (полностью металлический)
doc.qt.io
. Значения между разрешены для смешанных материалов. >1 не имеет физического смысла.

Шероховатость (roughness): от 0.0 (идеальное зеркало, гладкое) до 1.0 (матовый, диффузный) – физический диапазон.

Альбедо (baseColor): цвет в формате RGB, обычно каждое 0–1 (или 0–255). Нет специфического «максимума», кроме как белый.

Прозрачность и преломление:

opacity 0.0–1.0 (0 – полностью прозрачно, 1 – непрозрачно).

transmissionFactor 0.0–1.0
doc.qt.io
 (0 – материал не пропускает свет, 1 – стекло полностью пропускает свет). По умолчанию 0, нужно ставить 1 для стекла.

indexOfRefraction: обычно 1.0–3.0. Значение по умолчанию 1.5
doc.qt.io
. Материалы с IOR > 3 в природе не встречаются
doc.qt.io
, хотя двигательно можно поставить и выше, но эффект будет непредсказуемым.

attenuationDistance/Color: задают поглощение света в толщине, применимо для толстых прозрачных материалов. Обычно расстояние задаётся в сценических единицах (например, 1000 мм), цвет – любой. Ограничений как таковых нет, кроме разумных (если distance слишком мал, объект станет чёрным).

Спекулярность: specularAmount 0–1 (доп. параметр для диэлектриков, сколько отражённого света; 1 по умолчанию).

ClearCoat: 0–1 (вторичный отражающий слой), clearcoatRoughness 0–1.

Эмиссия: может быть любая (цвет >1 для супер-яркого самосвечения, но это линейный множитель).

Вывод: Все PBR параметры ограничены [0,1] либо физическими смыслами. Максимальные значения обычно 1.0 (100%) для коэффициентов, и ~3.0 для IOR.

Освещение:

Яркость источников (brightness/intensity): положительное значение без жёсткого лимита. По умолчанию 1.0 = стандартная яркость. Можно ставить 10, 100 и т.д. – будет эквивалентно усилению лампы. В разумных пределах <10 достаточно; сверх – может потребоваться тонемаппинг чтобы не клипповало.

Цвет источника: задаётся как RGB, диапазон 0–1 (в HDR можно >1 для цветных источников, но обычно нет).

Угол освещения для DirectionalLight: охватывает всю сцену, нет параметра угла (считается бесконечный).

QuadraticFade для PointLight: коэффициент квадратичного затухания. В примере стоит 0.00008
GitHub
 – он определяет радиус влияния. Нет фиксированного максимума, 0 отключает затухание (бесконечный радиус).

Количество источников: Qt Quick 3D может несколько (в нашем случае 4). Сильно много (>10) может просадить производительность, но формального лимита в документации нет, скорее GPU-ограничения.

Пост-эффекты (ExtendedSceneEnvironment):

Bloom (Glow):

glowEnabled: boolean.

glowIntensity: обычно 0.0–~2.0 (не указано явно, но >1 усиливает свечение сверх яркости источника). В коде макс. не задан, но glowHDRScale, glowHDRMin/Max контролируют реакцию на яркие цвета. Они установлены в 2.0, 1.0, 8.0 соответственно
GitHub
, это оптимально.

glowQualityHigh: true/false (если true – использует более детальный downsample для блум).

SSAO:

aoStrength: 0–100 [%]
GitHub
. Мы видим, что движок ожидает 0–100, наши 60–70 – это 60–70%.

aoDistance (Radius): в сценических единицах. Можно ставить большое значение, но радиус > ~100 может приводить к ненатуральной тени «гело». В старом коде пробовали 200
GitHub
. Оптимально 5–50 для мелких деталей, 100 – для крупной формы.

aoSampleRate: можно 1,2,3 (в коде 3 = максимальный predefined, означает количество выборок на пиксель, 3 – наибольшее, даёт лучшую детализацию, ценой производительности)
GitHub
.

aoSoftness: 0–?? (в коде 20) – степень размытия AO. 20 – довольно мягко, максимум не указан, но слишком большое размывает впустую.

Tonemapping: режимы None, Linear, Reinhard, Filmic
GitHub
. Максимум – художественный выбор, Filmic обычно оптимален для HDR.

whitePoint: 2.0 (в коде) – можно настраивать, выше – картинка темнее.

Vignette: vignetteStrength обычно 0–1 (код 0.7) – можно 1.0 для сильной виньетки.

Depth of Field:

depthOfFieldEnabled: bool.

FocusDistance: в сцен. единицах, зависит от сцены.

FocusRange: диапазон резкости. Нет явного макс, зависит от сцены.

BlurAmount: 0–? (код 3.0). Документация по DoF не даёт числовой предел, 3.0 видимо означает сильное размытие. Возможно, выше 5–10 бессмысленно, т.к. ядро размытия и так большой.

Lens Flare:

lensFlareGhostCount: обычно 3 (в коде) – возможно можно 0–5 (документация не указана, но больше – больше артефактов).

...Dispersal, HaloWidth, BloomBias, Stretch: заданы как 0.6, 0.25, 0.35, 1.0 – эти параметры не имеют строгих «максимумов», это коэффициенты для видимого эффекта, их можно менять для стиля.

Motion Blur: (в коде присутствует флаг, но не используется). Если бы был, параметр – shutter angle или samples. Сейчас отключён.

Обобщая, максимально возможные настройки качества для данного проекта на Qt Quick 3D будут: сглаживание VeryHigh (8x MSAA), тени Ultra 4096px + PCF64, включённый TAA+FXAA, Filmice tonemapping, максимум реалистичных эффектов (Bloom, SSAO и др.). PBR-материалы уже используют физически корректные диапазоны (0–1, IOR ~1-3). В пределах этих максимальных значений разработчики могут экспериментировать, однако нужно помнить о производительности – каждый шаг (увеличение разрешения теней, выборок AO, etc.) нагружает систему.

Заключение: Проанализированные проблемы имеют конкретные технические причины – в основном связанные с нюансами использования Qt Quick 3D. Сглаживание «не работало» из-за неверной конфигурации и неподходящего режима для движущейся сцены
codebrowser.dev
, качество теней страдало от недостаточного разрешения/фильтрации
doc.qt.io
doc.qt.io
, преломление оказалось малозаметным ввиду ограничений рендеринга и настроек материала
doc.qt.io
, а дергание камеры было вызвано логикой pivot и обработкой ввода
GitHub
GitHub
. Предложенные решения – корректировка настроек в соответствии с документацией и лучшими практиками – уже частично внедрены и должны быть доведены до конца. Следуя этим рекомендациям, можно добиться значительно более гладкой картинки, чётких теней и правильной работы всех заявленных графических эффектов.

Источники:

README проекта PneumoStabSim (технологии и функционал)
GitHub
GitHub

Фрагменты QML-сцены (настройки antialiasing, тени, преломление, камера)
GitHub
GitHub
GitHub
GitHub

Отчёт об исправлениях ExtendedSceneEnvironment (проблемы AA и камеры)
GitHub
GitHub

Документация Qt Quick 3D (антиалиасинг, тени, материалы) – Qt 6.10: Antialiasing Best Practices
codebrowser.dev
codebrowser.dev
, Light QML Type (теневые карты)
doc.qt.io
doc.qt.io
, PrincipledMaterial (IOR, metalness)
doc.qt.io
doc.qt.io
.

Таблица графических параметров Qt Quick 3D с диапазонами, значениями по умолчанию и использованием в проекте

Antialiasing Settings
Parameter	Type	Values/Range	Quality Levels (Numeric)	Qt Default	Usage in Project	Comment
antialiasingMode	enum	NoAA, SSAA, MSAA, ProgressiveAA
doc.qt.io
	(N/A – see antialiasingQuality for samples)	NoAA (no antialiasing)
doc.qt.io
	Set to MSAA by default (antialiasingMode = 2)
GitHub
	Chooses the primary AA technique. SSAA renders at higher resolution (high quality, but costly)
doc.qt.io
; MSAA smooths geometry edges (4x samples typical)
doc.qt.io
doc.qt.io
; ProgressiveAA accumulates frames when scene is still (great quality but only for static content)
doc.qt.io
doc.qt.io
. Project uses MSAA for moving scenes and can switch to ProgressiveAA for still frames
GitHub
GitHub
.
antialiasingQuality	enum	Medium, High, VeryHigh
felgo.com
	Medium: 1.2× SSAA, 2× MSAA
felgo.com
; High: 1.5× SSAA, 4× MSAA
felgo.com
; VeryHigh: 2.0× SSAA, 8× MSAA
felgo.com
	High (medium-high AA)
felgo.com
	Uses 3 levels: 0=Low, 1=Medium, 2=High (project default High=4× MSAA)
GitHub
	Sets the AA sample count or resolution scale. Higher quality means more samples or larger render buffer, improving smoothing at cost of performance. Project exposes Low/Med/High options (VeryHigh not exposed) – e.g. High=4× MSAA
felgo.com
. Medium uses fewer samples (2× MSAA), while VeryHigh would use 8× MSAA for maximum smoothness.
fxaaEnabled	bool	true/false	(N/A)	false (off)
doc.qt.io
	Enabled (true) in extended env.
GitHub
	Fast Approximate Anti-Aliasing. Post-process filter that smooths jagged edges with minimal cost. Improves fine detail aliasing that MSAA misses. Project enables FXAA in addition to MSAA for extra smoothing
GitHub
.
temporalAAEnabled	bool	true/false	(N/A)	false (off)
doc.qt.io
	Enabled when running animation (true while isRunning)
GitHub
	Temporal AA blends frames by jittering the camera slightly each frame
doc.qt.io
. Great for reducing flicker in motion (finds detail over frames) with low performance hit
doc.qt.io
. The project turns TAA on during animations to smooth motion, but off for still scenes (where ProgressiveAA takes over)
GitHub
GitHub
.
temporalAAStrength	real	0.0 – 1.0 (fraction of jitter amount)	(N/A)	0.3 (30% blend)
doc.qt.io
	Not explicitly set (uses default)	Controls how much camera “jitter” is applied for TAA. Higher values jitter more between frames (increasing AA effect but risking ghosting)
doc.qt.io
doc.qt.io
. The default (0.3) provides a moderate balance, which the project accepts as is.
specularAAEnabled	bool	true/false	(N/A)	false (off)
doc.qt.io
doc.qt.io
	Enabled (true) in project
GitHub
	Reduces aliasing on specular highlights (shiny reflections)
doc.qt.io
, preventing “sparkling” or flickering pixels. Enabled in project to smooth out glinting reflections from metal surfaces.
ditheringEnabled	bool	true/false	(N/A)	false (off)
doc.qt.io
	Enabled (true) in project
GitHub
	Applies subtle noise to avoid color banding in gradients
doc.qt.io
. Especially useful with post-processing and HDR to make color transitions smoother at the cost of slight noise. Enabled in project for better color smoothness.

Sources: Qt 6.10 SceneEnvironment & ExtendedSceneEnvironment docs
doc.qt.io
felgo.com
doc.qt.io
, PneumoStabSim code
GitHub
GitHub
.

Shadow and Lighting Parameters
Parameter	Type	Values/Range	Quality Levels (Numeric)	Qt Default	Usage in Project	Comment
castsShadow	bool	true/false	(N/A)	false (shadows off)
doc.qt.io
	Controlled via shadowsEnabled toggle (e.g. keyLight.castsShadow = true)
GitHub
	Enables real-time shadows from the light when true
doc.qt.io
. Disabled by default (no shadows). In project, the key light casts shadows when shadowsEnabled is true, allowing dynamic shadows in the scene.
shadowMapQuality	enum	Low, Medium, High, VeryHigh, Ultra
doc.qt.io
	Low: 256×256; Medium: 512×512; High: 1024×1024; VeryHigh: 2048×2048; Ultra: 4096×4096
doc.qt.io
	Low (256² shadow texture)
doc.qt.io
	Project uses Low/Med/High (default High=1024²)
GitHub
	Resolution of the shadow map. Higher quality uses larger maps for sharper, less pixelated shadows at the cost of memory/performance
doc.qt.io
. Project default High (1024²) yields fairly detailed shadows; Ultra (4096²) is available for maximum quality
doc.qt.io
.
softShadowQuality	enum	Hard, PCF4, PCF8, PCF16, PCF32, PCF64
doc.qt.io
	Hard: no filter (sharp shadows); PCF4: 4 samples; PCF8: 8 samples; ... PCF64: 64 samples
doc.qt.io
	PCF4 (4-sample softening)
doc.qt.io
	Project uses legacy filter instead	Chooses the softness filter for shadow edges. PCF (percentage-closer filtering) samples the shadow map multiple times to blur edges
doc.qt.io
. More samples yield smoother, softer shadows but reduce performance. Project Note: Qt 6.9 introduced this; the project instead computes a custom shadowFilter value (see below) for softness.
shadowFilter	real	1.0 – 64.0 (approx. PCF samples)	(N/A)	~4.0 (equivalent to PCF4)	Set dynamically: e.g. ~18 at default softness=0.5
GitHub
	Legacy softness parameter (pre-6.8). Higher values blur shadow edges more. The project calculates shadowFilter = 4 + 28*shadowSoftness
GitHub
, giving 4 (sharp) at softness 0 and up to 32 (very soft) at softness=1. This approximates PCF filtering (e.g. ~32 ≈ PCF32).
shadowSoftness	real	0.0 – 1.0 (user softness factor)	(N/A)	(n/a in Qt)	Exposed in UI (default 0.5)
GitHub
	Project-only parameter. Represents a user-friendly softness slider. It drives either shadowFilter (older method) or shadow bias adjustment. A higher softness means softer, more blurred shadow edges. Not an official Qt property, but mapped to shadow filtering in this project.
shadowBias	real	Scene-size dependent (tweak value, e.g. 0.0001 – 10)	(N/A)	10.0
doc.qt.io
	Set to very low (e.g. 0.0015)
GitHub
; in v2: bias = 0.001 * softness
GitHub
	Offset to mitigate “shadow acne” (self-shadowing artifacts)
doc.qt.io
. A small positive bias moves shadows slightly off surfaces. Qt default 10 is suitable for unit-sized scenes, but project uses a much smaller bias (~0.0015) due to its larger scale and high precision needs
GitHub
. Bias is tuned with softness in v2 to balance acne vs. peter-panning (floating shadows).
shadowFactor	real	0 – 100 (%)	(N/A)	75.0 (75% darkness)
doc.qt.io
	Uses default 75 (75% shadow)
GitHub
	How dark the shadows are. 0 = no visible shadow; 100 = fully black shadows
doc.qt.io
. Default 75 gives realistic soft shadows (25% light bleeds through). The project keeps 75, meaning shadows are fairly dark but not completely black, preserving some ambient light.
shadowMapFar	real	>0 (scene units)	(N/A)	5000.0 units
doc.qt.io
	~Not explicitly set (defaults)~	Max distance for rendering shadows from the light
doc.qt.io
. Objects beyond this range won’t cast shadows. Smaller values focus shadow detail near the origin (higher precision), but too small may clip distant shadows. Project leaves this at default ~5000 (adjusted automatically to cover the scene).
use32BitShadowmap	bool	true/false (requires Qt 6.9+)	(N/A)	false (16-bit depth)
doc.qt.io
	Not used (no 32-bit enabling)	Uses a 32-bit depth buffer for shadows when true
doc.qt.io
. Improves shadow precision (reducing banding/flicker) at cost of memory. Project did not enable this, likely using default 16-bit which is usually sufficient; no issues reported in shadows to necessitate 32-bit.

Sources: Qt 6.x Light documentation
doc.qt.io
doc.qt.io
, project QML code
GitHub
GitHub
.

Light Attenuation & Brightness
Parameter	Type	Range / Options	Default (Qt)	Usage in Project	Comment
brightness	real	≥ 0.0 (intensity multiplier)	1.0
doc.qt.io
	Increased for key/fill lights (e.g. 2.8 key, 1.2 fill)
GitHub
GitHub
	Overall strength of the light source
doc.qt.io
. Acts as a multiplier on the light’s color/intensity. Default 1 yields a physically realistic intensity given light color; higher values make the light brighter. In project, keyLight is set >2 for a strong primary source, fillLight ~0.8–1.2 for softer secondary lighting
GitHub
.
constantFade	real	≥ 0.0 (unitless)	1.0
doc.qt.io
	Uses default 1.0 (not tweaked)	Constant term in attenuation formula
doc.qt.io
doc.qt.io
. Default 1.0 means the light intensity starts at full strength. Usually kept at 1; lowering it dims light uniformly. Project leaves this at 1 (standard inverse-square law baseline).
linearFade	real	≥ 0.0 (scaled by 0.01 in formula)	0.0 (no linear term)
doc.qt.io
	Uses default 0.0	Linear attenuation factor
doc.qt.io
doc.qt.io
. Added to allow faster falloff than inverse-square. Default 0 means no linear attenuation (pure inverse-square decay). The project keeps this off (0) for physically correct lighting (no artificial linear dimming).
quadraticFade	real	≥ 0.0 (scaled by 0.0001 in formula)	1.0
doc.qt.io
	Greatly reduced for point light (e.g. 0.00008)
GitHub
	Quadratic attenuation (inverse-square law factor)
doc.qt.io
doc.qt.io
. Default 1.0 gives realistic 1/d² falloff (light intensity drops to 25% at double distance). The project’s point light uses a much smaller value (0.00008)
GitHub
 to simulate a very long-range light – essentially making attenuation negligible so the light carries far.
constant/linear/quadratic formula	–	Intensity = brightness / (constant + 0.01*linear*dist + 0.0001*quad*dist²)
doc.qt.io
doc.qt.io
	(see formula)	(above defaults yield standard inverse-square law)	Note: By default (constant=1, linear=0, quad=1), the light follows true inverse-square falloff
doc.qt.io
. The project’s tiny quadraticFade essentially flattens the falloff curve, making the point light act almost unattenuated across the scene.
ambientColor	color	Any color (RGBA)	#000000 (black)
doc.qt.io
	Not explicitly used (defaults to black)	The ambient base illumination color from this light
doc.qt.io
. Black by default (meaning no added ambient component). Rarely changed; global ambient lighting is usually done via environment maps instead. Project doesn’t set this, relying on environment ambient light (IBL).

Sources: Qt Quick3D PointLight docs
doc.qt.io
doc.qt.io
, project settings
GitHub
.

Material (PBR) Properties
Parameter	Type	Range / Values	Default (Qt)	Usage in Project	Comment
metalness	real	0.0 – 1.0 (fraction)	0.0 (non-metal)
doc.qt.io
doc.qt.io
	Set per material (e.g. 1.0 for metal parts, 0.0 for glass)
GitHub
GitHub
	Defines how “metallic” the surface is
doc.qt.io
. 0 = dielectric (plastic/wood; diffuse with low specular); 1 = metal (high reflective specular, no diffuse). Values in-between simulate semi-metals or tarnish
doc.qt.io
. Project uses 1.0 for steel parts, ~0.8–0.9 for painted metal, and 0.0 for dielectric glass and plastic components
GitHub
GitHub
.
roughness	real	0.0 – 1.0	0.0 (fully glossy)
doc.qt.io
doc.qt.io
	Set per material (e.g. 0.3 for frame, 0.05 for glass)
GitHub
GitHub
	Controls microsurface roughness (glossiness)
doc.qt.io
. 0 = perfectly smooth mirror; 1 = very rough/matte (blurry reflections)
doc.qt.io
. Project uses low roughness (≈0.3 or less) for shiny paint and glass, higher (~0.4–0.5) for duller metal surfaces
GitHub
, achieving appropriate highlight sizes on each.
indexOfRefraction (IOR)	real	~1.0 – 3.0 (physical range)	1.5 (glass/plastic)
doc.qt.io
doc.qt.io
	Used for glass (set ~1.52)
GitHub
GitHub
	Index of refraction for transparent materials
doc.qt.io
. Affects Fresnel reflectance and bending of light through the object. 1.0 = air; ~1.33 water; ~1.5 typical glass
doc.qt.io
. Project sets ~1.52 for its glass cylinder
GitHub
, matching real glass and ensuring realistic refraction and reflection behavior.
opacity	real	0.0 – 1.0 (0 = fully transparent)	1.0 (fully opaque)
doc.qt.io
	e.g. 0.35 for glass cylinder
GitHub
GitHub
	Material transparency amount. At 1.0, the object is opaque; lower values make it see-through
doc.qt.io
. The project’s “glass” material uses ~0.35 opacity (35% opaque)
GitHub
 with alpha blending
GitHub
 to simulate a translucent cylinder. Opaque materials remain at 1.0 (default).
alphaMode	enum	Opaque, Blend, Mask	Opaque (no blending)
doc.qt.io
doc.qt.io
	Used Blend for glass material
GitHub
	Determines how opacity is treated
doc.qt.io
. Opaque = no transparency (renders in opaque pass). Blend = semi-transparent blending (depth-sorted)
doc.qt.io
, used by project for glass so the 35% opacity blends with background
GitHub
. Mask = binary cutout based on opacity map.
transmissionFactor	real	0.0 – 1.0	0.0 (no light transmitted)
doc.qt.io
doc.qt.io
	Not used (left 0)	Percentage of light that passes through the surface (for transparent materials)
doc.qt.io
doc.qt.io
. 0 means fully opaque (all light is reflected/absorbed); 1.0 means fully transparent (like glass) with reflections intact. The project opted to simulate transparency via opacity and refractive IOR rather than this parameter (left at 0).
attenuationDistance	real	>0 or ∞ (world units)	∞ (no absorption)
doc.qt.io
doc.qt.io
	Not set (infinite)	Distance over which light is absorbed in a transparent material
doc.qt.io
. Represents average distance light travels before being significantly dimmed. Default infinity means clear medium (no color change through thickness). The project did not utilize volumetric absorption (the glass has no colored tint or distance-based fade).
attenuationColor	color	Any color (usually neutral or tinted)	White (#ffffff)
doc.qt.io
doc.qt.io
	Not set (white)	Color tint that transmitted light shifts to over the attenuation distance
doc.qt.io
. White (default) means no color tint in absorption. If set (e.g. blue), thick material looks that color as light gets absorbed. Not used in project (their glass remains colorless aside from base color).
clearcoatAmount	real	0.0 – 1.0	0.0 (no clearcoat)
doc.qt.io
doc.qt.io
	e.g. 0.1–0.25 on metals
GitHub
	Intensity of a transparent glossy clear coat layer on top of the material
doc.qt.io
. 0 means no clearcoat; 1 fully applied. Project adds a small clearcoat on metals (e.g. frameClearcoat 0.1) to simulate varnish or polish, giving an extra sharp reflection highlight.
clearcoatRoughnessAmount	real	0.0 – 1.0	0.0 (smooth coat)
doc.qt.io
doc.qt.io
	e.g. 0.2 on frame
GitHub
	Roughness of the clearcoat layer
doc.qt.io
. 0 = perfectly glossy clearcoat, higher values make the clearcoat itself hazy. Project uses a low value (e.g. 0.2) so the clearcoat remains shiny, adding a subtle sheen on top of the base roughness.

Sources: Qt Quick3D PrincipledMaterial docs
doc.qt.io
doc.qt.io
doc.qt.io
, project QML materials
GitHub
GitHub
.

Post-Processing Effects (ExtendedSceneEnvironment)
Parameter	Type	Values/Range	Default (Qt)	Usage in Project	Comment
Bloom (glow) – enabled	bool	true/false	false (off)
doc.qt.io
	Controlled via bloomEnabled (true by default)
GitHub
	Toggles bloom/glow effect. When on, very bright areas bleed light and glow. Project enables bloom by default, making highlights (like reflections or bright lights) bloom for a more realistic, high-dynamic-range look.
Bloom intensity	real	0.0 – 8.0 (scale)	1.0
doc.qt.io
	~0.6–0.8 in project (e.g. 0.8)
GitHub
	Strength of the bloom effect
doc.qt.io
. Acts as a multiplier on the accumulated glow. Higher values = brighter, more pronounced bloom. The project tuned this around ~0.8 (80%) for a noticeable but controlled bloom on bright highlights.
Bloom threshold	real	0.0 – ~4.0 (HDR intensity cutoff)	1.0
doc.qt.io
	~1.0 (default)
GitHub
GitHub
	Luminance threshold for bloom
doc.qt.io
. Pixels brighter than this (in HDR) will bloom. Default 1.0 means roughly any value above the normal 0-1 range triggers bloom. The project uses 1.0, meaning only very bright highlights (emissive or intense lights) bloom, preserving details in mid-bright areas.
Bloom quality high	bool	true/false	false
doc.qt.io
	Enabled (true) in project
GitHub
	Uses high-quality downsampling for bloom
doc.qt.io
. When true, more samples are used to produce a smoother glow effect at the cost of performance. The project enables this for better bloom quality, resulting in softer, more refined bloom with fewer artifacts.
Bicubic upscale	bool	true/false	false
doc.qt.io
	Enabled (true) in project
GitHub
	Reduces aliasing/blockiness in glow by using bicubic filter when upscaling blur passes
doc.qt.io
. Improves visual quality of bloom (smoother glow) at some performance cost. Project sets this true to get a cleaner bloom effect, accepting the trade-off.
SSAO – enabled	bool	true/false	false (off)
doc.qt.io
	Enabled (true)
GitHub
	Turns on Screen-Space Ambient Occlusion. When enabled, subtle contact shadows/darkening appear in creases and where objects meet, adding depth
doc.qt.io
doc.qt.io
. The project enables SSAO to enhance realism with global illumination approximation around mechanical parts.
SSAO strength	real	0.0 – 100.0 (%)	0.0 (disabled)
doc.qt.io
doc.qt.io
	~60 in project (scaled from 0.6)
GitHub
	Intensity of ambient occlusion (percentage darkness)
doc.qt.io
doc.qt.io
. 100 yields fully black crevices; lower values give lighter occlusion. Qt default 0 disables SSAO. Project sets ~60% strength (0.6 * 100) for noticeable yet not overpowering soft shadows in corners
GitHub
.
SSAO radius	real	0.0 – (scene size)	5.0
doc.qt.io
doc.qt.io
	e.g. 8.0 units (initial), later higher (200 in v2)
GitHub
GitHub
	The sample radius for occlusion in world units
doc.qt.io
. Larger radius means broader AO effect but can be costlier and may wash out small details. Default 5.0 is moderate. Project initially used 8.0 (units)
GitHub
 and later increased to a large value (200) in a scaled scene
GitHub
 to get visible AO in its meter-sized assembly, indicating tuning per scene scale.
SSAO softness	real	0.0 – 50.0	50.0
doc.qt.io
doc.qt.io
	Fixed ~20 in project
GitHub
GitHub
	How soft (blurred) the AO shadows are
doc.qt.io
. 50 (default) is maximum softness (very smooth AO), lower values make AO shading more defined. Project uses a softness of 20, producing relatively tight AO shadows so contacts aren’t too fuzzy
GitHub
.
SSAO sampleRate	int	2, 3, or 4	2 (lowest noise)
doc.qt.io
doc.qt.io
	3 (medium)
GitHub
GitHub
	Number of samples (quality) for AO noise pattern
doc.qt.io
. 2 = lowest quality (fastest), 4 = highest quality (more gray shades, less banding). Project picks 3 as a balance, reducing AO noise while not as slow as 4.
SSAO dither	bool	true/false	false
doc.qt.io
doc.qt.io
	Enabled (true)
GitHub
GitHub
	Whether to dither AO banding artifacts
doc.qt.io
. When true, introduces noise to smooth out the edges of AO shadows at the cost of some grain. The project enables dithering for AO to avoid visible rings or patterns in the ambient shadows.
Depth of Field – enabled	bool	true/false	false (off)
doc.qt.io
	Off by default (user toggle)
GitHub
; can be on	Toggles the Depth of Field blur effect. When on, objects outside the focus range are blurred, simulating camera focus. The project allows this to be turned on for cinematic effect, but keeps it off unless needed for performance reasons.
Focus distance	real	>0 (scene units)	600.0
doc.qt.io
doc.qt.io
	2000.0 in project (scene-specific)
GitHub
GitHub
	Distance from camera at which objects appear in sharp focus
doc.qt.io
. Anything at this depth is clear; closer or farther will blur. Default 600 is for typical scenes; project uses ~2000 to focus on its subject (e.g. the machinery) which is ~2m away
GitHub
.
Focus range	real	>0 (scene units)	100.0
doc.qt.io
doc.qt.io
	900.0 in project
GitHub
GitHub
	Depth range around the focus distance that remains fully sharp
doc.qt.io
. Within this range (±half on each side of focus distance) is in focus; beyond it, blur gradually increases. Project sets a fairly large range (900) to have a deep focal plane covering most of the assembly, for a mild DOF effect when enabled.
Blur amount	real	0.0 – 10.0 (blur strength)	4.0
doc.qt.io
doc.qt.io
	~3.0 in project
GitHub
GitHub
	How strong the out-of-focus blur is
doc.qt.io
. 0 = no blur, 10 = very heavy blur. Default 4.0 is a noticeable blur. Project dialed this to 3.0, giving a slightly softer blur for a less extreme DOF, so background elements are blurred but still somewhat recognizable when effect is on.
Tonemap mode	enum	None, Linear, Reinhard, Aces, HejlDawson, Filmic
doc.qt.io
doc.qt.io
	Linear (standard gamma)
doc.qt.io
doc.qt.io
	Enabled (Filmic by default, user-selectable)
GitHub
GitHub
	High dynamic range tone mapping operator
doc.qt.io
doc.qt.io
. Linear (default) just gamma-corrects to sRGB
doc.qt.io
. Other modes apply cinematic color grading: Filmic (used by project) gives a film-like contrast curve, preserving highlights
GitHub
; Reinhard and ACES are alternative HDR compression curves. Project defaults to Filmic tonemapping for a rich, high-contrast look, with options to switch via UI
GitHub
.
Exposure	real	0.0 – inf (multiplier)	1.0
doc.qt.io
	Adjusted via iblIntensity (for IBL) or fixed 1.0
GitHub
GitHub
	Global exposure adjustment applied during tonemapping
doc.qt.io
. Higher exposure brightens the final image (like camera exposure). Project sets environment exposure = 1.0 for tonemapper, but uses probeExposure to control IBL intensity (e.g. iblIntensity ~1.3 acts like exposure for environment map)
GitHub
GitHub
.
Vignette – enabled	bool	true/false	false (off)
doc.qt.io
	Enabled (true) in project v2
GitHub
	Toggles vignette effect. When on, darkens image towards the corners for a cinematic look
GitHub
. Project enables a subtle vignette to draw focus to the center.
Vignette radius	real	0.0 – 5.0	0.35
doc.qt.io
	~0.4 in project
GitHub
	Radius of the vignette (size of clear center)
doc.qt.io
. Smaller values (closer to 0) leave only a small clear area and darken most of the frame; larger radius pushes darkening to the extreme edges. Default 0.35 is moderate. Project uses 0.4, meaning slightly wider clear area before vignette fades in.
Vignette strength	real	0.0 – 15.0	15.0
doc.qt.io
	0.7 in project (gentle)
GitHub
	How dark the corners become
doc.qt.io
. 15 (default) is a very strong vignette. The project’s strength 0.7 is very mild (only slight darkening at edges), chosen to avoid overpowering the image while still focusing the viewer’s eye.
Lens Flare – enabled	bool	true/false	false (off)
doc.qt.io
	Enabled (true)
GitHub
GitHub
	Toggles lens flare artifacts for bright light sources. Off by default, but project enables it to simulate camera lens effects (glowing streaks, halos from lights) for added realism, especially around the key light acting as “sun.”
Ghost count	int	0 – 20	4
doc.qt.io
doc.qt.io
	3 in project
GitHub
	Number of lens flare “ghost” images (reflections) visible
doc.qt.io
. More ghosts = more secondary flare spots. Default 4; project uses 3 to reduce clutter while still having a noticeable flare trail
GitHub
.
Ghost dispersal	real	0.0 – 5.0	0.5
doc.qt.io
doc.qt.io
	0.6 in project
GitHub
	Spacing of lens flare ghosts along the flare line
doc.qt.io
. Higher values spread the ghost artifacts farther apart. Project uses 0.6 (a bit wider than default), making the flare appear more spread-out across the frame
GitHub
.
Halo width	real	0.0 – 1.0	0.25
doc.qt.io
doc.qt.io
	0.25 (default)
GitHub
	Size of the central halo around the light source in the lens flare
doc.qt.io
. The project leaves this at 0.25 (default), yielding a moderate halo around bright light sources.
Lens bloom bias	real	0.0 – ~1.0	0.95
doc.qt.io
doc.qt.io
	~0.35 in project
GitHub
	Brightness threshold for lens flare visibility. A lower bias value makes the lens flare more easily triggered by lights
doc.qt.io
. Qt default 0.95 is high (only extremely bright lights cause flare). Project’s 0.35 is much lower, ensuring even moderately bright highlights produce a visible lens flare effect
GitHub
.
Distortion	real	0.0 – 20.0	0.0 (none)
doc.qt.io
	Not explicitly set (0)	Chromatic aberration amount in lens flare
doc.qt.io
. Higher values introduce rainbow-like distortion in flare streaks. Project did not adjust this, leaving flares un-distorted.

Sources: Qt Quick3D ExtendedSceneEnvironment docs
doc.qt.io
doc.qt.io
doc.qt.io
doc.qt.io
, project ExtendedSceneEnvironment usage
GitHub
GitHub
GitHub
.

Camera and Environment
Parameter	Type	Values/Range	Default (Qt)	Usage in Project	Comment
Field of View (FOV)	real (degrees)	typically 30°–120° (vertical or horizontal)	60° (vertical FOV)
doc.qt.io
	~50° vertical FOV
GitHub
GitHub
	Camera aperture angle controlling how wide the view is. A larger FOV (e.g. 90°) captures more of the scene but with more perspective distortion; a smaller FOV (e.g. 30°) is zoomed-in. Qt default 60° gives a natural perspective
doc.qt.io
. The project sets ~50° for a slightly zoomed-in view on the machinery, focusing on the subject without extreme distortion
GitHub
.
clipNear	real	>0.0 (scene units)	10.0
doc.qt.io
	2.0–5.0 in project (closer near plane)
GitHub
GitHub
	Distance from camera to the near clipping plane. Objects closer than this are not rendered
doc.qt.io
. Default 10.0 may clip out very near objects. Project reduces near plane to a few units (2.0 in main, 5.0 in realism)
GitHub
 so the camera can get closer to small parts without clipping them. A too-small near can cause depth-buffer precision issues, but their values are reasonable for the scene scale.
clipFar	real	> clipNear (scene units)	10000.0
doc.qt.io
	50000.0 in project (extended far)
GitHub
	Distance to the far clipping plane. Anything beyond this distance from the camera is not drawn
doc.qt.io
. Default 10000 is suitable for many scenes; the project sets a much farther plane (50k) to accommodate its large scene (several meters in size) so distant objects (e.g. the frame corners when zoomed out) are still visible. Very large far values can reduce depth precision, but with a relatively larger near (2–5), the ratio is manageable.
backgroundMode	enum	Transparent, Color, SkyBox, SkyBoxCubeMap
felgo.com
felgo.com
	Transparent (no clear)
felgo.com
	Uses SkyBox when IBL ready, else Color
GitHub
	Determines how the scene background is rendered
felgo.com
. Color clears with a solid color (project uses a dark gray)
GitHub
. Transparent leaves background blank (composited behind UI). SkyBox draws an environment map as the backdrop
felgo.com
 – project uses this to show the HDR environment when available (falling back to color if skybox is disabled or not ready)
GitHub
.
clearColor	color	Any color (RGBA)	#000000 black
felgo.com
	Dark gray #2a2a2a when no skybox
GitHub
	The solid background color for Color mode
felgo.com
. Unused if SkyBox is active. Project sets a neutral dark gray as the background when skybox is off, to avoid a harsh black background.
lightProbe	Texture/LightProbe	HDR image or cubemap (prefiltered environment)	None (no IBL)
felgo.com
	Set to loaded HDR map (studio environment)
GitHub
GitHub
	Image-Based Lighting environment map
felgo.com
. Provides ambient lighting and reflections from a surrounding environment. The project loads an HDRI (studio.hdr) as a LightProbe and assigns it when IBL is enabled
GitHub
. This lights the scene with realistic ambient light and adds environment reflections on materials. If not set, only explicit lights contribute.
probeExposure	real	any (multiplier on IBL brightness)	1.0
felgo.com
	Exposed as iblIntensity (e.g. 1.0–1.3)
GitHub
GitHub
	Multiplier for the lightProbe’s intensity
felgo.com
. Allows tuning the brightness of environment lighting and reflections. Project links this to a UI property IBL intensity (default ~1.0)
GitHub
. For example, raising it to 1.3 makes the environment lighting 30% brighter
GitHub
, which they use to fine-tune scene lighting balance.
skyBoxCubeMap	TextureCube	Cubemap image (6 faces or HDR equirectangular)	None (unused unless set)	(Not directly used – they use lightProbe as sky)	If set and backgroundMode = SkyBoxCubeMap, this cube map is rendered as the background
felgo.com
. In the project, instead of using a separate skyBoxCubeMap, they rely on the LightProbe’s HDR for the sky (SkyBox mode uses the lightProbe’s map by default)
felgo.com
. So this parameter remains default (null).
skyBoxBlurAmount	real	0.0 – 1.0 (fraction)	0.0 (no blur)
felgo.com
GitHub
	0.0 (sharp) or user-set (project default 0)
GitHub
	Blurs the skybox/environment map for background rendering. 0 = full detail; 1 = maximum blur (smooth gradient). Useful to reduce distraction from a detailed background or simulate depth of field for distant environment. Project leaves it 0 by default (sharp background), but exposes a slider (skyboxBlur) to blur if desired
GitHub
.
fog – enabled	bool	true/false	false (off)	Off by default (can enable via UI)
GitHub
	Toggles distance fog in the scene. Not explicitly requested in question, but present in environment. The project has fog parameters (color, density) but keeps it off unless needed. Fog would fade objects with distance. (Default off, so omitted unless user turns it on.)

Sources: Qt View3D/SceneEnvironment docs
felgo.com
felgo.com
, project code for environment setup
GitHub
GitHub
.

 

Note: Parameters not utilized in the current project (e.g. transmissionFactor, attenuation, 32-bit shadows) are included for completeness but marked as not used. The table highlights which Qt Quick 3D features the project actively employs versus those simply available in Qt.