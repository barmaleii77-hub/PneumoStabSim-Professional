diff --git a/assets/qml/main.qml b/assets/qml/main.qml
index ca189328b5fbf213bcd7704fa4031db5e94687e5..7ab0ffbe5b524cf9732ba1287d3bd532468bbd72 100644
--- a/assets/qml/main.qml
+++ b/assets/qml/main.qml
@@ -18,81 +18,94 @@ Item {
 
  // ---------------------------------------------
  // Свойства и сигнал для батч-обновлений из Python
  // ---------------------------------------------
  property var pendingPythonUpdates: null
  signal batchUpdatesApplied(var summary)
 
  // Состояние симуляции, управляется из Python (MainWindow)
  property bool isRunning: false
  property real animationTime:0.0 // сек, накапливается Python-таймером
 
  // -------- Геометрия подвески (СИ) --------
  property real userFrameLength:3.2
  property real userFrameHeight:0.65
  property real userBeamSize:0.12
  property real userLeverLength:0.8
  property real userCylinderLength:0.5
  property real userTrackWidth:1.6
  property real userFrameToPivot:0.6
  property real userRodPosition:0.6
  property real userBoreHead:0.08
  property real userRodDiameter:0.035
  property real userPistonThickness:0.025
  property real userPistonRodLength:0.2
 
- // Анимация рычагов (град)
+ // Анимация (параметры панелей)
  property real userAmplitude:8.0
  property real userFrequency:1.0
  property real userPhaseGlobal:0.0
  property real userPhaseFL:0.0
  property real userPhaseFR:0.0
  property real userPhaseRL:0.0
  property real userPhaseRR:0.0
 
- // Вычисляемые углы (SLERP handled by Qt)
- property real fl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseFL) * Math.PI /180) :0.0
- property real fr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseFR) * Math.PI /180) :0.0
- property real rl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseRL) * Math.PI /180) :0.0
- property real rr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseRR) * Math.PI /180) :0.0
+ // Данные симуляции в СИ
+ property real flAngleRad:0.0
+ property real frAngleRad:0.0
+ property real rlAngleRad:0.0
+ property real rrAngleRad:0.0
+ property real fl_angle: flAngleRad *180 / Math.PI
+ property real fr_angle: frAngleRad *180 / Math.PI
+ property real rl_angle: rlAngleRad *180 / Math.PI
+ property real rr_angle: rrAngleRad *180 / Math.PI
+ property real frameHeave:0.0
+ property real frameRollRad:0.0
+ property real framePitchRad:0.0
+ property real frameRollDeg: frameRollRad *180 / Math.PI
+ property real framePitchDeg: framePitchRad *180 / Math.PI
+ property var pistonPositions: ({ fl:0.0, fr:0.0, rl:0.0, rr:0.0 })
+ property var linePressures: ({})
+ property real tankPressure:0.0
 
  // -------- Материалы/вид --------
  property color defaultClearColor: "#1a1a2e"
  property color modelBaseColor: "#9ea4ab"
  property real modelRoughness:0.35
  property real modelMetalness:0.9
 
  // ---------------------------------------------
  // Утилиты
  // ---------------------------------------------
  function setIfExists(obj, prop, value) {
- try {
- if (obj && (prop in obj || typeof obj[prop] !== 'undefined')) {
+ if (!obj)
+ return;
+ const hasProperty = Object.prototype.hasOwnProperty.call(obj, prop) || typeof obj[prop] !== 'undefined';
+ if (!hasProperty)
+ return;
  obj[prop] = value;
  }
- } catch (e) { /* ignore */ }
- }
 
  function clamp(value, minValue, maxValue) {
  if (typeof value !== 'number' || !isFinite(value))
  return minValue;
  return Math.max(minValue, Math.min(maxValue, value));
  }
 
  // ---------------------------------------------
  // Применение батч-обновлений из Python
  // ---------------------------------------------
  onPendingPythonUpdatesChanged: {
  if (!pendingPythonUpdates)
  return;
  try {
  applyBatchedUpdates(pendingPythonUpdates);
  } finally {
  pendingPythonUpdates = null; // очистка после применения
  }
  }
 
  function applyBatchedUpdates(updates) {
  if (!updates)
  return;
  var applied = {};
  if (updates.geometry) { applyGeometryUpdates(updates.geometry); applied.geometry = true; }
@@ -239,63 +252,129 @@ Item {
  if (params.oitMode) setIfExists(sceneEnvCtl, 'oitMode', String(params.oitMode));
  // Dithering
  if (params.ditheringEnabled !== undefined) setIfExists(sceneEnvCtl, 'ditheringEnabled', !!params.ditheringEnabled);
  }
 
  function applyQualityUpdates(params) {
  if (!params) return;
  if (params.aaPrimaryMode) setIfExists(sceneEnvCtl, 'aaPrimaryMode', String(params.aaPrimaryMode));
  if (params.aaQualityLevel) setIfExists(sceneEnvCtl, 'aaQualityLevel', String(params.aaQualityLevel));
  if (params.ditheringEnabled !== undefined) setIfExists(sceneEnvCtl, 'ditheringEnabled', !!params.ditheringEnabled);
  }
 
  function applyMaterialUpdates(params) {
  if (!params) return;
  // Упрощённо: применять к металлу рычагов
  if (params.baseColor) modelBaseColor = params.baseColor;
  if (params.roughness !== undefined) modelRoughness = clamp(Number(params.roughness),0.0,1.0);
  if (params.metalness !== undefined) modelMetalness = clamp(Number(params.metalness),0.0,1.0);
  }
 
  function applyEffectsUpdates(params) {
  if (!params) return;
  // Эффекты уже настраиваются через applyEnvironmentUpdates
  }
 
- function applyAnimationUpdates(params) {
- if (!params) return;
- if (params.isRunning !== undefined) isRunning = !!params.isRunning;
- if (params.amplitude !== undefined) userAmplitude = Number(params.amplitude);
- if (params.frequency !== undefined) userFrequency = Number(params.frequency);
- if (params.phase_global !== undefined) userPhaseGlobal = Number(params.phase_global);
- if (params.phase_fl !== undefined) userPhaseFL = Number(params.phase_fl);
- if (params.phase_fr !== undefined) userPhaseFR = Number(params.phase_fr);
- if (params.phase_rl !== undefined) userPhaseRL = Number(params.phase_rl);
- if (params.phase_rr !== undefined) userPhaseRR = Number(params.phase_rr);
- }
+function applyAnimationUpdates(params) {
+if (!params) return;
+if (params.isRunning !== undefined) isRunning = !!params.isRunning;
+if (params.simulationTime !== undefined) animationTime = Number(params.simulationTime);
+if (params.amplitude !== undefined) userAmplitude = Number(params.amplitude);
+if (params.frequency !== undefined) userFrequency = Number(params.frequency);
+if (params.phase_global !== undefined) userPhaseGlobal = Number(params.phase_global);
+if (params.phase_fl !== undefined) userPhaseFL = Number(params.phase_fl);
+if (params.phase_fr !== undefined) userPhaseFR = Number(params.phase_fr);
+if (params.phase_rl !== undefined) userPhaseRL = Number(params.phase_rl);
+if (params.phase_rr !== undefined) userPhaseRR = Number(params.phase_rr);
+if (params.frame) {
+ var frame = params.frame;
+ if (frame.heave !== undefined) frameHeave = Number(frame.heave);
+ if (frame.roll !== undefined) frameRollRad = Number(frame.roll);
+ if (frame.pitch !== undefined) framePitchRad = Number(frame.pitch);
+}
+if (params.leverAngles) {
+ var angles = params.leverAngles;
+ if (angles.fl !== undefined) flAngleRad = Number(angles.fl);
+ if (angles.fr !== undefined) frAngleRad = Number(angles.fr);
+ if (angles.rl !== undefined) rlAngleRad = Number(angles.rl);
+ if (angles.rr !== undefined) rrAngleRad = Number(angles.rr);
+ }
+if (params.pistonPositions) {
+ var pist = params.pistonPositions;
+ var updatedPistons = Object.assign({}, pistonPositions || {});
+ if (pist.fl !== undefined) updatedPistons.fl = Number(pist.fl);
+ if (pist.fr !== undefined) updatedPistons.fr = Number(pist.fr);
+ if (pist.rl !== undefined) updatedPistons.rl = Number(pist.rl);
+ if (pist.rr !== undefined) updatedPistons.rr = Number(pist.rr);
+ pistonPositions = updatedPistons;
+ }
+if (params.linePressures) {
+ var lp = params.linePressures;
+ var updatedPressures = Object.assign({}, linePressures || {});
+ if (lp.a1 !== undefined) updatedPressures.a1 = Number(lp.a1);
+ if (lp.b1 !== undefined) updatedPressures.b1 = Number(lp.b1);
+ if (lp.a2 !== undefined) updatedPressures.a2 = Number(lp.a2);
+ if (lp.b2 !== undefined) updatedPressures.b2 = Number(lp.b2);
+ linePressures = updatedPressures;
+ }
+if (params.tankPressure !== undefined) tankPressure = Number(params.tankPressure);
+}
 
- function apply3DUpdates(params) {
+function apply3DUpdates(params) {
+ if (!params) return;
+ if (params.frame) {
+ var frame3d = params.frame;
+ if (frame3d.heave !== undefined) frameHeave = Number(frame3d.heave);
+ if (frame3d.roll !== undefined) frameRollRad = Number(frame3d.roll);
+ if (frame3d.pitch !== undefined) framePitchRad = Number(frame3d.pitch);
+ }
+ if (params.wheels) {
+ var wheelData = params.wheels;
+ var pistons = Object.assign({}, pistonPositions || {});
+ var angleMap = { fl: "flAngleRad", fr: "frAngleRad", rl: "rlAngleRad", rr: "rrAngleRad" };
+ for (var key in wheelData) {
+ if (!wheelData.hasOwnProperty(key)) continue;
+ var wheel = wheelData[key];
+ if (!wheel) continue;
+ if (wheel.pistonPosition !== undefined) pistons[key] = Number(wheel.pistonPosition);
+ if (wheel.leverAngle !== undefined && angleMap[key] !== undefined) {
+ root[angleMap[key]] = Number(wheel.leverAngle);
+ }
+ }
+ pistonPositions = pistons;
+ }
+ if (params.lines) {
+ var lines = params.lines;
+ var updated = Object.assign({}, linePressures || {});
+ for (var name in lines) {
+ if (!lines.hasOwnProperty(name)) continue;
+ var line = lines[name];
+ if (line && line.pressure !== undefined) updated[name] = Number(line.pressure);
+ }
+ linePressures = updated;
+ }
+ if (params.tank && params.tank.pressure !== undefined) tankPressure = Number(params.tank.pressure);
  }
 
  function applyRenderSettings(params) {
  }
 
  // ---------------------------------------------
  // IBL Loader (загрузка HDR probe)
  // ---------------------------------------------
  IblProbeLoader {
  id: iblLoader
  }
 
  // ---------------------------------------------
  //3D сцена + ExtendedSceneEnvironment с IBL
  // ---------------------------------------------
  View3D {
  id: view3d
  anchors.fill: parent
 
  environment: SceneEnvironmentController {
  id: sceneEnvCtl
  iblProbe: iblLoader.probe
  backgroundColor: root.defaultClearColor
  }
 
diff --git a/assets/qml/main_v2_realism.qml b/assets/qml/main_v2_realism.qml
index 0879d26ad879933dec4a1dab4ff6a2e4a258046d..8630ff0e2d1aaa4d21cd296cb81d4278073a4dc3 100644
--- a/assets/qml/main_v2_realism.qml
+++ b/assets/qml/main_v2_realism.qml
@@ -58,69 +58,207 @@ Item {
     property real dofFocusDistance: 2000
     property real dofFocusRange: 900
 
     // --- Geometry/animation properties (unchanged) ---
     property real userFrameLength: 3200
     property real userFrameHeight: 650
     property real userBeamSize: 120
     property real userLeverLength: 800
     property real userCylinderLength: 500
     property real userTrackWidth: 1600
     property real userFrameToPivot: 600
     property real userRodPosition: 0.6
     property real userBoreHead: 80
     property real userRodDiameter: 35
     property real userPistonThickness: 25
     property real userPistonRodLength: 200
     property bool isRunning: false
     property real animationTime: 0.0
     property real userAmplitude: 8.0
     property real userFrequency: 1.0
     property real userPhaseGlobal: 0.0
     property real userPhaseFL: 0.0
     property real userPhaseFR: 0.0
     property real userPhaseRL: 0.0
     property real userPhaseRR: 0.0
-    property real fl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseFL) * Math.PI / 180) : 0.0
-    property real fr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseFR) * Math.PI / 180) : 0.0
-    property real rl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseRL) * Math.PI / 180) : 0.0
-    property real rr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseRR) * Math.PI / 180) : 0.0
+    property real flAngleRad: 0.0
+    property real frAngleRad: 0.0
+    property real rlAngleRad: 0.0
+    property real rrAngleRad: 0.0
+    property real fl_angle: flAngleRad * 180 / Math.PI
+    property real fr_angle: frAngleRad * 180 / Math.PI
+    property real rl_angle: rlAngleRad * 180 / Math.PI
+    property real rr_angle: rrAngleRad * 180 / Math.PI
+    property real frameHeave: 0.0
+    property real frameRollRad: 0.0
+    property real framePitchRad: 0.0
+    property real frameRollDeg: frameRollRad * 180 / Math.PI
+    property real framePitchDeg: framePitchRad * 180 / Math.PI
+    property var pistonPositions: ({ fl: 0.0, fr: 0.0, rl: 0.0, rr: 0.0 })
+    property var linePressures: ({})
+    property real tankPressure: 0.0
 
     // === HDR probe with fallback ===
     Texture {
         id: hdrProbe
         source: "assets/studio_small_09_2k.hdr"  // === FIXED: Relative path
     }
 
     // === Smooth camera animations ===
     Behavior on yawDeg         { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on pitchDeg       { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on cameraDistance { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on panX           { NumberAnimation { duration: 120; easing.type: Easing.OutCubic } }
     Behavior on panY           { NumberAnimation { duration: 120; easing.type: Easing.OutCubic } }
 
     // === Python integration functions ===
+    function applyAnimationUpdates(params) {
+        if (!params)
+            return
+
+        if (params.isRunning !== undefined)
+            isRunning = !!params.isRunning
+        if (params.simulationTime !== undefined)
+            animationTime = Number(params.simulationTime)
+        if (params.amplitude !== undefined)
+            userAmplitude = Number(params.amplitude)
+        if (params.frequency !== undefined)
+            userFrequency = Number(params.frequency)
+        if (params.phase_global !== undefined)
+            userPhaseGlobal = Number(params.phase_global)
+        if (params.phase_fl !== undefined)
+            userPhaseFL = Number(params.phase_fl)
+        if (params.phase_fr !== undefined)
+            userPhaseFR = Number(params.phase_fr)
+        if (params.phase_rl !== undefined)
+            userPhaseRL = Number(params.phase_rl)
+        if (params.phase_rr !== undefined)
+            userPhaseRR = Number(params.phase_rr)
+
+        if (params.frame) {
+            const frame = params.frame
+            if (frame.heave !== undefined)
+                frameHeave = Number(frame.heave)
+            if (frame.roll !== undefined)
+                frameRollRad = Number(frame.roll)
+            if (frame.pitch !== undefined)
+                framePitchRad = Number(frame.pitch)
+        }
+
+        if (params.leverAngles) {
+            const angles = params.leverAngles
+            if (angles.fl !== undefined)
+                flAngleRad = Number(angles.fl)
+            if (angles.fr !== undefined)
+                frAngleRad = Number(angles.fr)
+            if (angles.rl !== undefined)
+                rlAngleRad = Number(angles.rl)
+            if (angles.rr !== undefined)
+                rrAngleRad = Number(angles.rr)
+        }
+
+        if (params.pistonPositions) {
+            const pist = params.pistonPositions
+            const updated = Object.assign({}, pistonPositions || {})
+            if (pist.fl !== undefined)
+                updated.fl = Number(pist.fl)
+            if (pist.fr !== undefined)
+                updated.fr = Number(pist.fr)
+            if (pist.rl !== undefined)
+                updated.rl = Number(pist.rl)
+            if (pist.rr !== undefined)
+                updated.rr = Number(pist.rr)
+            pistonPositions = updated
+        }
+
+        if (params.linePressures) {
+            const lp = params.linePressures
+            const updatedPressures = Object.assign({}, linePressures || {})
+            if (lp.a1 !== undefined)
+                updatedPressures.a1 = Number(lp.a1)
+            if (lp.b1 !== undefined)
+                updatedPressures.b1 = Number(lp.b1)
+            if (lp.a2 !== undefined)
+                updatedPressures.a2 = Number(lp.a2)
+            if (lp.b2 !== undefined)
+                updatedPressures.b2 = Number(lp.b2)
+            linePressures = updatedPressures
+        }
+
+        if (params.tankPressure !== undefined)
+            tankPressure = Number(params.tankPressure)
+    }
+
+    function apply3DUpdates(params) {
+        if (!params)
+            return
+
+        if (params.frame) {
+            const frame3d = params.frame
+            if (frame3d.heave !== undefined)
+                frameHeave = Number(frame3d.heave)
+            if (frame3d.roll !== undefined)
+                frameRollRad = Number(frame3d.roll)
+            if (frame3d.pitch !== undefined)
+                framePitchRad = Number(frame3d.pitch)
+        }
+
+        if (params.wheels) {
+            const wheelData = params.wheels
+            const pistons = Object.assign({}, pistonPositions || {})
+            const angleMap = { fl: "flAngleRad", fr: "frAngleRad", rl: "rlAngleRad", rr: "rrAngleRad" }
+            for (const key in wheelData) {
+                if (!Object.prototype.hasOwnProperty.call(wheelData, key))
+                    continue
+                const wheel = wheelData[key]
+                if (!wheel)
+                    continue
+                if (wheel.pistonPosition !== undefined)
+                    pistons[key] = Number(wheel.pistonPosition)
+                if (wheel.leverAngle !== undefined && angleMap[key] !== undefined)
+                    root[angleMap[key]] = Number(wheel.leverAngle)
+            }
+            pistonPositions = pistons
+        }
+
+        if (params.lines) {
+            const lines = params.lines
+            const updated = Object.assign({}, linePressures || {})
+            for (const name in lines) {
+                if (!Object.prototype.hasOwnProperty.call(lines, name))
+                    continue
+                const line = lines[name]
+                if (line && line.pressure !== undefined)
+                    updated[name] = Number(line.pressure)
+            }
+            linePressures = updated
+        }
+
+        if (params.tank && params.tank.pressure !== undefined)
+            tankPressure = Number(params.tank.pressure)
+    }
+
     function updateGeometry(params) {
         console.log("QML: updateGeometry called with", JSON.stringify(params))
 
         if (params.frameLength !== undefined) userFrameLength = params.frameLength
         if (params.frameHeight !== undefined) userFrameHeight = params.frameHeight
         if (params.frameBeamSize !== undefined) userBeamSize = params.frameBeamSize
         if (params.leverLength !== undefined) userLeverLength = params.leverLength
         if (params.cylinderBodyLength !== undefined) userCylinderLength = params.cylinderBodyLength
         if (params.trackWidth !== undefined) userTrackWidth = params.trackWidth
         if (params.frameToPivot !== undefined) userFrameToPivot = params.frameToPivot
         if (params.rodPosition !== undefined) userRodPosition = params.rodPosition
 
         resetView() // Update camera after geometry changes
     }
 
     function updateLighting(params) {
         console.log("QML: updateLighting called with", JSON.stringify(params))
 
         if (params.key_light) {
             var kl = params.key_light
             if (kl.brightness !== undefined) keyLightBrightness = kl.brightness
             if (kl.color !== undefined) keyLightColor = kl.color
             if (kl.angle_x !== undefined) keyLightAngleX = kl.angle_x
             if (kl.angle_y !== undefined) keyLightAngleY = kl.angle_y
         }
diff --git a/src/ui/main_window/qml_bridge.py b/src/ui/main_window/qml_bridge.py
index 7b9c1950b973e03192991cd65f4768bbc57fc23c..e769a77f026bbc0a11e4cc0249b32208691593c8 100644
--- a/src/ui/main_window/qml_bridge.py
+++ b/src/ui/main_window/qml_bridge.py
@@ -1,80 +1,103 @@
 """QML Bridge Module - Python↔QML communication
 
 Модуль управления взаимодействием между Python и QML.
 Отвечает за вызов QML функций, батч-обновления и синхронизацию состояния.
 
 Russian comments / English code.
 """
 from __future__ import annotations
 
 import logging
 from pathlib import Path
 from typing import TYPE_CHECKING, Any, Dict, Optional
 
 from PySide6.QtCore import Q_ARG, QMetaObject, Qt
 
 if TYPE_CHECKING:
     from .main_window import MainWindow
 
+from src.pneumo.enums import Line, Wheel
+from src.runtime.state import StateSnapshot
+
 
 class QMLBridge:
     """Мост между Python и QML
 
     Управляет:
     - Вызовами QML функций
     - Батч-обновлениями
     - Очередью изменений
     - ACK сигналами
 
     Static methods для делегирования из MainWindow.
     """
 
     logger = logging.getLogger(__name__)
 
     # QML update method mapping
     QML_UPDATE_METHODS: Dict[str, tuple[str, ...]] = {
         "geometry": ("applyGeometryUpdates", "updateGeometry"),
         "animation": (
             "applyAnimationUpdates",
             "updateAnimation",
             "applyAnimParamsUpdates",
             "updateAnimParams",
         ),
-        "lighting": ("applyLightingUpdates", "updateLighting"),
-        "materials": ("applyMaterialUpdates", "updateMaterials"),
-        "environment": ("applyEnvironmentUpdates", "updateEnvironment"),
-        "quality": ("applyQualityUpdates", "updateQuality"),
-        "camera": ("applyCameraUpdates", "updateCamera"),
-        "effects": ("applyEffectsUpdates", "updateEffects"),
+        "lighting": (
+            "applyLightingUpdates",
+            "updateLighting",
+        ),
+        "materials": (
+            "applyMaterialUpdates",
+            "updateMaterials",
+        ),
+        "environment": (
+            "applyEnvironmentUpdates",
+            "updateEnvironment",
+        ),
+        "quality": (
+            "applyQualityUpdates",
+            "updateQuality",
+        ),
+        "camera": (
+            "applyCameraUpdates",
+            "updateCamera",
+        ),
+        "effects": (
+            "applyEffectsUpdates",
+            "updateEffects",
+        ),
     }
 
     # ------------------------------------------------------------------
     # Queue Management
     # ------------------------------------------------------------------
     @staticmethod
-    def queue_update(window: MainWindow, key: str, params: Dict[str, Any]) -> None:
+    def queue_update(
+        window: MainWindow, key: str, params: Dict[str, Any]
+    ) -> None:
         """Поставить изменения в очередь для батч-отправки в QML
 
         Args:
             window: MainWindow instance
             key: Update category (geometry, lighting, etc.)
             params: Update parameters
         """
         if not params:
             return
 
         if key not in window._qml_update_queue:
             window._qml_update_queue[key] = {}
 
         QMLBridge._deep_merge_dicts(window._qml_update_queue[key], params)
 
         if not window._qml_flush_timer.isActive():
             window._qml_flush_timer.start(0)
 
     @staticmethod
     def flush_updates(window: MainWindow) -> None:
         """Сбросить накопленные batched-обновления в QML
 
         Strategy:
         1. Try pendingPythonUpdates property (fast)
         2. Fallback to individual function calls
@@ -84,227 +107,380 @@ class QMLBridge:
         """
         if not window._qml_update_queue:
             return
 
         if not window._qml_root_object:
             # Retry later
             window._qml_flush_timer.start(100)
             return
 
         pending = window._qml_update_queue
         window._qml_update_queue = {}
 
         # Try batched push
         if QMLBridge._push_batched_updates(window, pending):
             window._last_batched_updates = pending
             return
 
         # Fallback: individual calls
         for key, payload in pending.items():
             methods = QMLBridge.QML_UPDATE_METHODS.get(key, ())
             for method_name in methods:
                 if QMLBridge.invoke_qml_function(window, method_name, payload):
                     break
 
     @staticmethod
-    def _push_batched_updates(window: MainWindow, updates: Dict[str, Any]) -> bool:
+    def _push_batched_updates(
+        window: MainWindow, updates: Dict[str, Any]
+    ) -> bool:
         """Push updates via pendingPythonUpdates property
 
         Args:
             window: MainWindow instance
             updates: Batched updates dict
 
         Returns:
             True if successful
         """
         if not updates:
             return True
         if not window._qml_root_object:
             return False
 
         try:
             sanitized = QMLBridge._prepare_for_qml(updates)
-            window._qml_root_object.setProperty("pendingPythonUpdates", sanitized)
+            window._qml_root_object.setProperty(
+                "pendingPythonUpdates",
+                sanitized,
+            )
             return True
         except Exception:
             return False
 
+    # ------------------------------------------------------------------
+    # Simulation State Synchronization
+    # ------------------------------------------------------------------
+    @staticmethod
+    def set_simulation_state(
+        window: "MainWindow", snapshot: StateSnapshot
+    ) -> bool:
+        """Push complete simulation state into QML as SI-based payload."""
+
+        if snapshot is None or not window._qml_root_object:
+            return False
+
+        try:
+            payload = QMLBridge._snapshot_to_payload(snapshot)
+            payload.setdefault("animation", {})["isRunning"] = bool(
+                getattr(window, "is_simulation_running", False)
+            )
+
+            sanitized = QMLBridge._prepare_for_qml(payload)
+            window._qml_root_object.setProperty(
+                "pendingPythonUpdates",
+                sanitized,
+            )
+            return True
+        except Exception as exc:
+            QMLBridge.logger.debug(
+                f"Failed to push simulation state: {exc}"
+            )
+            return False
+
+    @staticmethod
+    def _snapshot_to_payload(snapshot: StateSnapshot) -> Dict[str, Any]:
+        """Convert StateSnapshot dataclass into QML-friendly SI dictionary."""
+
+        wheel_key_map = {
+            Wheel.LP: "fl",
+            Wheel.PP: "fr",
+            Wheel.LZ: "rl",
+            Wheel.PZ: "rr",
+        }
+
+        wheels_payload: Dict[str, Dict[str, Any]] = {}
+        lever_angles: Dict[str, float] = {}
+        piston_positions: Dict[str, float] = {}
+
+        for wheel_enum, corner_key in wheel_key_map.items():
+            wheel_state = snapshot.wheels.get(wheel_enum)
+            if not wheel_state:
+                continue
+
+            lever_angle = float(wheel_state.lever_angle)
+            piston_position = float(wheel_state.piston_position)
+
+            wheels_payload[corner_key] = {
+                "leverAngle": lever_angle,
+                "pistonPosition": piston_position,
+                "pistonVelocity": float(wheel_state.piston_velocity),
+                "joint": {
+                    "x": float(wheel_state.joint_x),
+                    "y": float(wheel_state.joint_y),
+                    "z": float(wheel_state.joint_z),
+                },
+                "forces": {
+                    "pneumatic": float(wheel_state.force_pneumatic),
+                    "spring": float(wheel_state.force_spring),
+                    "damper": float(wheel_state.force_damper),
+                },
+            }
+
+            lever_angles[corner_key] = lever_angle
+            piston_positions[corner_key] = piston_position
+
+        line_payload: Dict[str, Dict[str, Any]] = {}
+        for line_enum in Line:
+            line_state = snapshot.lines.get(line_enum)
+            if not line_state:
+                continue
+
+            key = line_enum.value.lower()
+            line_payload[key] = {
+                "pressure": float(line_state.pressure),
+                "temperature": float(line_state.temperature),
+                "mass": float(line_state.mass),
+            }
+
+        animation_payload = {
+            "timestamp": float(snapshot.timestamp),
+            "simulationTime": float(snapshot.simulation_time),
+            "frame": {
+                "heave": float(snapshot.frame.heave),
+                "roll": float(snapshot.frame.roll),
+                "pitch": float(snapshot.frame.pitch),
+                "heaveRate": float(snapshot.frame.heave_rate),
+                "rollRate": float(snapshot.frame.roll_rate),
+                "pitchRate": float(snapshot.frame.pitch_rate),
+            },
+            "leverAngles": lever_angles,
+            "pistonPositions": piston_positions,
+            "linePressures": {
+                key: state["pressure"]
+                for key, state in line_payload.items()
+            },
+            "tankPressure": float(snapshot.tank.pressure),
+        }
+
+        three_d_payload = {
+            "wheels": wheels_payload,
+            "lines": line_payload,
+            "tank": {
+                "pressure": float(snapshot.tank.pressure),
+                "temperature": float(snapshot.tank.temperature),
+            },
+            "frame": {
+                "heave": float(snapshot.frame.heave),
+                "roll": float(snapshot.frame.roll),
+                "pitch": float(snapshot.frame.pitch),
+            },
+        }
+
+        return {
+            "animation": animation_payload,
+            "threeD": three_d_payload,
+        }
+
     # ------------------------------------------------------------------
     # Function Invocation
     # ------------------------------------------------------------------
     @staticmethod
     def invoke_qml_function(
-        window: MainWindow, method_name: str, payload: Optional[Dict[str, Any]] = None
+        window: MainWindow,
+        method_name: str,
+        payload: Optional[Dict[str, Any]] = None,
     ) -> bool:
         """Безопасный вызов QML-функции
 
         Args:
             window: MainWindow instance
             method_name: QML function name
             payload: Optional function arguments
 
         Returns:
             True if call succeeded
         """
         if not window._qml_root_object:
             return False
 
         try:
             # Log QML invoke
             try:
-                window.event_logger.log_qml_invoke(method_name, payload or {})
+                window.event_logger.log_qml_invoke(
+                    method_name,
+                    payload or {},
+                )
             except Exception:
                 pass
 
             if payload is None:
                 success = QMetaObject.invokeMethod(
                     window._qml_root_object,
                     method_name,
                     Qt.ConnectionType.DirectConnection,
                 )
             else:
                 success = QMetaObject.invokeMethod(
                     window._qml_root_object,
                     method_name,
                     Qt.ConnectionType.DirectConnection,
                     Q_ARG("QVariant", payload),
                 )
 
             return bool(success)
-        except Exception as e:
-            QMLBridge.logger.debug(f"QML call failed: {method_name} - {e}")
+        except Exception as exc:
+            QMLBridge.logger.debug(
+                f"QML call failed: {method_name} - {exc}"
+            )
             return False
 
     # ------------------------------------------------------------------
     # Data Preparation
     # ------------------------------------------------------------------
     @staticmethod
     def _prepare_for_qml(value: Any) -> Any:
         """Подготовить данные для передачи в QML
 
         Handles:
         - Nested dicts/lists
         - NumPy types
         - Path objects
 
         Args:
             value: Python value
 
         Returns:
             QML-safe value
         """
         if isinstance(value, dict):
-            return {str(k): QMLBridge._prepare_for_qml(v) for k, v in value.items()}
+            return {
+                str(k): QMLBridge._prepare_for_qml(v)
+                for k, v in value.items()
+            }
 
         if isinstance(value, (list, tuple)):
             return [QMLBridge._prepare_for_qml(i) for i in value]
 
         # NumPy conversion
         try:
             import numpy as np
 
             if isinstance(value, np.generic):
                 return value.item()
             if hasattr(value, "tolist") and callable(value.tolist):
                 return QMLBridge._prepare_for_qml(value.tolist())
         except ImportError:
             pass
 
         # Path to string
         if isinstance(value, Path):
             return str(value)
 
         return value
 
     @staticmethod
-    def _deep_merge_dicts(target: Dict[str, Any], source: Dict[str, Any]) -> None:
+    def _deep_merge_dicts(
+        target: Dict[str, Any], source: Dict[str, Any]
+    ) -> None:
         """Deep merge source dict into target
 
         Args:
             target: Target dict (modified in-place)
             source: Source dict
         """
         for k, v in source.items():
             if isinstance(v, dict) and isinstance(target.get(k), dict):
-                QMLBridge._deep_merge_dicts(target[k], v)
+                QMLBridge._deep_merge_dicts(
+                    target[k],
+                    v,
+                )
             else:
                 target[k] = v
 
     # ------------------------------------------------------------------
     # ACK Handling
     # ------------------------------------------------------------------
     @staticmethod
     def handle_qml_ack(window: MainWindow, summary: Dict[str, Any]) -> None:
         """Обработать ACK от QML после применения батч-обновлений
 
         Args:
             window: MainWindow instance
             summary: ACK summary from QML
         """
         try:
             QMLBridge.logger.info(f"QML batch ACK: {summary}")
 
             if hasattr(window, "status_bar"):
-                window.status_bar.showMessage("Обновления применены в сцене", 1500)
+                window.status_bar.showMessage(
+                    "Обновления применены в сцене",
+                    1500,
+                )
 
             # Mark changes as applied in GraphicsLogger
             if window._last_batched_updates:
                 try:
                     from ..panels.graphics_logger import get_graphics_logger
 
                     glog = get_graphics_logger()
 
                     since_ts = (
-                        summary.get("timestamp") if isinstance(summary, dict) else None
+                        summary.get("timestamp")
+                        if isinstance(summary, dict)
+                        else None
                     )
 
                     for cat, payload in window._last_batched_updates.items():
                         if isinstance(payload, dict) and payload:
                             # Log as applied
                             QMLBridge._log_graphics_change(
                                 window, str(cat), payload, applied=True
                             )
 
                             # Mark category as synced
                             try:
                                 glog.mark_category_changes_applied(
-                                    str(cat), since_timestamp=since_ts
+                                    str(cat),
+                                    since_timestamp=since_ts,
                                 )
                             except Exception:
                                 pass
 
                     window._last_batched_updates = None
                 except Exception:
                     pass
         except Exception:
             pass
 
     # ------------------------------------------------------------------
     # Graphics Logger Integration
     # ------------------------------------------------------------------
     @staticmethod
     def _log_graphics_change(
-        window: MainWindow, category: str, payload: Dict[str, Any], applied: bool
+        window: MainWindow,
+        category: str,
+        payload: Dict[str, Any],
+        applied: bool,
     ) -> None:
         """Log graphics change for sync metrics
 
         Args:
             window: MainWindow instance
             category: Change category
             payload: Change data
             applied: Whether applied to QML
         """
         try:
             from ..panels.graphics_logger import get_graphics_logger
 
             logger = get_graphics_logger()
             logger.log_change(
                 parameter_name=f"{category}_batch",
                 old_value=None,
                 new_value=payload,
                 category=category,
                 panel_state=payload,
                 qml_state={"applied": applied},
                 applied_to_qml=applied,
             )
         except Exception:
             pass
diff --git a/tests/ui/test_qml_bridge_state.py b/tests/ui/test_qml_bridge_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..275b2f9e289c6fe0135651ea3940a9a8e4bb08e3
--- /dev/null
+++ b/tests/ui/test_qml_bridge_state.py
@@ -0,0 +1,224 @@
+import importlib.util
+from pathlib import Path
+import sys
+import types
+
+import pytest
+
+from src.pneumo.enums import Line, Wheel
+
+
+def _install_qt_stubs() -> None:
+    if "PySide6" in sys.modules:
+        return
+
+    qt_module = types.ModuleType("PySide6")
+    qtcore_module = types.ModuleType("PySide6.QtCore")
+
+    class _QtNamespace:
+        ConnectionType = types.SimpleNamespace(DirectConnection=0)
+        QueuedConnection = 1
+
+    class _MetaObject:
+        @staticmethod
+        def invokeMethod(*_args, **_kwargs):  # type: ignore[override]
+            return True
+
+    def _q_arg(*_args, **_kwargs):  # type: ignore[override]
+        return None
+
+    class _Signal:
+        def __init__(self, *_args, **_kwargs):
+            self._callbacks = []
+
+        def connect(self, callback):
+            self._callbacks.append(callback)
+
+        def emit(self, *args, **kwargs):
+            for callback in list(self._callbacks):
+                callback(*args, **kwargs)
+
+    class _QObject:
+        def __init__(self, *_args, **_kwargs):
+            super().__init__()
+
+    class _QTimer:
+        def __init__(self, *_args, **_kwargs):
+            self._interval = 0
+
+        def start(self, *_args, **_kwargs):
+            return None
+
+        def stop(self):
+            return None
+
+    def _slot(*_types, **_kwargs):  # type: ignore[override]
+        def decorator(func):
+            return func
+
+        return decorator
+
+    class _QThread:
+        def start(self):
+            return None
+
+        def quit(self):
+            return None
+
+        def wait(self, *_args, **_kwargs):
+            return None
+
+    class _QPointF:
+        def __init__(self, x=0.0, y=0.0):
+            self._x = x
+            self._y = y
+
+        def x(self):
+            return self._x
+
+        def y(self):
+            return self._y
+
+    qtcore_module.Q_ARG = _q_arg  # type: ignore[attr-defined]
+    qtcore_module.QMetaObject = _MetaObject  # type: ignore[attr-defined]
+    qtcore_module.Qt = _QtNamespace()  # type: ignore[attr-defined]
+    qtcore_module.Signal = _Signal  # type: ignore[attr-defined]
+    qtcore_module.QObject = _QObject  # type: ignore[attr-defined]
+    qtcore_module.QTimer = _QTimer  # type: ignore[attr-defined]
+    qtcore_module.Slot = _slot  # type: ignore[attr-defined]
+    qtcore_module.QThread = _QThread  # type: ignore[attr-defined]
+    qtcore_module.QPointF = _QPointF  # type: ignore[attr-defined]
+
+    qtwidgets_module = types.ModuleType("PySide6.QtWidgets")
+
+    class _QWidget:
+        def __init__(self, *_args, **_kwargs):
+            super().__init__()
+
+    qtwidgets_module.QWidget = _QWidget  # type: ignore[attr-defined]
+
+    qt_module.QtCore = qtcore_module  # type: ignore[attr-defined]
+    qt_module.QtWidgets = qtwidgets_module  # type: ignore[attr-defined]
+
+    qtgui_module = types.ModuleType("PySide6.QtGui")
+
+    def _make_dummy(name):
+        return type(name, (), {"__init__": lambda self, *args, **kwargs: None})
+
+    for _name in [
+        "QPainter",
+        "QLinearGradient",
+        "QColor",
+        "QPen",
+        "QBrush",
+        "QFont",
+    ]:
+        setattr(qtgui_module, _name, _make_dummy(_name))
+
+    sys.modules["PySide6"] = qt_module
+    sys.modules["PySide6.QtCore"] = qtcore_module
+    sys.modules["PySide6.QtWidgets"] = qtwidgets_module
+    sys.modules["PySide6.QtGui"] = qtgui_module
+
+
+_install_qt_stubs()
+
+from src.runtime.state import StateSnapshot  # noqa: E402
+
+
+def _load_qml_bridge():
+    module_path = (
+        Path(__file__).resolve().parents[2]
+        / "src"
+        / "ui"
+        / "main_window"
+        / "qml_bridge.py"
+    )
+    spec = importlib.util.spec_from_file_location(
+        "src.ui.main_window.qml_bridge",
+        module_path,
+    )
+    module = importlib.util.module_from_spec(spec)
+    assert spec and spec.loader
+    sys.modules[spec.name] = module
+    spec.loader.exec_module(module)
+    return module
+
+
+QMLBridge = _load_qml_bridge().QMLBridge
+
+
+class DummyRoot:
+    def __init__(self) -> None:
+        self.properties = {}
+
+    def setProperty(self, name, value):  # noqa: N802 - Qt-style API
+        self.properties[name] = value
+        return True
+
+
+@pytest.fixture
+def snapshot() -> StateSnapshot:
+    snap = StateSnapshot()
+    snap.simulation_time = 1.234
+    snap.frame.heave = 0.02
+    snap.frame.roll = 0.15
+    snap.frame.pitch = -0.05
+
+    snap.wheels[Wheel.LP].lever_angle = 0.25
+    snap.wheels[Wheel.LP].piston_position = 0.045
+    snap.wheels[Wheel.LP].piston_velocity = 0.5
+    snap.wheels[Wheel.PP].lever_angle = -0.12
+    snap.wheels[Wheel.PP].piston_position = 0.038
+
+    snap.lines[Line.A1].pressure = 245000.0
+    snap.lines[Line.A1].temperature = 301.5
+    snap.lines[Line.A1].mass = 0.12
+    snap.lines[Line.B1].pressure = 255000.0
+
+    snap.tank.pressure = 310000.0
+    snap.tank.temperature = 305.0
+
+    return snap
+
+
+def test_set_simulation_state_pushes_si_payload(
+    snapshot: StateSnapshot,
+) -> None:
+    window = types.SimpleNamespace(
+        _qml_root_object=DummyRoot(),
+        is_simulation_running=True,
+    )
+
+    applied = QMLBridge.set_simulation_state(window, snapshot)
+
+    assert applied is True
+    payload = window._qml_root_object.properties["pendingPythonUpdates"]
+
+    animation = payload["animation"]
+    assert animation["isRunning"] is True
+    assert animation["simulationTime"] == pytest.approx(
+        snapshot.simulation_time
+    )
+    assert animation["leverAngles"]["fl"] == pytest.approx(
+        snapshot.wheels[Wheel.LP].lever_angle
+    )
+    assert animation["pistonPositions"]["fl"] == pytest.approx(
+        snapshot.wheels[Wheel.LP].piston_position
+    )
+    assert animation["linePressures"]["a1"] == pytest.approx(
+        snapshot.lines[Line.A1].pressure
+    )
+    assert animation["tankPressure"] == pytest.approx(snapshot.tank.pressure)
+
+    three_d = payload["threeD"]
+    assert three_d["wheels"]["fl"]["leverAngle"] == pytest.approx(
+        snapshot.wheels[Wheel.LP].lever_angle
+    )
+    assert three_d["wheels"]["fr"]["leverAngle"] == pytest.approx(
+        snapshot.wheels[Wheel.PP].lever_angle
+    )
+    assert three_d["lines"]["a1"]["pressure"] == pytest.approx(
+        snapshot.lines[Line.A1].pressure
+    )
+    assert three_d["tank"]["pressure"] == pytest.approx(snapshot.tank.pressure)
diff --git a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py
index 5c5cd8a5cbf74de1fb9c45e10b05d2d192f36355..00abb72bbd88057a656d3107aa17a27123bb7deb 100644
--- a/src/runtime/sim_loop.py
+++ b/src/runtime/sim_loop.py
@@ -1,125 +1,151 @@
 """
 Physics simulation loop with fixed timestep
 Runs in dedicated QThread with QTimer for precise timing
 """
 
 import time
 import logging
+from dataclasses import replace
 from typing import Optional, Dict, Any
 import numpy as np
 
 from PySide6.QtCore import QObject, QTimer, Signal, Slot, Qt
 from PySide6.QtCore import QThread
 
 from .state import (
     StateSnapshot,
     StateBus,
     FrameState,
     WheelState,
     LineState,
     TankState,
     SystemAggregates,
 )
 from .sync import (
     LatestOnlyQueue,
     PerformanceMetrics,
     TimingAccumulator,
     ThreadSafeCounter,
 )
 
 # Измененные импорты на абсолютные пути
 from src.physics.odes import RigidBody3DOF, create_initial_conditions
 from src.physics.integrator import (
     step_dynamics,
     create_default_rigid_body,
 )
 from src.pneumo.enums import (
     Wheel,
     Line,
     ThermoMode,
+    Port,
+    ReceiverVolumeMode,
 )
-from src.pneumo.receiver import ReceiverState
+from src.pneumo.receiver import ReceiverSpec, ReceiverState
 from src.pneumo.system import create_standard_diagonal_system
-from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
+from src.pneumo.gas_state import (
+    create_line_gas_state,
+    create_tank_gas_state,
+    apply_instant_volume_change,
+)
 from src.pneumo.network import GasNetwork
-from src.road.engine import RoadInput
+from src.road.engine import create_road_input_from_preset
 from src.road.scenarios import get_preset_by_name
+from src.common.units import PA_ATM, T_AMBIENT
+from src.app.config_defaults import create_default_system_configuration
 
 # Settings manager (используем абсолютный импорт, т.к. общий модуль)
 from src.common.settings_manager import get_settings_manager
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
         self.max_frame_time: float = 0.05
 
         # Simulation state
         self.is_running = False
         self.is_configured = False
         self.simulation_time = 0.0
         self.step_counter = 0
 
         # Physics objects (will be initialized in configure)
         self.rigid_body: Optional[RigidBody3DOF] = None
         self.road_input: Optional[Any] = None  # Changed type hint
         self.pneumatic_system: Optional[Any] = None
         self.gas_network: Optional[Any] = None
 
         # Current physics state
         self.physics_state: np.ndarray = np.zeros(6)  # [Y, φz, θx, dY, dφz, dθx]
+        self._prev_frame_velocities = np.zeros(3)
+        self._latest_frame_accel = np.zeros(3)
 
         # Simulation modes (overridden by persisted settings)
         self.thermo_mode = ThermoMode.ISOTHERMAL
         self.master_isolation_open = False
 
         # Receiver parameters and limits (loaded from settings)
         self.receiver_volume: float = 0.0
         self.receiver_volume_mode: str = ""
         self._volume_limits: tuple[float, float] = (0.0, 0.0)
 
+        # Cached state for snapshot creation
+        self._latest_wheel_states: Dict[Wheel, WheelState] = {
+            wheel: WheelState(wheel=wheel) for wheel in Wheel
+        }
+        self._latest_line_states: Dict[Line, LineState] = {
+            line: LineState(line=line) for line in Line
+        }
+        self._latest_tank_state = TankState()
+        self._prev_piston_positions: Dict[Wheel, float] = {
+            wheel: 0.0 for wheel in Wheel
+        }
+        self._last_road_inputs: Dict[str, float] = {
+            wheel.value: 0.0 for wheel in Wheel
+        }
+
         # Threading objects (created in target thread)
         self.physics_timer: Optional[QTimer] = None
 
         # Performance monitoring
         self.performance = PerformanceMetrics()
         self.timing_accumulator: Optional[TimingAccumulator] = None
         self.step_time_samples = []
 
         # Thread safety
         self.error_counter = ThreadSafeCounter()
 
         # Load persisted configuration
         self._load_initial_settings()
         self._apply_timing_configuration()
 
         self.logger.info(
             "PhysicsWorker settings: dt=%.6fs, vsync=%.1fHz, max_steps=%d, max_frame_time=%.3fs, "
             "receiver=%.3fm³ (%s mode)",
             self.dt_physics,
             self.vsync_render_hz,
             self.max_steps_per_frame,
             self.max_frame_time,
             self.receiver_volume,
             self.receiver_volume_mode,
         )
@@ -253,90 +279,131 @@ class PhysicsWorker(QObject):
         if isinstance(max_frame_time, (int, float)) and not isinstance(
             max_frame_time, bool
         ):
             self.max_frame_time = float(max_frame_time)
 
         # Update timing accumulator
         self._apply_timing_configuration()
 
         # Create default physics objects
         self._initialize_physics_objects()
 
         self.is_configured = True
         self.logger.info(
             f"Physics configured: dt={self.dt_physics*1000:.3f}ms, render={self.vsync_render_hz:.1f}Hz"
         )
 
     def _initialize_physics_objects(self):
         """Initialize physics simulation objects"""
         try:
             # Create 3-DOF rigid body
             self.rigid_body = create_default_rigid_body()
 
             # Initialize physics state (at rest)
             self.physics_state = create_initial_conditions()
 
-            # TODO: Initialize pneumatic system and gas network
-            # For now, create minimal stubs
-            self.pneumatic_system = None  # Will be set up later
-            self.gas_network = None
+            config_defaults = create_default_system_configuration()
 
-            # TODO: Initialize road input
-            # For now, create minimal stub
-            self.road_input = None
+            receiver_spec = ReceiverSpec(
+                V_min=self._volume_limits[0],
+                V_max=self._volume_limits[1],
+            )
+            receiver_mode = self._resolve_receiver_mode(self.receiver_volume_mode)
+            receiver_state = ReceiverState(
+                spec=receiver_spec,
+                V=self.receiver_volume,
+                p=PA_ATM,
+                T=T_AMBIENT,
+                mode=receiver_mode,
+            )
 
-            # NEW: Initialize road input with default scenario
-            road_scenario = "default_scenario"  # Заменить на нужный пресет
-            road_config = get_preset_by_name(road_scenario)
-            if road_config:
-                self.road_input = RoadInput(config=road_config)
-                self.logger.info(
-                    f"Road input initialized with scenario: {road_scenario}"
-                )
-            else:
-                self.logger.warning(f"Road scenario not found: {road_scenario}")
-                self.road_input = None  # Использовать заглушку
+            self.pneumatic_system = create_standard_diagonal_system(
+                cylinder_specs=config_defaults["cylinder_specs"],
+                line_configs=config_defaults["line_configs"],
+                receiver=receiver_state,
+                master_isolation_open=self.master_isolation_open,
+            )
 
-            # NEW: Initialize pneumatic system with standard configuration
-            try:
-                self.pneumatic_system = create_standard_diagonal_system()
-                self.logger.info(
-                    "Pneumatic system initialized with standard configuration"
+            line_volumes = self.pneumatic_system.get_line_volumes()
+            line_states: Dict[Line, Any] = {}
+            for line_name, volume_info in line_volumes.items():
+                if not isinstance(volume_info, dict) or "total_volume" not in volume_info:
+                    raise RuntimeError(
+                        f"Line volume information missing for {line_name.value}"
+                    )
+                total_volume = float(volume_info.get("total_volume"))
+                if total_volume <= 0:
+                    raise RuntimeError(
+                        f"Line {line_name.value} has non-positive volume {total_volume}"
+                    )
+                line_states[line_name] = create_line_gas_state(
+                    line_name,
+                    PA_ATM,
+                    T_AMBIENT,
+                    total_volume,
                 )
-            except Exception as e:
-                self.logger.warning(f"Failed to create standard pneumatic system: {e}")
-                self.pneumatic_system = None  # Использовать заглушку
 
-            # NEW: Initialize gas network with default parameters
-            try:
-                self.gas_network = GasNetwork()
-                self.logger.info("Gas network initialized with default parameters")
-            except Exception as e:
-                self.logger.warning(f"Failed to create gas network: {e}")
-                self.gas_network = None  # Использовать заглушку
+            tank_state = create_tank_gas_state(
+                V_initial=self.receiver_volume,
+                p_initial=PA_ATM,
+                T_initial=T_AMBIENT,
+                mode=receiver_mode,
+            )
+
+            self.gas_network = GasNetwork(
+                lines=line_states,
+                tank=tank_state,
+                system_ref=self.pneumatic_system,
+                master_isolation_open=self.master_isolation_open,
+            )
+
+            self._latest_tank_state = TankState(
+                pressure=tank_state.p,
+                temperature=tank_state.T,
+                mass=tank_state.m,
+                volume=tank_state.V,
+            )
 
-            self.logger.info("Physics objects initialized successfully")
+            for wheel, cylinder in self.pneumatic_system.cylinders.items():
+                self._prev_piston_positions[wheel] = cylinder.x
+                wheel_state = self._latest_wheel_states[wheel]
+                wheel_state.piston_position = cylinder.x
+                wheel_state.lever_angle = 0.0
+
+            preset_name = self._select_road_preset()
+            road_input = create_road_input_from_preset(preset_name)
+            road_input.configure(road_input.config, system=self.pneumatic_system)
+            road_input.prime()
+            self.road_input = road_input
+
+            if not all([self.pneumatic_system, self.gas_network, self.road_input]):
+                raise RuntimeError("Failed to initialize all physics dependencies")
+
+            self.logger.info(
+                "Physics objects initialized successfully with preset '%s'",
+                preset_name,
+            )
 
         except Exception as e:
             self.logger.error(f"Failed to initialize physics objects: {e}")
             raise
 
     @Slot()
     def start_simulation(self):
         """Start physics simulation (called from UI thread)"""
         if not self.is_configured:
             self.error_occurred.emit("Physics worker not configured")
             return
 
         if self.is_running:
             self.logger.warning("Simulation already running")
             return
 
         # Create timer in this thread (will be moved to physics thread)
         if self.physics_timer is None:
             self.physics_timer = QTimer()
             self.physics_timer.timeout.connect(self._physics_step)
             self.physics_timer.setSingleShot(False)
 
         # Start timer with high precision
         timer_interval_ms = max(1, int(self.dt_physics * 1000))  # At least 1ms
         self.physics_timer.start(timer_interval_ms)
@@ -456,55 +523,71 @@ class PhysicsWorker(QObject):
 
         self.logger.info(f"Thermo mode set to: {mode}")
 
     @Slot(bool)
     def set_master_isolation(self, open: bool):
         """Set master isolation valve state"""
         self.master_isolation_open = open
         self.logger.info(f"Master isolation: {'OPEN' if open else 'CLOSED'}")
 
     @Slot(float, str)
     def set_receiver_volume(self, volume: float, mode: str):
         """Set receiver volume and recalculation mode
 
         Args:
             volume: New receiver volume in m?
             mode: Recalculation mode ('NO_RECALC' or 'ADIABATIC_RECALC')
         """
         if volume <= 0 or volume > 1.0:  # Reasonable limits (0-1000L)
             self.error_occurred.emit(f"Invalid receiver volume: {volume} m?")
             return
 
         # Store volume and mode for gas network updates
         self.receiver_volume = volume
         self.receiver_volume_mode = mode
 
-        # TODO: Update actual ReceiverState when gas network is integrated
-        # For now, just log the change
-        self.logger.info(f"Receiver volume set: {volume:.3f}m? (mode: {mode})")
+        mode_enum = self._resolve_receiver_mode(mode)
+
+        if self.pneumatic_system is not None:
+            try:
+                self.pneumatic_system.receiver.mode = mode_enum
+                self.pneumatic_system.receiver.apply_instant_volume_change(volume)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update receiver state: {exc}")
 
-        print(f"?? PhysicsWorker: Receiver volume={volume*1000:.1f}L, mode={mode}")
+        if self.gas_network is not None:
+            try:
+                self.gas_network.tank.mode = mode_enum
+                apply_instant_volume_change(
+                    self.gas_network.tank,
+                    volume,
+                    gamma=self.gas_network.tank.gamma,
+                )
+            except Exception as exc:
+                self.logger.warning(f"Failed to update gas network tank volume: {exc}")
+
+        self.logger.info(f"Receiver volume set: {volume:.3f}m? (mode: {mode})")
 
     @Slot(float)
     def set_physics_dt(self, dt: float):
         """Change physics timestep"""
         if dt <= 0 or dt > 0.1:  # Reasonable limits
             self.error_occurred.emit(f"Invalid physics dt: {dt}")
             return
 
         old_dt = self.dt_physics
         self.dt_physics = dt
         self.timing_accumulator = TimingAccumulator(dt)
         self.performance.target_dt = dt
 
         # Restart timer if running
         if self.is_running and self.physics_timer:
             self.physics_timer.stop()
             timer_interval_ms = max(1, int(dt * 1000))
             self.physics_timer.start(timer_interval_ms)
 
         self.logger.info(f"Physics dt changed: {old_dt*1000:.3f}ms ? {dt*1000:.3f}ms")
 
     @Slot()
     def _physics_step(self):
         """Single physics simulation step (called by QTimer)"""
         if not self.is_running:
@@ -523,206 +606,317 @@ class PhysicsWorker(QObject):
             step_end_time = time.perf_counter()
             step_time = step_end_time - step_start_time
             self.performance.update_step_time(step_time)
 
             # Emit performance update periodically
             if self.step_counter % 100 == 0:  # Every 100 steps
                 self.performance_update.emit(self.performance.get_summary())
 
             # Create and emit state snapshot
             snapshot = self._create_state_snapshot()
             if snapshot and snapshot.validate():
                 self.state_ready.emit(snapshot)
             else:
                 self.error_counter.increment()
                 if self.error_counter.get() > 10:  # Too many invalid states
                     self.error_occurred.emit("Too many invalid state snapshots")
                     self.stop_simulation()
 
         except Exception as e:
             self.logger.error(f"Physics step failed: {e}")
             self.error_occurred.emit(f"Physics step error: {str(e)}")
             self.stop_simulation()
 
     def _execute_physics_step(self):
         """Execute single physics timestep"""
+        if not self.pneumatic_system or not self.gas_network or not self.road_input:
+            raise RuntimeError("Physics dependencies are not initialized")
+
         # 1. Get road inputs
         road_inputs = self._get_road_inputs()
+        self._last_road_inputs = {k: float(v) for k, v in road_inputs.items()}
 
         # 2. Update geometry/kinematics
-        if self.rigid_body:
-            try:
-                # Update lever angles and piston positions from road inputs
-                if self.pneumatic_system:
-                    for wheel, input_value in road_inputs.items():
-                        if wheel in {Wheel.LP.value, Wheel.PP.value}:  # Левые колеса
-                            cylinder = self.pneumatic_system.left_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-                        elif wheel in {Wheel.LZ.value, Wheel.PZ.value}:  # Правые колеса
-                            cylinder = self.pneumatic_system.right_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
+        lever_angles: Dict[Wheel, float] = {}
+        wheel_key_map = {
+            Wheel.LP: "LF",
+            Wheel.PP: "RF",
+            Wheel.LZ: "LR",
+            Wheel.PZ: "RR",
+        }
+
+        for wheel, key in wheel_key_map.items():
+            excitation = float(road_inputs.get(key, 0.0))
+            cylinder = self.pneumatic_system.cylinders[wheel]
+            lever = cylinder.spec.lever_geom
+            lever_length = max(lever.L_lever, 1e-6)
+            angle = float(np.clip(excitation / lever_length, -0.5, 0.5))
+            lever_angles[wheel] = angle
+
+        self.pneumatic_system.update_system_from_lever_angles(lever_angles)
+
+        for wheel, angle in lever_angles.items():
+            cylinder = self.pneumatic_system.cylinders[wheel]
+            piston_pos = float(cylinder.x)
+            prev_pos = self._prev_piston_positions.get(wheel, 0.0)
+            piston_vel = (
+                (piston_pos - prev_pos) / self.dt_physics
+                if self.dt_physics > 0
+                else 0.0
+            )
+            self._prev_piston_positions[wheel] = piston_pos
+
+            geom = cylinder.spec.geometry
+            rod_x, rod_y = cylinder.spec.lever_geom.rod_joint_pos(angle)
+            wheel_state = self._latest_wheel_states[wheel]
+            wheel_state.lever_angle = angle
+            wheel_state.piston_position = piston_pos
+            wheel_state.piston_velocity = piston_vel
+            wheel_state.vol_head = cylinder.vol_head()
+            wheel_state.vol_rod = cylinder.vol_rod()
+            wheel_state.joint_x = 0.0
+            wheel_state.joint_y = rod_x
+            wheel_state.joint_z = geom.Z_axle + rod_y
+            wheel_state.road_excitation = self._last_road_inputs.get(
+                wheel_key_map[wheel], 0.0
+            )
 
-            except Exception as e:
-                self.logger.warning(f"Failed to update kinematics: {e}")
+            head_pressure = self._get_line_pressure(wheel, Port.HEAD)
+            rod_pressure = self._get_line_pressure(wheel, Port.ROD)
+            area_head = geom.area_head(cylinder.spec.is_front)
+            area_rod = geom.area_rod(cylinder.spec.is_front)
+            wheel_state.force_pneumatic = head_pressure * area_head - rod_pressure * area_rod
 
         # 3. Update gas system
-        if self.gas_network:
+        line_volumes = self.pneumatic_system.get_line_volumes()
+        for line_name, volume_info in line_volumes.items():
+            total_volume = float(volume_info.get("total_volume"))
+            self.gas_network.lines[line_name].set_volume(total_volume)
+
+        self.gas_network.master_isolation_open = self.master_isolation_open
+        self.gas_network.update_pressures_due_to_volume(self.thermo_mode)
+
+        receiver_mode = self._resolve_receiver_mode(self.receiver_volume_mode)
+        self.gas_network.tank.mode = receiver_mode
+        if abs(self.gas_network.tank.V - self.receiver_volume) > 1e-9:
+            apply_instant_volume_change(
+                self.gas_network.tank,
+                self.receiver_volume,
+                gamma=self.gas_network.tank.gamma,
+            )
+
+        self.gas_network.apply_valves_and_flows(self.dt_physics, self.logger)
+        self.gas_network.enforce_master_isolation(self.logger)
+
+        for line_name, gas_state in self.gas_network.lines.items():
+            line_state = self._latest_line_states[line_name]
+            line_state.pressure = gas_state.p
+            line_state.temperature = gas_state.T
+            line_state.mass = gas_state.m
+            line_state.volume = gas_state.V_curr
+            pneumo_line = self.pneumatic_system.lines[line_name]
             try:
-                # Получаем текущее состояние газа в трубопроводах и резервуарах
-                line_gas_states = create_line_gas_state(self.gas_network)
-                tank_gas_states = create_tank_gas_state(self.gas_network)
-
-                # Обновляем состояния резервуаров в системе
-                for state in tank_gas_states:
-                    if state.receiver_id == "default_receiver":
-                        # Применяем новое состояние газа к резервуару
-                        receiver_state = ReceiverState(
-                            pressure=state.pressure,
-                            temperature=state.temperature,
-                            volume=self.receiver_volume,
-                        )
-                        self.gas_network.update_receiver_state(receiver_state)
+                line_state.cv_atmo_open = pneumo_line.cv_atmo.is_open(
+                    PA_ATM, gas_state.p
+                )
+            except Exception:
+                line_state.cv_atmo_open = False
+            try:
+                line_state.cv_tank_open = pneumo_line.cv_tank.is_open(
+                    gas_state.p, self.gas_network.tank.p
+                )
+            except Exception:
+                line_state.cv_tank_open = False
+            line_state.flow_atmo = 0.0
+            line_state.flow_tank = 0.0
 
-            except Exception as e:
-                self.logger.warning(f"Failed to update gas network: {e}")
+        tank_state = self.gas_network.tank
+        self._latest_tank_state.pressure = tank_state.p
+        self._latest_tank_state.temperature = tank_state.T
+        self._latest_tank_state.mass = tank_state.m
+        self._latest_tank_state.volume = tank_state.V
 
         # 4. Integrate 3-DOF dynamics
         if self.rigid_body:
             try:
-                # Use placeholder system/gas for now
                 result = step_dynamics(
                     y0=self.physics_state,
                     t0=self.simulation_time,
                     dt=self.dt_physics,
                     params=self.rigid_body,
                     system=self.pneumatic_system,
                     gas=self.gas_network,
                     method="Radau",
                 )
 
                 if result.success:
+                    prev_vel = self.physics_state[3:6].copy()
                     self.physics_state = result.y_final
+                    velocities = self.physics_state[3:6]
+                    if self.dt_physics > 0:
+                        self._latest_frame_accel = (velocities - prev_vel) / self.dt_physics
+                    self._prev_frame_velocities = velocities.copy()
                 else:
                     self.performance.integration_failures += 1
                     self.logger.warning(f"Integration failed: {result.message}")
 
             except Exception as e:
                 self.performance.integration_failures += 1
                 self.logger.error(f"Integration error: {e}")
 
         # Update simulation time and step counter
         self.simulation_time += self.dt_physics
         self.step_counter += 1
 
     def _get_road_inputs(self) -> Dict[str, float]:
         """Get road excitation for all wheels"""
         if self.road_input:
             try:
                 return self.road_input.get_wheel_excitation(self.simulation_time)
             except Exception as e:
                 self.logger.warning(f"Road input error: {e}")
 
         # Return zero excitation as fallback
-        return {"LP": 0.0, "PP": 0.0, "LZ": 0.0, "PZ": 0.0}
+        return {"LF": 0.0, "RF": 0.0, "LR": 0.0, "RR": 0.0}
 
     def _create_state_snapshot(self) -> Optional[StateSnapshot]:
         """Create current state snapshot"""
         try:
             snapshot = StateSnapshot()
 
             # Basic timing info
             snapshot.simulation_time = self.simulation_time
             snapshot.dt_physics = self.dt_physics
             snapshot.step_number = self.step_counter
 
             # Frame state from physics integration
             if len(self.physics_state) >= 6:
                 Y, phi_z, theta_x, dY, dphi_z, dtheta_x = self.physics_state
 
                 snapshot.frame = FrameState(
                     heave=float(Y),
                     roll=float(phi_z),
                     pitch=float(theta_x),
                     heave_rate=float(dY),
                     roll_rate=float(dphi_z),
                     pitch_rate=float(dtheta_x),
+                    heave_accel=float(self._latest_frame_accel[0]),
+                    roll_accel=float(self._latest_frame_accel[1]),
+                    pitch_accel=float(self._latest_frame_accel[2]),
                 )
 
             # Road excitations
-            road_excitations = self._get_road_inputs()
+            road_excitations = self._last_road_inputs
 
             # Wheel states
             for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
-                wheel_state = WheelState(wheel=wheel)
+                wheel_state = replace(self._latest_wheel_states[wheel])
 
-                # Add road excitation
                 wheel_key = wheel.value  # LP, PP, LZ, PZ
                 if wheel_key in road_excitations:
                     wheel_state.road_excitation = road_excitations[wheel_key]
 
-                # TODO: Add actual wheel state from pneumatic system
-
                 snapshot.wheels[wheel] = wheel_state
 
-            # Line states (placeholder)
+            # Line states
             for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
-                line_state = LineState(line=line)
-                # TODO: Get actual line state from gas network
-                snapshot.lines[line] = line_state
-
-            # Tank state (placeholder)
-            snapshot.tank = TankState()
+                snapshot.lines[line] = replace(self._latest_line_states[line])
 
-            # NEW: Update tank volume from receiver settings
-            snapshot.tank.volume = self.receiver_volume
+            # Tank state
+            snapshot.tank = replace(self._latest_tank_state)
 
             # System aggregates
             snapshot.aggregates = SystemAggregates(
                 physics_step_time=self.performance.avg_step_time,
                 integration_steps=self.step_counter,
                 integration_failures=self.performance.integration_failures,
             )
 
             # Configuration
             snapshot.master_isolation_open = self.master_isolation_open
             snapshot.thermo_mode = (
                 self.thermo_mode.name
                 if hasattr(self.thermo_mode, "name")
                 else str(self.thermo_mode)
             )
 
             return snapshot
 
         except Exception as e:
             self.logger.error(f"Failed to create state snapshot: {e}")
             return None
 
+    def _resolve_receiver_mode(self, mode: Optional[str] = None) -> ReceiverVolumeMode:
+        raw_mode = (mode or self.receiver_volume_mode or "MANUAL").strip().upper()
+        mapping = {
+            "MANUAL": ReceiverVolumeMode.NO_RECALC,
+            "GEOMETRIC": ReceiverVolumeMode.ADIABATIC_RECALC,
+            ReceiverVolumeMode.NO_RECALC.name: ReceiverVolumeMode.NO_RECALC,
+            ReceiverVolumeMode.ADIABATIC_RECALC.name: ReceiverVolumeMode.ADIABATIC_RECALC,
+        }
+        if raw_mode not in mapping:
+            raise RuntimeError(f"Unsupported receiver volume mode: {raw_mode}")
+        return mapping[raw_mode]
+
+    def _select_road_preset(self) -> str:
+        preset_candidates = [
+            self.settings_manager.get("simulation.road_preset", None),
+            self.settings_manager.get("modes.road_preset", None),
+            self.settings_manager.get("modes.mode_preset", None),
+        ]
+
+        for candidate in preset_candidates:
+            if candidate:
+                preset = str(candidate).strip()
+                if preset:
+                    break
+        else:
+            preset = "test_sine"
+
+        alias_map = {
+            "standard": "urban_50kmh",
+            "полная динамика": "sine_sweep",
+            "только кинематика": "test_sine",
+            "тест пневматики": "test_sine",
+        }
+
+        lookup = alias_map.get(preset.lower(), preset)
+        if get_preset_by_name(lookup) is None:
+            self.logger.warning(
+                "Unknown road preset '%s', falling back to 'test_sine'",
+                lookup,
+            )
+            lookup = "test_sine"
+        return lookup
+
+    def _get_line_pressure(self, wheel: Wheel, port: Port) -> float:
+        for line_name, line in self.pneumatic_system.lines.items():
+            for endpoint_wheel, endpoint_port in line.endpoints:
+                if endpoint_wheel == wheel and endpoint_port == port:
+                    return float(self.gas_network.lines[line_name].p)
+        return float(self.gas_network.tank.p)
+
 
 class SimulationManager(QObject):
     """High-level simulation manager
 
     Manages PhysicsWorker in separate thread and provides
     unified interface for UI interaction.
     """
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Create physics thread and worker
         self.physics_thread = QThread()
         self.physics_worker = PhysicsWorker()
 
         # Move worker to physics thread
         self.physics_worker.moveToThread(self.physics_thread)
 
         # Create state bus for communication
         self.state_bus = StateBus()
 
         # Create state queue for latest-only semantics
         self.state_queue = LatestOnlyQueue()
 
         # Connect signals
diff --git a/tests/runtime/test_sim_loop.py b/tests/runtime/test_sim_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..c4b55e10639bcff873df5d2bcab6b25b317a3fd3
--- /dev/null
+++ b/tests/runtime/test_sim_loop.py
@@ -0,0 +1,34 @@
+import pytest
+
+from src.runtime.sim_loop import PhysicsWorker
+from src.common.units import PA_ATM
+
+
+@pytest.mark.integration
+def test_physics_worker_generates_dynamic_state():
+    worker = PhysicsWorker()
+    worker.configure()
+
+    for _ in range(10):
+        worker._execute_physics_step()
+
+    snapshot = worker._create_state_snapshot()
+    assert snapshot is not None
+
+    lever_angles = [abs(state.lever_angle) for state in snapshot.wheels.values()]
+    piston_positions = [abs(state.piston_position) for state in snapshot.wheels.values()]
+    line_pressures = [state.pressure for state in snapshot.lines.values()]
+
+    assert any(angle != 0.0 for angle in lever_angles)
+    assert any(pos != 0.0 for pos in piston_positions)
+    assert any(p != PA_ATM for p in line_pressures)
+
+
+def test_execute_physics_step_requires_dependencies():
+    worker = PhysicsWorker()
+    worker.configure()
+
+    worker.gas_network = None
+
+    with pytest.raises(RuntimeError):
+        worker._execute_physics_step()
diff --git a/assets/qml/geometry/Frame.qml b/assets/qml/geometry/Frame.qml
index ae9b4d257c0089794524740e15444c600be2bf5b..952571202251c83980d3234a7e160720a538e260 100644
--- a/assets/qml/geometry/Frame.qml
+++ b/assets/qml/geometry/Frame.qml
@@ -1,66 +1,66 @@
 import QtQuick
 import QtQuick3D
 
 /*
  * Frame Component - U-shaped frame (3 beams)
  * Extracted from main.qml for modular QML architecture
  *
  * Constructs a U-frame with:
  * - Bottom horizontal beam (along Z axis)
  * - Front vertical beam (at front end)
  * - Rear vertical beam (at rear end)
  */
 Node {
     id: frame
 
     // ===============================================================
     // REQUIRED PROPERTIES
     // ===============================================================
 
     required property Node worldRoot
-    required property real beamSize       // mm - cross-section size
-    required property real frameHeight    // mm - height of vertical beams
-    required property real frameLength    // mm - length along Z axis
+    required property real beamSizeM       // m - cross-section size
+    required property real frameHeightM    // m - height of vertical beams
+    required property real frameLengthM    // m - length along Z axis
     required property var frameMaterial
 
     // ===============================================================
     // FRAME GEOMETRY (3 beams forming U-shape)
     // Центрируем U-раму относительно нуля координат по оси Z.
     // Нижняя балка проходит от -L/2 до +L/2, стойки на концах.
     // ===============================================================
 
     // 1. BOTTOM BEAM (horizontal, along Z axis) — центр по Z в 0
     Model {
         parent: worldRoot
         source: "#Cube"
-        position: Qt.vector3d(0, beamSize/2, 0)
-        scale: Qt.vector3d(beamSize/100, beamSize/100, frameLength/100)
+        position: Qt.vector3d(0, beamSizeM / 2, 0)
+        scale: Qt.vector3d(beamSizeM, beamSizeM, frameLengthM)
         materials: [frameMaterial]
     }
 
     // 2. FRONT VERTICAL BEAM (at Z = -frameLength/2 + beamSize/2)
     Model {
         parent: worldRoot
         source: "#Cube"
-        position: Qt.vector3d(0, beamSize + frameHeight/2, -frameLength/2 + beamSize/2)
-        scale: Qt.vector3d(beamSize/100, frameHeight/100, beamSize/100)
+        position: Qt.vector3d(0, beamSizeM + frameHeightM / 2, -frameLengthM / 2 + beamSizeM / 2)
+        scale: Qt.vector3d(beamSizeM, frameHeightM, beamSizeM)
         materials: [frameMaterial]
     }
 
     // 3. REAR VERTICAL BEAM (at Z = +frameLength/2 - beamSize/2)
     Model {
         parent: worldRoot
         source: "#Cube"
-        position: Qt.vector3d(0, beamSize + frameHeight/2, frameLength/2 - beamSize/2)
-        scale: Qt.vector3d(beamSize/100, frameHeight/100, beamSize/100)
+        position: Qt.vector3d(0, beamSizeM + frameHeightM / 2, frameLengthM / 2 - beamSizeM / 2)
+        scale: Qt.vector3d(beamSizeM, frameHeightM, beamSizeM)
         materials: [frameMaterial]
     }
 
     // ===============================================================
     // INITIALIZATION
     // ===============================================================
 
     Component.onCompleted: {
-        console.log("🏗️ Frame initialized (centered): " + beamSize + " × " + frameHeight + " × " + frameLength + " mm")
+        console.log("🏗️ Frame initialized (centered): " + beamSizeM.toFixed(3) + " × " + frameHeightM.toFixed(3) + " × " + frameLengthM.toFixed(3) + " m")
     }
 }
diff --git a/assets/qml/geometry/SuspensionCorner.qml b/assets/qml/geometry/SuspensionCorner.qml
index fecb805d34630c544632d5231e6891648d965ca6..a091f560b9b497ec55af9a9265babc229989e21c 100644
--- a/assets/qml/geometry/SuspensionCorner.qml
+++ b/assets/qml/geometry/SuspensionCorner.qml
@@ -1,247 +1,249 @@
 import QtQuick
 import QtQuick3D
 
 /*
  * Suspension Corner Component - Complete suspension assembly
  * Extracted from main.qml for modular QML architecture
  *
  * Includes:
  * - Lever (arm)
  * - Tail rod
  * - Cylinder body (transparent)
  * - Piston (animated)
  * - Piston rod (from piston to j_rod)
  * - 3 Cylindrical joints (tail, arm, rod)
  */
 Node {
     id: suspensionCorner
 
     // ===============================================================
     // REQUIRED PROPERTIES - Joint positions and geometry
     // ===============================================================
 
     required property vector3d j_arm      // Arm pivot point
     required property vector3d j_tail     // Tail attachment point
-    required property real leverAngle     // Lever rotation angle (degrees)
-    required property real pistonPositionFromPython  // Piston position from simulation (mm)
+    required property real leverAngleRad  // Lever rotation angle (radians)
+    required property real pistonPositionM  // Piston position from simulation (m)
 
     // ===============================================================
     // GEOMETRY PARAMETERS (from root or defaults)
     // ===============================================================
 
-    property real leverLength: 800        // мм
+    property real leverLengthM: 0.8       // м
     property real rodPosition: 0.6        // Fraction (0.0 - 1.0)
-    property real cylinderLength: 500     // мм
-    property real boreHead: 80            // мм
-    property real rodDiameter: 35         // мм
-    property real pistonThickness: 25     // мм
-    property real pistonRodLength: 200    // мм
+    property real cylinderLengthM: 0.5    // м
+    property real boreHeadM: 0.08         // м
+    property real rodDiameterM: 0.035     // м
+    property real pistonThicknessM: 0.025 // м
+    property real pistonRodLengthM: 0.2   // м
     property int cylinderSegments: 64
     property int cylinderRings: 8
     // Новый параметр длины хвостовика цилиндра (отрезок от j_tail до начала цилиндра)
-    property real tailRodLength: 100      // мм
+    property real tailRodLengthM: 0.1     // м
 
     // Масштабы шарниров (радиус/высота) как множители базовых значений
     property real jointTailScale: 1.0
     property real jointArmScale: 1.0
     property real jointRodScale: 1.0
 
     // ===============================================================
     // MATERIAL PROPERTIES (required from parent)
     // ===============================================================
 
     required property var leverMaterial
     required property var tailRodMaterial
     required property var cylinderMaterial
     required property var pistonBodyMaterial
     required property var pistonRodMaterial
     required property var jointTailMaterial
     required property var jointArmMaterial
     required property var jointRodMaterial
 
     // ===============================================================
     // CALCULATED PROPERTIES - Geometry calculations
     // ===============================================================
 
-    readonly property real baseAngle: (j_arm.x < 0) ? 180 : 0  // Left: 180°, Right: 0°
-    readonly property real totalAngle: baseAngle + leverAngle
+    readonly property real baseAngleRad: (j_arm.x < 0) ? Math.PI : 0  // Left: π, Right: 0
+    readonly property real totalAngleRad: baseAngleRad + leverAngleRad
+    readonly property real baseAngleDeg: baseAngleRad * 180 / Math.PI
+    readonly property real totalAngleDeg: totalAngleRad * 180 / Math.PI
 
     // Calculate j_rod position (rod attachment point on lever)
     readonly property vector3d j_rod: Qt.vector3d(
-        j_arm.x + (leverLength * rodPosition) * Math.cos(totalAngle * Math.PI / 180),
-        j_arm.y + (leverLength * rodPosition) * Math.sin(totalAngle * Math.PI / 180),
+        j_arm.x + (leverLengthM * rodPosition) * Math.cos(totalAngleRad),
+        j_arm.y + (leverLengthM * rodPosition) * Math.sin(totalAngleRad),
         j_arm.z
     )
 
     // Cylinder axis direction
     readonly property vector3d cylDirection: Qt.vector3d(j_rod.x - j_tail.x, j_rod.y - j_tail.y, 0)
     readonly property real cylDirectionLength: Math.hypot(cylDirection.x, cylDirection.y)
     readonly property vector3d cylDirectionNorm: Qt.vector3d(
         cylDirection.x / cylDirectionLength,
         cylDirection.y / cylDirectionLength,
         0
     )
 
     // Tail rod end position (cylinder starts here)
     readonly property vector3d tailRodEnd: Qt.vector3d(
-        j_tail.x + cylDirectionNorm.x * tailRodLength,
-        j_tail.y + cylDirectionNorm.y * tailRodLength,
+        j_tail.x + cylDirectionNorm.x * tailRodLengthM,
+        j_tail.y + cylDirectionNorm.y * tailRodLengthM,
         j_tail.z
     )
     readonly property vector3d cylStart: tailRodEnd
 
     // Cylinder end position
     readonly property vector3d cylEnd: Qt.vector3d(
-        cylStart.x + cylDirectionNorm.x * cylinderLength,
-        cylStart.y + cylDirectionNorm.y * cylinderLength,
+        cylStart.x + cylDirectionNorm.x * cylinderLengthM,
+        cylStart.y + cylDirectionNorm.y * cylinderLengthM,
         cylStart.z
     )
 
     // Piston center position (from Python simulation)
     readonly property vector3d pistonCenter: Qt.vector3d(
-        cylStart.x + cylDirectionNorm.x * pistonPositionFromPython,
-        cylStart.y + cylDirectionNorm.y * pistonPositionFromPython,
+        cylStart.x + cylDirectionNorm.x * pistonPositionM,
+        cylStart.y + cylDirectionNorm.y * pistonPositionM,
         cylStart.z
     )
 
     // ===============================================================
     // ERROR CHECKING - Rod length consistency
     // ===============================================================
 
     readonly property real rodLengthError: {
         const dx = j_rod.x - pistonCenter.x
         const dy = j_rod.y - pistonCenter.y
         const actualLength = Math.hypot(dx, dy)
-        return Math.abs(actualLength - pistonRodLength)
+        return Math.abs(actualLength - pistonRodLengthM)
     }
 
     // ===============================================================
     // VISUAL COMPONENTS
     // ===============================================================
 
     // 1. LEVER (rotating arm)
     Model {
         source: "#Cube"
         position: Qt.vector3d(
-            j_arm.x + (leverLength/2) * Math.cos(totalAngle * Math.PI / 180),
-            j_arm.y + (leverLength/2) * Math.sin(totalAngle * Math.PI / 180),
+            j_arm.x + (leverLengthM / 2) * Math.cos(totalAngleRad),
+            j_arm.y + (leverLengthM / 2) * Math.sin(totalAngleRad),
             j_arm.z
         )
-        scale: Qt.vector3d(leverLength/100, 0.8, 0.8)
-        eulerRotation: Qt.vector3d(0, 0, totalAngle)
+        scale: Qt.vector3d(leverLengthM, 0.08, 0.08)
+        eulerRotation: Qt.vector3d(0, 0, totalAngleDeg)
         materials: [leverMaterial]
     }
 
     // 2. TAIL ROD (from j_tail to cylinder start)
     Model {
         source: "#Cylinder"
         position: Qt.vector3d(
             (j_tail.x + tailRodEnd.x)/2,
             (j_tail.y + tailRodEnd.y)/2,
             j_tail.z
         )
-        scale: Qt.vector3d(0.5, tailRodLength/100, 0.5)
+        scale: Qt.vector3d(0.05, tailRodLengthM, 0.05)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(tailRodEnd.y - j_tail.y, tailRodEnd.x - j_tail.x) * 180 / Math.PI + 90)
         materials: [tailRodMaterial]
     }
 
     // 3. CYLINDER BODY (transparent, fixed)
     Model {
         source: "#Cylinder"
         position: Qt.vector3d(
             (cylStart.x + cylEnd.x)/2,
             (cylStart.y + cylEnd.y)/2,
             cylStart.z
         )
-        scale: Qt.vector3d(boreHead/100 * 1.2, cylinderLength/100, boreHead/100 * 1.2)
+        scale: Qt.vector3d(boreHeadM * 1.2, cylinderLengthM, boreHeadM * 1.2)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(cylEnd.y - cylStart.y, cylEnd.x - cylStart.x) * 180 / Math.PI + 90)
         materials: [cylinderMaterial]
     }
 
     // 4. PISTON (moving, position from Python)
     Model {
         source: "#Cylinder"
         position: pistonCenter
         // ✅ ЕДИНОЕ масштабирование /100 для согласованности
-        scale: Qt.vector3d(boreHead/100 * 1.08, pistonThickness/100, boreHead/100 * 1.08)
+        scale: Qt.vector3d(boreHeadM * 1.08, pistonThicknessM, boreHeadM * 1.08)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(cylDirection.y, cylDirection.x) * 180 / Math.PI + 90)
         materials: [pistonBodyMaterial]
     }
 
     // 5. PISTON ROD (from piston to j_rod, CONSTANT length)
     Model {
         source: "#Cylinder"
 
         // Direction from piston to j_rod
         property real rodDirX: j_rod.x - pistonCenter.x
         property real rodDirY: j_rod.y - pistonCenter.y
         property real rodDirLen: Math.hypot(rodDirX, rodDirY)
 
         // Normalized direction
         property real rodDirNormX: rodDirX / rodDirLen
         property real rodDirNormY: rodDirY / rodDirLen
 
         // Rod end position (piston + rodLength in direction of j_rod)
         property vector3d rodEnd: Qt.vector3d(
-            pistonCenter.x + rodDirNormX * pistonRodLength,
-            pistonCenter.y + rodDirNormY * pistonRodLength,
+            pistonCenter.x + rodDirNormX * pistonRodLengthM,
+            pistonCenter.y + rodDirNormY * pistonRodLengthM,
             pistonCenter.z
         )
 
         position: Qt.vector3d(
             (pistonCenter.x + rodEnd.x)/2,
             (pistonCenter.y + rodEnd.y)/2,
             pistonCenter.z
         )
         // ✅ ЕДИНОЕ масштабирование /100 для согласованности
-        scale: Qt.vector3d(rodDiameter/100 * 0.5, pistonRodLength/100, rodDiameter/100 * 0.5)
+        scale: Qt.vector3d(rodDiameterM * 0.5, pistonRodLengthM, rodDiameterM * 0.5)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(rodEnd.y - pistonCenter.y, rodEnd.x - pistonCenter.x) * 180 / Math.PI + 90)
         materials: [pistonRodMaterial]
     }
 
     // ===============================================================
     // JOINTS (cylindrical, Z-axis oriented)
     // ===============================================================
 
     // 6. TAIL JOINT (blue, at j_tail)
     Model {
         source: "#Cylinder"
         position: j_tail
         // Масштабируем базовые значения через множитель jointTailScale
         scale: Qt.vector3d(1.2 * jointTailScale, 2.4 * jointTailScale, 1.2 * jointTailScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointTailMaterial]
     }
 
     // 7. ARM JOINT (orange, at j_arm)
     Model {
         source: "#Cylinder"
         position: j_arm
         scale: Qt.vector3d(1.0 * jointArmScale, 2.0 * jointArmScale, 1.0 * jointArmScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointArmMaterial]
     }
 
     // 8. ROD JOINT (green, at j_rod)
     Model {
         source: "#Cylinder"
         position: j_rod
         scale: Qt.vector3d(0.8 * jointRodScale, 1.6 * jointRodScale, 0.8 * jointRodScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointRodMaterial]
     }
 
     // ===============================================================
     // INITIALIZATION
     // ===============================================================
 
     Component.onCompleted: {
         console.log("🔧 SuspensionCorner initialized:")
         console.log("   j_arm:", j_arm.x, j_arm.y, j_arm.z)
         console.log("   j_tail:", j_tail.x, j_tail.y, j_tail.z)
         console.log("   j_rod:", j_rod.x, j_rod.y, j_rod.z)
-        console.log("   leverAngle:", leverAngle, "deg")
-        console.log("   pistonPosition:", pistonPositionFromPython, "mm")
-        console.log("   rodLengthError:", rodLengthError.toFixed(2), "mm")
+        console.log("   leverAngle:", leverAngleRad, "rad")
+        console.log("   pistonPosition:", pistonPositionM.toFixed(4), "m")
+        console.log("   rodLengthError:", rodLengthError.toFixed(4), "m")
     }
 }
diff --git a/src/ui/geometry_bridge.py b/src/ui/geometry_bridge.py
index 2e70fb51efc06fa7552da80f8c9371060f38f678..eace992044dc72cd728b29a303871b414464e9ee 100644
--- a/src/ui/geometry_bridge.py
+++ b/src/ui/geometry_bridge.py
@@ -1,477 +1,500 @@
 # -*- coding: utf-8 -*-
+"""Geometry-to-3D bridge module.
+
+This module converts 2D suspension geometry to 3D visualization coordinates and
+is integrated with the Qt user interface layer. All dimensions are handled in
+SI units (meters and radians).
 """
-Geometry-to-3D bridge module
-Converts 2D kinematics geometry to 3D visualization coordinates
-INTEGRATED WITH USER INTERFACE CONTROLS
-"""
+
+from __future__ import annotations
+
+import math
+from typing import Any, Dict, Optional
+
 import numpy as np
+from PySide6.QtCore import QObject, Property, Signal
 from PySide6.QtGui import QVector3D
-from PySide6.QtCore import QObject, Signal, Property
-from typing import Dict, Any, Optional
 
-from ..core.settings import SettingsManager
+from ..common.settings_manager import get_settings_manager
 from ..core.geometry import GeometryParams
 
 
 class GeometryTo3DConverter(QObject):
     """Converts 2D geometry parameters to 3D visualization coordinates
     WITH USER INTERFACE INTEGRATION"""
 
     # Signals for parameter changes
     geometryChanged = Signal()
     frameChanged = Signal()
 
-    def __init__(self, geometry: GeometryParams):
-        """Initialize geometry bridge converter"""
+    def __init__(
+        self,
+        geometry: GeometryParams,
+        *,
+        settings_manager: Optional[Any] = None,
+    ):
+        """Initialize geometry bridge converter."""
         super().__init__()
         self.geometry = geometry
+        self._settings_manager = settings_manager or get_settings_manager()
+
+        defaults = self._load_geometry_defaults()
+
+        def _default(key: str, fallback: float) -> float:
+            value = defaults.get(key, fallback)
+            try:
+                return float(value)
+            except (TypeError, ValueError):
+                return float(fallback)
 
         # USER-CONTROLLABLE PARAMETERS (will be connected to UI)
-        self._frame_beam_size = 120.0  # mm - beam size
-        self._frame_height = 650.0  # mm - horn height
-        self._frame_length = 2000.0  # mm - frame length (2 meters!)
-        self._lever_length = 315.0  # mm - lever length
-        self._cylinder_body_length = 250.0  # mm - cylinder working length
-        self._tail_rod_length = 100.0  # mm - tail extension length
+        self._frame_beam_size = _default("frame_beam_size_m", 0.12)
+        self._frame_height = _default("frame_height_m", 0.65)
+        self._frame_length = _default("frame_length_m", 2.0)
+        self._lever_length = _default("lever_length_m", 0.315)
+        self._cylinder_body_length = _default("cylinder_body_length_m", 0.25)
+        self._tail_rod_length = _default("tail_rod_length_m", 0.1)
 
         # Z-coordinates for front/rear - calculated from frame length
-        self._front_z = -self._frame_length / 2.0  # Front at -1000mm
-        self._rear_z = self._frame_length / 2.0  # Rear at +1000mm
+        self._front_z = -self._frame_length / 2.0  # Front at -frame_length/2
+        self._rear_z = self._frame_length / 2.0  # Rear at +frame_length/2
 
-        print("    GeometryBridge initialized:")
-        print(
-            f"      Frame: {self._frame_length:.0f}x{self._frame_height:.0f}x{self._frame_beam_size:.0f}mm"
-        )
-        print(f"      Lever: {self._lever_length:.0f}mm")
-        print(
-            f"      Cylinder: {self._cylinder_body_length:.0f}mm + {self._tail_rod_length:.0f}mm tail"
-        )
+    # ------------------------------------------------------------------
+    # Helpers
+    # ------------------------------------------------------------------
+
+    def _load_geometry_defaults(self) -> Dict[str, Any]:
+        """Load geometry defaults from :class:`SettingsManager`."""
+
+        if self._settings_manager is None:
+            return {}
+
+        try:
+            return self._settings_manager.get_category("geometry")
+        except Exception:
+            # If the category is missing we keep the built-in fallbacks
+            return {}
 
     # USER-CONTROLLABLE PROPERTIES (connected to UI sliders/spinboxes)
 
     @Property(float, notify=frameChanged)
-    def frameLength(self):
+    def frameLength(self) -> float:
         return self._frame_length
 
     @frameLength.setter
-    def frameLength(self, value):
+    def frameLength(self, value: float) -> None:
         if self._frame_length != value:
             self._frame_length = value
             self._front_z = -value / 2.0
             self._rear_z = value / 2.0
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=frameChanged)
-    def frameHeight(self):
+    def frameHeight(self) -> float:
         return self._frame_height
 
     @frameHeight.setter
-    def frameHeight(self, value):
+    def frameHeight(self, value: float) -> None:
         if self._frame_height != value:
             self._frame_height = value
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=frameChanged)
-    def frameBeamSize(self):
+    def frameBeamSize(self) -> float:
         return self._frame_beam_size
 
     @frameBeamSize.setter
-    def frameBeamSize(self, value):
+    def frameBeamSize(self, value: float) -> None:
         if self._frame_beam_size != value:
             self._frame_beam_size = value
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
-    def leverLength(self):
+    def leverLength(self) -> float:
         return self._lever_length
 
     @leverLength.setter
-    def leverLength(self, value):
+    def leverLength(self, value: float) -> None:
         if self._lever_length != value:
             self._lever_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
-    def cylinderBodyLength(self):
+    def cylinderBodyLength(self) -> float:
         return self._cylinder_body_length
 
     @cylinderBodyLength.setter
-    def cylinderBodyLength(self, value):
+    def cylinderBodyLength(self, value: float) -> None:
         if self._cylinder_body_length != value:
             self._cylinder_body_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
-    def tailRodLength(self):
+    def tailRodLength(self) -> float:
         return self._tail_rod_length
 
     @tailRodLength.setter
-    def tailRodLength(self, value):
+    def tailRodLength(self, value: float) -> None:
         if self._tail_rod_length != value:
             self._tail_rod_length = value
             self.geometryChanged.emit()
 
     def get_frame_params(self) -> Dict[str, float]:
-        """Get frame parameters for 3D visualization"""
+        """Get frame parameters for 3D visualization in meters."""
         return {
             "beamSize": self._frame_beam_size,
             "frameHeight": self._frame_height,
             "frameLength": self._frame_length,
+            "beamSizeM": self._frame_beam_size,
+            "frameHeightM": self._frame_height,
+            "frameLengthM": self._frame_length,
         }
 
     def get_corner_3d_coords(
         self,
         corner: str,
-        lever_angle_deg: float = 0.0,
+        lever_angle_rad: float = 0.0,
         cylinder_state: Optional[Any] = None,
     ) -> Dict[str, Any]:
         """Convert 2D kinematics to 3D coordinates for one corner
         USING CORRECTED SUSPENSION MECHANICS FROM test_2m_suspension.py
 
         Args:
             corner: 'fl', 'fr', 'rl', 'rr'
-            lever_angle_deg: Current lever angle in degrees
+            lever_angle_rad: Current lever angle in radians
             cylinder_state: Optional CylinderState from physics simulation
 
         Returns:
             Dictionary with 3D coordinates for QML (compatible with CorrectedSuspensionCorner)
         """
         # Determine side and position
         is_left = corner.endswith("l")  # fl, rl = left side
         is_front = corner.startswith("f")  # fl, fr = front
 
         # Side multiplier for mirroring
         side_mult = -1.0 if is_left else 1.0
 
         # Z position (longitudinal)
         z_plane = self._front_z if is_front else self._rear_z
 
         # FIXED FRAME ATTACHMENT POINTS (never change)
 
         # Lever pivot (j_arm) - FIXED attachment to frame
-        pivot_offset_x = 150.0  # mm from center
+        pivot_offset_x = 0.15  # m from center
         pivot_height = self._frame_beam_size / 2.0  # ON BEAM AXIS
 
         j_arm = QVector3D(
             pivot_offset_x * side_mult,  # ±150mm from center
             pivot_height,  # beam axis height
             z_plane,  # EXACTLY in plane
         )
 
         # Cylinder tail (j_tail) - FIXED attachment to frame
         horn_height = self._frame_beam_size + self._frame_height  # total horn height
         tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset
-        tail_offset_x = 100.0  # mm from center
+        tail_offset_x = 0.1  # m from center
 
         j_tail = QVector3D(
             tail_offset_x * side_mult,  # ±100mm from center
             tail_height,  # horn height
             z_plane,  # EXACTLY in plane
         )
 
         # MOVING PARTS (depend on lever angle)
 
         # Base angle: LEFT side points LEFT (180°), RIGHT side points RIGHT (0°)
         base_angle_deg = 180.0 if is_left else 0.0
-        total_angle_deg = base_angle_deg + lever_angle_deg
-        total_angle_rad = np.deg2rad(total_angle_deg)
+        base_angle_rad = math.pi if is_left else 0.0
+        total_angle_rad = base_angle_rad + lever_angle_rad
+        total_angle_deg = float(np.rad2deg(total_angle_rad))
 
         # Rod attachment point on lever (at lever end)
-        rod_attach_x = j_arm.x() + self._lever_length * np.cos(total_angle_rad)
-        rod_attach_y = j_arm.y() + self._lever_length * np.sin(total_angle_rad)
+        rod_attach_x = j_arm.x() + self._lever_length * math.cos(total_angle_rad)
+        rod_attach_y = j_arm.y() + self._lever_length * math.sin(total_angle_rad)
 
         j_rod = QVector3D(rod_attach_x, rod_attach_y, z_plane)
 
         # PISTON POSITION CALCULATION
         # Calculate from GEOMETRY (correct kinematics!)
         # Distance from tail to rod attachment point
         tail_to_rod_dist = np.sqrt(
             (j_rod.x() - j_tail.x()) ** 2 + (j_rod.y() - j_tail.y()) ** 2
         )
 
         # Total assembly: tail_rod + cylinder_body + piston_rod
         # tail_rod = FIXED 100mm
         # cylinder_body = FIXED 250mm
         # piston_rod = VARIABLE (depends on lever angle!)
 
         # Calculate baseline distance (lever horizontal)
-        base_angle_rad = np.deg2rad(base_angle_deg)
-        base_rod_x = j_arm.x() + self._lever_length * np.cos(base_angle_rad)
-        base_rod_y = j_arm.y() + self._lever_length * np.sin(base_angle_rad)
+        base_angle_rad = math.pi if is_left else 0.0
+        base_rod_x = j_arm.x() + self._lever_length * math.cos(base_angle_rad)
+        base_rod_y = j_arm.y() + self._lever_length * math.sin(base_angle_rad)
         base_dist = np.sqrt(
             (base_rod_x - j_tail.x()) ** 2 + (base_rod_y - j_tail.y()) ** 2
         )
 
         # Change in distance from baseline
         delta_dist = tail_to_rod_dist - base_dist
 
         # Piston position inside cylinder:
         # When lever is horizontal (baseline), piston is centered
         # When lever rotates, distance changes ? piston moves
         # Piston moves IN SAME DIRECTION as rod extension
         # (if rod extends/distance increases, piston moves toward rod end/increases)
         # CORRECTED: Use PLUS (not minus) because piston follows rod extension
-        piston_position_mm = (self._cylinder_body_length / 2.0) + delta_dist
+        piston_position = (self._cylinder_body_length / 2.0) + delta_dist
 
         # Clip to safe range (10% to 90% of cylinder length)
-        piston_position_mm = float(
+        piston_position = float(
             np.clip(
-                piston_position_mm,
+                piston_position,
                 self._cylinder_body_length
                 * 0.1,  # 10% minimum (25mm for 250mm cylinder)
                 self._cylinder_body_length
                 * 0.9,  # 90% maximum (225mm for 250mm cylinder)
             )
         )
 
         # Calculate ratio for QML
-        piston_ratio = float(piston_position_mm / self._cylinder_body_length)
+        piston_ratio = float(piston_position / self._cylinder_body_length)
 
         # If cylinder_state provided, OVERRIDE with physics data
         if cylinder_state is not None:
             # Use actual physics data from CylinderKinematics
-            stroke_mm = cylinder_state.stroke * 1000.0  # m to mm
-
             # Calculate piston position from stroke
             # Assuming stroke 0 = center of cylinder
-            max_stroke_mm = self._cylinder_body_length * 0.4  # ±40% stroke range
-            piston_ratio_physics = 0.5 + (stroke_mm / (2 * max_stroke_mm))
+            stroke_m = cylinder_state.stroke
+            max_stroke = self._cylinder_body_length * 0.4  # ±40% stroke range
+            piston_ratio_physics = 0.5 + (stroke_m / (2 * max_stroke))
             piston_ratio_physics = float(np.clip(piston_ratio_physics, 0.1, 0.9))
-            piston_position_mm_physics = (
+            piston_position_physics = (
                 piston_ratio_physics * self._cylinder_body_length
             )
 
             # Use physics values
-            piston_position_mm = float(piston_position_mm_physics)
+            piston_position = float(piston_position_physics)
             piston_ratio = float(piston_ratio_physics)
 
         # Return data compatible with CorrectedSuspensionCorner.qml
         result = {
             # FIXED joints
             "j_arm": j_arm,  # Lever pivot (orange joint)
             "j_tail": j_tail,  # Cylinder mount (blue joint)
             "j_rod": j_rod,  # Rod attachment (green joint)
             # Animation
-            "leverAngle": float(lever_angle_deg),
+            "leverAngle": float(np.rad2deg(lever_angle_rad)),
+            "leverAngleRad": float(lever_angle_rad),
+            "totalAngleRad": float(total_angle_rad),
             # Dimensions (for QML calculations)
             "leverLength": float(self._lever_length),
             "cylinderBodyLength": float(self._cylinder_body_length),
             "tailRodLength": float(self._tail_rod_length),
             # PISTON POSITION (ALWAYS float, never None or empty!)
-            "pistonPositionMm": float(
-                piston_position_mm
-            ),  # Absolute position in cylinder (mm)
+            "pistonPosition": float(
+                piston_position
+            ),  # Absolute position in cylinder (m)
             "pistonRatio": float(piston_ratio),  # Ratio 0..1 inside cylinder
             # Additional data for UI
             "corner": corner,
             "totalAngle": float(total_angle_deg),
             "baseAngle": float(base_angle_deg),
             "side": "left" if is_left else "right",
             "position": "front" if is_front else "rear",
         }
 
         # If cylinder_state provided, add full physics data
         if cylinder_state is not None:
             result["cylinderPhysics"] = {
                 "stroke": cylinder_state.stroke,
                 "strokeVelocity": cylinder_state.stroke_velocity,
                 "volumeHead": cylinder_state.volume_head,
                 "volumeRod": cylinder_state.volume_rod,
                 "distance": cylinder_state.distance,
                 "axisAngle": cylinder_state.cylinder_axis_angle,
             }
 
         return result
 
     def get_all_corners_3d(
         self,
         lever_angles: Optional[Dict[str, float]] = None,
         cylinder_states: Optional[Dict[str, Any]] = None,
     ) -> Dict[str, Dict[str, Any]]:
         """Get 3D coordinates for all 4 corners
 
         Args:
-            lever_angles: Optional dict with current lever angles {'fl': deg, 'fr': deg, 'rl': deg, 'rr': deg}
+            lever_angles: Optional dict with current lever angles {'fl': rad, 'fr': rad, 'rl': rad, 'rr': rad}
             cylinder_states: Optional dict with CylinderState objects for each corner
 
         Returns:
             Dictionary with all corner coordinates
         """
         if lever_angles is None:
             lever_angles = {"fl": 0.0, "fr": 0.0, "rl": 0.0, "rr": 0.0}
 
         if cylinder_states is None:
             cylinder_states = {}
 
         corners = {}
         for corner in ["fl", "fr", "rl", "rr"]:
             angle = lever_angles.get(corner, 0.0)
             cyl_state = cylinder_states.get(corner, None)
             corners[corner] = self.get_corner_3d_coords(corner, angle, cyl_state)
 
         return corners
 
     def update_from_simulation(self, sim_state: Dict[str, Any]) -> Dict[str, Any]:
         """Update 3D coordinates from simulation state
 
         Args:
             sim_state: Current simulation state with lever angles, cylinder states, etc.
 
         Returns:
             Complete geometry data for 3D scene update
         """
         # Extract lever angles from simulation
         lever_angles = {}
 
         if "lever_angles" in sim_state:
             lever_angles = sim_state["lever_angles"]
         else:
             # Extract from individual angle fields
             lever_angles = {
                 "fl": sim_state.get("fl_angle", 0.0),
                 "fr": sim_state.get("fr_angle", 0.0),
                 "rl": sim_state.get("rl_angle", 0.0),
                 "rr": sim_state.get("rr_angle", 0.0),
             }
 
+        # Ensure angles are in radians (tolerate legacy degrees)
+        for key, value in list(lever_angles.items()):
+            if isinstance(value, (int, float)) and abs(value) > math.tau:
+                lever_angles[key] = math.radians(value)
+
         # Extract cylinder states (if available)
         cylinder_states = {}
         if "cylinder_states" in sim_state:
             cylinder_states = sim_state["cylinder_states"]
         elif "corners" in sim_state:
             # Try to extract from corners structure
             for corner, data in sim_state.get("corners", {}).items():
                 if "cylinder_state" in data:
                     cylinder_states[corner] = data["cylinder_state"]
 
         return {
             "frame": self.get_frame_params(),
             "corners": self.get_all_corners_3d(lever_angles, cylinder_states),
             # Add user-controllable parameters
             "userParams": {
                 "frameLength": self._frame_length,
                 "frameHeight": self._frame_height,
                 "frameBeamSize": self._frame_beam_size,
                 "leverLength": self._lever_length,
                 "cylinderBodyLength": self._cylinder_body_length,
                 "tailRodLength": self._tail_rod_length,
             },
         }
 
     def update_user_parameters(self, params: Dict[str, float], persist: bool = False):
         """Update multiple user parameters at once
 
         Args:
             params: Dictionary with parameter names and values
             persist: If True, persist changes to settings manager
         """
-        changed = False
-
         if "frameLength" in params and params["frameLength"] != self._frame_length:
             self.frameLength = params["frameLength"]
-            changed = True
 
         if "frameHeight" in params and params["frameHeight"] != self._frame_height:
             self.frameHeight = params["frameHeight"]
-            changed = True
 
         if (
             "frameBeamSize" in params
             and params["frameBeamSize"] != self._frame_beam_size
         ):
             self.frameBeamSize = params["frameBeamSize"]
-            changed = True
 
         if "leverLength" in params and params["leverLength"] != self._lever_length:
             self.leverLength = params["leverLength"]
-            changed = True
 
         if (
             "cylinderBodyLength" in params
             and params["cylinderBodyLength"] != self._cylinder_body_length
         ):
             self.cylinderBodyLength = params["cylinderBodyLength"]
-            changed = True
 
         if (
             "tailRodLength" in params
             and params["tailRodLength"] != self._tail_rod_length
         ):
             self.tailRodLength = params["tailRodLength"]
-            changed = True
-
-        if changed:
-            print(f"    GeometryBridge updated: {params}")
 
         # Persist changes to settings manager
         if persist:
             self.save_to_settings()
 
     def save_to_settings(self):
         """Save current geometry settings to persistent storage"""
-        # Collect settings data
-        settings_data = {
-            "frameLength": self._frame_length,
-            "frameHeight": self._frame_height,
-            "frameBeamSize": self._frame_beam_size,
-            "leverLength": self._lever_length,
-            "cylinderBodyLength": self._cylinder_body_length,
-            "tailRodLength": self._tail_rod_length,
-        }
-
-        # Update settings manager
-        SettingsManager.set_geometry_settings(settings_data)
-
-        print(f"    Geometry settings saved: {settings_data}")
+        if self._settings_manager is None:
+            return
+
+        manager = self._settings_manager
+        manager.set("geometry.frame_length_m", self._frame_length, auto_save=False)
+        manager.set("geometry.frame_height_m", self._frame_height, auto_save=False)
+        manager.set("geometry.frame_beam_size_m", self._frame_beam_size, auto_save=False)
+        manager.set("geometry.lever_length_m", self._lever_length, auto_save=False)
+        manager.set(
+            "geometry.cylinder_body_length_m",
+            self._cylinder_body_length,
+            auto_save=False,
+        )
+        manager.set("geometry.tail_rod_length_m", self._tail_rod_length, auto_save=False)
+        manager.save()
 
     def export_geometry_params(self) -> Dict[str, Any]:
         """Export current geometry parameters as dictionary
 
         Returns:
             Dictionary with geometry parameters for export
         """
         return {
             "frameLength": self._frame_length,
             "frameHeight": self._frame_height,
             "frameBeamSize": self._frame_beam_size,
             "leverLength": self._lever_length,
             "cylinderBodyLength": self._cylinder_body_length,
             "tailRodLength": self._tail_rod_length,
         }
 
 
 # Convenience function for easy integration
 def create_geometry_converter(
     wheelbase: float = 2.0,
     lever_length: float = 0.315,
     cylinder_diameter: float = 0.08,
     settings_manager: Optional[Any] = None,
 ) -> GeometryTo3DConverter:
     """Create geometry converter with common parameters
 
     Args:
         wheelbase: Vehicle track width in meters
         lever_length: Suspension lever length in meters
         cylinder_diameter: Cylinder bore diameter in meters
         settings_manager: Optional SettingsManager instance for persistent settings
 
     Returns:
         Configured GeometryTo3DConverter
     """
     geometry = GeometryParams()
     geometry.wheelbase = wheelbase
     geometry.lever_length = lever_length
     geometry.cylinder_inner_diameter = cylinder_diameter
     geometry.enforce_track_from_geometry()  # Ensure consistency
 
-    converter = GeometryTo3DConverter(geometry)
-
-    # Load settings from manager if available
-    if settings_manager is not None:
-        settings = settings_manager.get_geometry_settings()
-        converter.update_user_parameters(settings, persist=False)
+    converter = GeometryTo3DConverter(geometry, settings_manager=settings_manager)
 
     return converter
diff --git a/src/ui/main_window_backup.py b/src/ui/main_window_backup.py
index c5b33240ad03ade6217bc93ae619bcd797aa35dd..45929e60aa841c79a2331dbfb401e9e2857875b4 100644
--- a/src/ui/main_window_backup.py
+++ b/src/ui/main_window_backup.py
@@ -712,56 +712,56 @@ class MainWindow(QMainWindow):
                 "rl": {
                     "leverAngle": amplitude
                     * np.sin(omega * t + np.deg2rad(phase_global + phase_rl)),
                     "cylinderState": None,
                 },
                 "rr": {
                     "leverAngle": amplitude
                     * np.sin(omega * t + np.deg2rad(phase_global + phase_rr)),
                     "cylinderState": None,
                 },
             }
 
             # CRITICAL: Calculate piston positions using GeometryBridge!
             piston_positions = {}
             lever_angles = {}
 
             for corner, data in corners_data.items():
                 angle = data["leverAngle"]
                 lever_angles[corner] = angle  # Store for QML update
 
                 # Use GeometryBridge to calculate CORRECT piston position from angle
                 if hasattr(self, "geometry_converter"):
                     corner_3d = self.geometry_converter.get_corner_3d_coords(
                         corner, angle, None  # No physics state, pure geometry
                     )
-                    piston_positions[corner] = corner_3d.get("pistonPositionMm", 125.0)
+                    piston_positions[corner] = corner_3d.get("pistonPosition", 0.125)
                 else:
                     # Fallback without GeometryBridge
                     piston_ratio = 0.5 + angle / 20.0
                     piston_ratio = np.clip(piston_ratio, 0.1, 0.9)
-                    piston_positions[corner] = piston_ratio * 250.0
+                    piston_positions[corner] = piston_ratio * 0.25
 
             # Update animation time in QML (for smooth interpolation if needed)
             if hasattr(snapshot, "simulation_time"):
                 self._qml_root_object.setProperty(
                     "animationTime", snapshot.simulation_time
                 )
 
             # CRITICAL: Update lever angles FIRST (so j_rod positions are correct)
             from PySide6.QtCore import QMetaObject, Q_ARG, Qt as _Qt
 
             # WORKAROUND: Set angles directly via properties instead of method call
             # This is more reliable than invokeMethod for simple value updates
             for corner, angle in lever_angles.items():
                 prop_name = f"{corner}_angle"
                 self._qml_root_object.setProperty(prop_name, float(angle))
 
             # CRITICAL: Update piston positions SECOND (after angles are set)
             if piston_positions:
                 success_pistons = QMetaObject.invokeMethod(
                     self._qml_root_object,
                     "updatePistonPositions",
                     _Qt.ConnectionType.DirectConnection,
                     Q_ARG("QVariant", piston_positions),
                 )
 
diff --git a/tests/ui/test_geometry_bridge_units.py b/tests/ui/test_geometry_bridge_units.py
new file mode 100644
index 0000000000000000000000000000000000000000..9539f863edca08dfb2a17f89a0902572818d1766
--- /dev/null
+++ b/tests/ui/test_geometry_bridge_units.py
@@ -0,0 +1,97 @@
+# -*- coding: utf-8 -*-
+"""Tests for GeometryTo3DConverter SI units output."""
+
+from __future__ import annotations
+
+import importlib.util
+import math
+from pathlib import Path
+
+import pytest
+
+from src.common.settings_manager import get_settings_manager
+from src.core.geometry import GeometryParams
+_GEOMETRY_BRIDGE_PATH = Path(__file__).resolve().parents[2] / "src" / "ui" / "geometry_bridge.py"
+
+
+def _load_geometry_bridge():
+    spec = importlib.util.spec_from_file_location(
+        "geometry_bridge", _GEOMETRY_BRIDGE_PATH
+    )
+    module = importlib.util.module_from_spec(spec)
+    assert spec.loader is not None
+    spec.loader.exec_module(module)
+    return module
+
+
+try:
+    _geometry_bridge = _load_geometry_bridge()
+except ImportError as exc:  # pragma: no cover - environment specific
+    pytest.skip(
+        f"Geometry bridge requires PySide6: {exc}", allow_module_level=True
+    )
+else:
+    GeometryTo3DConverter = _geometry_bridge.GeometryTo3DConverter
+
+
+@pytest.fixture()
+def converter() -> GeometryTo3DConverter:
+    """Create converter with defaults from SettingsManager."""
+    geometry = GeometryParams()
+    manager = get_settings_manager()
+    return GeometryTo3DConverter(geometry, settings_manager=manager)
+
+
+def test_defaults_loaded_in_meters(converter: GeometryTo3DConverter) -> None:
+    """Ensure default parameters are read in meters from SettingsManager."""
+    manager = get_settings_manager()
+    defaults = manager.get_category("geometry")
+    frame_params = converter.get_frame_params()
+
+    expected_frame_length = float(defaults.get("frame_length_m", 2.0))
+    expected_frame_height = float(defaults.get("frame_height_m", 0.65))
+    expected_beam_size = float(defaults.get("frame_beam_size_m", 0.12))
+
+    assert frame_params["frameLength"] == pytest.approx(expected_frame_length)
+    assert frame_params["frameHeight"] == pytest.approx(expected_frame_height)
+    assert frame_params["beamSize"] == pytest.approx(expected_beam_size)
+
+    exported = converter.export_geometry_params()
+    assert exported["leverLength"] < 10.0
+    assert exported["leverLength"] == pytest.approx(
+        float(defaults.get("lever_length_m", exported["leverLength"]))
+    )
+
+
+def test_corner_coordinates_are_meter_based(converter: GeometryTo3DConverter) -> None:
+    """Check that coordinates and piston position are calculated in meters."""
+    frame = converter.get_frame_params()
+    frame_length = frame["frameLength"]
+    beam_half = frame["beamSize"] / 2.0
+
+    lever_length = converter.leverLength
+    cylinder_length = converter.cylinderBodyLength
+
+    front_left_zero = converter.get_corner_3d_coords("fl", 0.0)
+    assert front_left_zero["j_arm"].x() == pytest.approx(-0.15)
+    assert front_left_zero["j_arm"].y() == pytest.approx(beam_half)
+    assert front_left_zero["j_tail"].z() == pytest.approx(-frame_length / 2.0)
+    assert front_left_zero["pistonPosition"] == pytest.approx(cylinder_length / 2.0)
+
+    angle = math.radians(12.0)
+    front_right = converter.get_corner_3d_coords("fr", angle)
+    expected_x = 0.15 + lever_length * math.cos(angle)
+    expected_y = beam_half + lever_length * math.sin(angle)
+    assert front_right["j_arm"].x() == pytest.approx(0.15)
+    assert front_right["j_rod"].x() == pytest.approx(expected_x)
+    assert front_right["j_rod"].y() == pytest.approx(expected_y)
+    assert front_right["totalAngleRad"] == pytest.approx(angle)
+    assert 0.0 < front_right["pistonPosition"] < cylinder_length
+
+    rear_left = converter.get_corner_3d_coords("rl", 0.0)
+    assert rear_left["j_arm"].z() == pytest.approx(frame_length / 2.0)
+    assert rear_left["j_tail"].z() == pytest.approx(frame_length / 2.0)
+
+
+if __name__ == "__main__":
+    pytest.main([__file__, "-vv"])
diff --git a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py
index 5c5cd8a5cbf74de1fb9c45e10b05d2d192f36355..b18bf540ffc21674ceeb8ed82f968f6e4c2c3031 100644
--- a/src/runtime/sim_loop.py
+++ b/src/runtime/sim_loop.py
@@ -1,113 +1,144 @@
 """
 Physics simulation loop with fixed timestep
 Runs in dedicated QThread with QTimer for precise timing
 """
 
 import time
 import logging
+from dataclasses import replace
 from typing import Optional, Dict, Any
 import numpy as np
 
 from PySide6.QtCore import QObject, QTimer, Signal, Slot, Qt
 from PySide6.QtCore import QThread
 
 from .state import (
     StateSnapshot,
     StateBus,
     FrameState,
     WheelState,
     LineState,
     TankState,
     SystemAggregates,
 )
 from .sync import (
     LatestOnlyQueue,
     PerformanceMetrics,
     TimingAccumulator,
     ThreadSafeCounter,
 )
 
 # Измененные импорты на абсолютные пути
 from src.physics.odes import RigidBody3DOF, create_initial_conditions
 from src.physics.integrator import (
     step_dynamics,
     create_default_rigid_body,
 )
 from src.pneumo.enums import (
     Wheel,
     Line,
     ThermoMode,
+    ReceiverVolumeMode,
+    Port,
 )
-from src.pneumo.receiver import ReceiverState
-from src.pneumo.system import create_standard_diagonal_system
+from src.pneumo.receiver import ReceiverState, ReceiverSpec
 from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
 from src.pneumo.network import GasNetwork
+from src.pneumo.system import create_standard_diagonal_system
+from src.common.units import PA_ATM, T_AMBIENT
+from src.app.config_defaults import create_default_system_configuration
 from src.road.engine import RoadInput
 from src.road.scenarios import get_preset_by_name
+from src.road.types import RoadConfig, SourceKind, CorrelationSpec
 
 # Settings manager (используем абсолютный импорт, т.к. общий модуль)
 from src.common.settings_manager import get_settings_manager
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
         self.max_frame_time: float = 0.05
 
         # Simulation state
         self.is_running = False
         self.is_configured = False
         self.simulation_time = 0.0
         self.step_counter = 0
 
         # Physics objects (will be initialized in configure)
         self.rigid_body: Optional[RigidBody3DOF] = None
         self.road_input: Optional[Any] = None  # Changed type hint
         self.pneumatic_system: Optional[Any] = None
         self.gas_network: Optional[Any] = None
 
+        # Cached geometry/kinematics parameters
+        self.lever_length: float = 0.5
+
+        # Cached state for snapshot generation
+        self._wheel_state_cache: Dict[Wheel, WheelState] = {}
+        self._line_state_cache: Dict[Line, LineState] = {}
+        self._tank_state_cache: TankState = TankState()
+        self._wheel_line_mapping: Dict[Wheel, Dict[Port, Line]] = {}
+
+        # Historical values for derivative estimates
+        self._prev_lever_angles: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+        self._prev_piston_positions: Dict[Wheel, float] = {
+            wheel: 0.0 for wheel in Wheel
+        }
+        self._prev_road_inputs: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+        self._prev_line_masses: Dict[Line, float] = {}
+        self._prev_tank_mass: float = 0.0
+
+        # Relief valve thresholds (Pa)
+        self._relief_thresholds: Dict[str, float] = {
+            "min": 0.0,
+            "stiff": 0.0,
+            "safety": 0.0,
+        }
+
         # Current physics state
         self.physics_state: np.ndarray = np.zeros(6)  # [Y, φz, θx, dY, dφz, dθx]
 
         # Simulation modes (overridden by persisted settings)
         self.thermo_mode = ThermoMode.ISOTHERMAL
         self.master_isolation_open = False
 
         # Receiver parameters and limits (loaded from settings)
         self.receiver_volume: float = 0.0
         self.receiver_volume_mode: str = ""
         self._volume_limits: tuple[float, float] = (0.0, 0.0)
 
         # Threading objects (created in target thread)
         self.physics_timer: Optional[QTimer] = None
 
         # Performance monitoring
         self.performance = PerformanceMetrics()
         self.timing_accumulator: Optional[TimingAccumulator] = None
         self.step_time_samples = []
 
         # Thread safety
         self.error_counter = ThreadSafeCounter()
 
         # Load persisted configuration
         self._load_initial_settings()
@@ -247,96 +278,237 @@ class PhysicsWorker(QObject):
         ):
             self.vsync_render_hz = float(vsync_render_hz)
         if isinstance(max_steps_per_frame, (int, float)) and not isinstance(
             max_steps_per_frame, bool
         ):
             self.max_steps_per_frame = max(1, int(round(max_steps_per_frame)))
         if isinstance(max_frame_time, (int, float)) and not isinstance(
             max_frame_time, bool
         ):
             self.max_frame_time = float(max_frame_time)
 
         # Update timing accumulator
         self._apply_timing_configuration()
 
         # Create default physics objects
         self._initialize_physics_objects()
 
         self.is_configured = True
         self.logger.info(
             f"Physics configured: dt={self.dt_physics*1000:.3f}ms, render={self.vsync_render_hz:.1f}Hz"
         )
 
     def _initialize_physics_objects(self):
         """Initialize physics simulation objects"""
         try:
-            # Create 3-DOF rigid body
+            geometry_cfg = self.settings_manager.get("geometry", None)
+            pneumatic_cfg = self.settings_manager.get("pneumatic", None)
+            road_cfg = self.settings_manager.get("modes", None)
+
+            if not geometry_cfg or not pneumatic_cfg or not road_cfg:
+                raise RuntimeError(
+                    "Missing geometry, pneumatic or modes configuration in settings"
+                )
+
+            if "lever_length" not in geometry_cfg:
+                raise RuntimeError("geometry.lever_length setting is required")
+            self.lever_length = float(geometry_cfg["lever_length"])
+
+            self._relief_thresholds = {
+                "min": float(pneumatic_cfg.get("relief_min_pressure", 0.0)),
+                "stiff": float(pneumatic_cfg.get("relief_stiff_pressure", 0.0)),
+                "safety": float(pneumatic_cfg.get("relief_safety_pressure", 0.0)),
+            }
+
             self.rigid_body = create_default_rigid_body()
+            if "wheelbase" in geometry_cfg:
+                self.rigid_body.wheelbase = float(geometry_cfg["wheelbase"])
+            if "track" in geometry_cfg:
+                self.rigid_body.track = float(geometry_cfg["track"])
 
-            # Initialize physics state (at rest)
             self.physics_state = create_initial_conditions()
 
-            # TODO: Initialize pneumatic system and gas network
-            # For now, create minimal stubs
-            self.pneumatic_system = None  # Will be set up later
-            self.gas_network = None
+            default_config = create_default_system_configuration()
+            frame_geom = default_config["frame_geom"]
+            lever_geom = default_config["lever_geom"]
+            cylinder_geom = default_config["cylinder_geom"]
+            cylinder_specs = default_config["cylinder_specs"]
+            line_configs = default_config["line_configs"]
 
-            # TODO: Initialize road input
-            # For now, create minimal stub
-            self.road_input = None
+            frame_geom.L_wb = float(geometry_cfg.get("wheelbase", frame_geom.L_wb))
+            lever_geom.L_lever = self.lever_length
 
-            # NEW: Initialize road input with default scenario
-            road_scenario = "default_scenario"  # Заменить на нужный пресет
-            road_config = get_preset_by_name(road_scenario)
-            if road_config:
-                self.road_input = RoadInput(config=road_config)
-                self.logger.info(
-                    f"Road input initialized with scenario: {road_scenario}"
-                )
+            frame_to_pivot = float(
+                geometry_cfg.get("frame_to_pivot", lever_geom.d_frame_to_lever_hinge)
+            )
+            lever_geom.d_frame_to_lever_hinge = max(frame_to_pivot, 0.1)
+
+            rod_position = float(geometry_cfg.get("rod_position", 0.5))
+            if self.lever_length > 0:
+                rod_fraction = rod_position / self.lever_length
             else:
-                self.logger.warning(f"Road scenario not found: {road_scenario}")
-                self.road_input = None  # Использовать заглушку
+                rod_fraction = rod_position
+            lever_geom.rod_joint_frac = float(np.clip(rod_fraction, 0.1, 0.9))
 
-            # NEW: Initialize pneumatic system with standard configuration
-            try:
-                self.pneumatic_system = create_standard_diagonal_system()
-                self.logger.info(
-                    "Pneumatic system initialized with standard configuration"
+            cylinder_geom.L_inner = float(
+                geometry_cfg.get("cylinder_length", cylinder_geom.L_inner)
+            )
+            cylinder_inner = float(
+                geometry_cfg.get("cyl_diam_m", cylinder_geom.D_in_front)
+            )
+            cylinder_geom.D_in_front = max(cylinder_inner, 1e-3)
+            cylinder_geom.D_in_rear = max(cylinder_inner, 1e-3)
+            cylinder_geom.D_out_front = max(
+                cylinder_geom.D_in_front + 0.01, cylinder_geom.D_out_front
+            )
+            cylinder_geom.D_out_rear = max(
+                cylinder_geom.D_in_rear + 0.01, cylinder_geom.D_out_rear
+            )
+            cylinder_geom.D_rod = float(
+                geometry_cfg.get("rod_diameter_m", cylinder_geom.D_rod)
+            )
+            dead_gap = float(geometry_cfg.get("dead_gap_m", cylinder_geom.L_dead_head))
+            cylinder_geom.L_dead_head = max(dead_gap, 1e-3)
+            cylinder_geom.L_dead_rod = max(
+                float(geometry_cfg.get("dead_zone_rod", dead_gap)), 1e-3
+            )
+            cylinder_geom.t_piston = float(
+                geometry_cfg.get("piston_thickness_m", cylinder_geom.t_piston)
+            )
+            cylinder_geom.Y_tail = float(
+                geometry_cfg.get("tail_mount_offset_m", cylinder_geom.Y_tail)
+            )
+            cylinder_geom.Z_axle = float(
+                geometry_cfg.get("frame_height_m", cylinder_geom.Z_axle)
+            )
+
+            receiver_spec = ReceiverSpec(
+                V_min=self._volume_limits[0], V_max=self._volume_limits[1]
+            )
+            air_temp_c = float(pneumatic_cfg.get("atmo_temp", 20.0))
+            air_temp_k = T_AMBIENT if np.isnan(air_temp_c) else air_temp_c + 273.15
+            initial_pressure = float(pneumatic_cfg.get("initial_pressure", PA_ATM))
+            mode_name = self.receiver_volume_mode
+            if mode_name == "MANUAL":
+                receiver_mode = ReceiverVolumeMode.NO_RECALC
+            elif mode_name == "GEOMETRIC":
+                receiver_mode = ReceiverVolumeMode.ADIABATIC_RECALC
+            else:
+                receiver_mode = ReceiverVolumeMode[mode_name]
+
+            receiver_state = ReceiverState(
+                spec=receiver_spec,
+                V=self.receiver_volume,
+                p=initial_pressure,
+                T=air_temp_k,
+                mode=receiver_mode,
+            )
+
+            self.pneumatic_system = create_standard_diagonal_system(
+                cylinder_specs=cylinder_specs,
+                line_configs=line_configs,
+                receiver=receiver_state,
+                master_isolation_open=self.master_isolation_open,
+            )
+
+            self._wheel_line_mapping = {}
+            for line_name, pneumo_line in self.pneumatic_system.lines.items():
+                for wheel, port in pneumo_line.endpoints:
+                    self._wheel_line_mapping.setdefault(wheel, {})[port] = line_name
+
+            line_volumes = self.pneumatic_system.get_line_volumes()
+            line_states: Dict[Line, Any] = {}
+            line_pressure = float(pneumatic_cfg.get("initial_line_pressure", PA_ATM))
+
+            for line_name, info in line_volumes.items():
+                volume = float(info.get("total_volume", 0.0))
+                if volume <= 0:
+                    volume = 1e-6
+                line_states[line_name] = create_line_gas_state(
+                    name=line_name,
+                    p_initial=line_pressure,
+                    T_initial=air_temp_k,
+                    V_initial=volume,
                 )
-            except Exception as e:
-                self.logger.warning(f"Failed to create standard pneumatic system: {e}")
-                self.pneumatic_system = None  # Использовать заглушку
 
-            # NEW: Initialize gas network with default parameters
-            try:
-                self.gas_network = GasNetwork()
-                self.logger.info("Gas network initialized with default parameters")
-            except Exception as e:
-                self.logger.warning(f"Failed to create gas network: {e}")
-                self.gas_network = None  # Использовать заглушку
+            tank_state = create_tank_gas_state(
+                V_initial=self.receiver_volume,
+                p_initial=initial_pressure,
+                T_initial=air_temp_k,
+                mode=receiver_mode,
+            )
+
+            self.gas_network = GasNetwork(
+                lines=line_states,
+                tank=tank_state,
+                system_ref=self.pneumatic_system,
+                master_isolation_open=self.master_isolation_open,
+            )
+
+            self._prev_line_masses = {line: state.m for line, state in line_states.items()}
+            self._prev_tank_mass = tank_state.m
+
+            for wheel, cylinder in self.pneumatic_system.cylinders.items():
+                self._prev_piston_positions[wheel] = cylinder.x
+
+            preset_name = str(road_cfg.get("mode_preset", "")).strip().lower()
+            road_config: Optional[RoadConfig] = None
+            if preset_name:
+                preset = get_preset_by_name(preset_name)
+                if preset is not None:
+                    road_config = RoadConfig(
+                        source=preset.source_kind,
+                        preset=preset,
+                        wheelbase=self.rigid_body.wheelbase,
+                        track=self.rigid_body.track,
+                    )
+
+            if road_config is None:
+                amplitude = float(road_cfg.get("amplitude", 0.02))
+                frequency = float(road_cfg.get("frequency", 1.0))
+                phase = float(road_cfg.get("phase", 0.0))
+                velocity = float(road_cfg.get("velocity", 12.0))
+                duration = float(road_cfg.get("duration", 20.0))
+                rho = float(np.clip(road_cfg.get("rho_LR", 0.85), 0.0, 1.0))
+                correlation = CorrelationSpec(rho_LR=rho, method="coherence")
+                road_config = RoadConfig(
+                    source=SourceKind.SINE,
+                    velocity=velocity,
+                    duration=duration,
+                    amplitude=amplitude,
+                    frequency=frequency,
+                    phase=phase,
+                    wheelbase=self.rigid_body.wheelbase,
+                    track=self.rigid_body.track,
+                    correlation=correlation,
+                )
 
-            self.logger.info("Physics objects initialized successfully")
+            self.road_input = RoadInput()
+            self.road_input.configure(road_config, system=self.pneumatic_system)
+            self.road_input.prime()
+
+            self.logger.info("Physics objects initialized successfully from settings")
 
         except Exception as e:
             self.logger.error(f"Failed to initialize physics objects: {e}")
             raise
 
     @Slot()
     def start_simulation(self):
         """Start physics simulation (called from UI thread)"""
         if not self.is_configured:
             self.error_occurred.emit("Physics worker not configured")
             return
 
         if self.is_running:
             self.logger.warning("Simulation already running")
             return
 
         # Create timer in this thread (will be moved to physics thread)
         if self.physics_timer is None:
             self.physics_timer = QTimer()
             self.physics_timer.timeout.connect(self._physics_step)
             self.physics_timer.setSingleShot(False)
 
         # Start timer with high precision
         timer_interval_ms = max(1, int(self.dt_physics * 1000))  # At least 1ms
         self.physics_timer.start(timer_interval_ms)
@@ -523,187 +695,358 @@ class PhysicsWorker(QObject):
             step_end_time = time.perf_counter()
             step_time = step_end_time - step_start_time
             self.performance.update_step_time(step_time)
 
             # Emit performance update periodically
             if self.step_counter % 100 == 0:  # Every 100 steps
                 self.performance_update.emit(self.performance.get_summary())
 
             # Create and emit state snapshot
             snapshot = self._create_state_snapshot()
             if snapshot and snapshot.validate():
                 self.state_ready.emit(snapshot)
             else:
                 self.error_counter.increment()
                 if self.error_counter.get() > 10:  # Too many invalid states
                     self.error_occurred.emit("Too many invalid state snapshots")
                     self.stop_simulation()
 
         except Exception as e:
             self.logger.error(f"Physics step failed: {e}")
             self.error_occurred.emit(f"Physics step error: {str(e)}")
             self.stop_simulation()
 
     def _execute_physics_step(self):
         """Execute single physics timestep"""
-        # 1. Get road inputs
+        if self.dt_physics <= 0:
+            raise RuntimeError("Physics dt must be positive")
+
+        if (
+            self.rigid_body is None
+            or self.pneumatic_system is None
+            or self.gas_network is None
+            or self.road_input is None
+        ):
+            raise RuntimeError("Physics dependencies are not fully initialized")
+
+        if not self._wheel_line_mapping:
+            raise RuntimeError("Wheel to line mapping is not configured")
+
         road_inputs = self._get_road_inputs()
+        road_per_wheel = {
+            wheel: float(road_inputs.get(wheel.value, 0.0)) for wheel in Wheel
+        }
 
-        # 2. Update geometry/kinematics
-        if self.rigid_body:
-            try:
-                # Update lever angles and piston positions from road inputs
-                if self.pneumatic_system:
-                    for wheel, input_value in road_inputs.items():
-                        if wheel in {Wheel.LP.value, Wheel.PP.value}:  # Левые колеса
-                            cylinder = self.pneumatic_system.left_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-                        elif wheel in {Wheel.LZ.value, Wheel.PZ.value}:  # Правые колеса
-                            cylinder = self.pneumatic_system.right_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
+        state = np.asarray(self.physics_state, dtype=float)
+        if state.size < 6:
+            raise RuntimeError("Physics state vector must have 6 components")
 
-            except Exception as e:
-                self.logger.warning(f"Failed to update kinematics: {e}")
+        Y, phi_z, theta_x, dY, dphi_z, dtheta_x = state[:6]
 
-        # 3. Update gas system
-        if self.gas_network:
-            try:
-                # Получаем текущее состояние газа в трубопроводах и резервуарах
-                line_gas_states = create_line_gas_state(self.gas_network)
-                tank_gas_states = create_tank_gas_state(self.gas_network)
-
-                # Обновляем состояния резервуаров в системе
-                for state in tank_gas_states:
-                    if state.receiver_id == "default_receiver":
-                        # Применяем новое состояние газа к резервуару
-                        receiver_state = ReceiverState(
-                            pressure=state.pressure,
-                            temperature=state.temperature,
-                            volume=self.receiver_volume,
-                        )
-                        self.gas_network.update_receiver_state(receiver_state)
+        lever_angles: Dict[Wheel, float] = {}
+        road_velocities: Dict[Wheel, float] = {}
 
-            except Exception as e:
-                self.logger.warning(f"Failed to update gas network: {e}")
+        for wheel in Wheel:
+            x_i, z_i = self.rigid_body.attachment_points.get(wheel.value, (0.0, 0.0))
+            road_disp = road_per_wheel[wheel]
+            prev_road = self._prev_road_inputs.get(wheel, road_disp)
+            road_velocity = (road_disp - prev_road) / self.dt_physics
+            road_velocities[wheel] = road_velocity
 
-        # 4. Integrate 3-DOF dynamics
-        if self.rigid_body:
-            try:
-                # Use placeholder system/gas for now
-                result = step_dynamics(
-                    y0=self.physics_state,
-                    t0=self.simulation_time,
-                    dt=self.dt_physics,
-                    params=self.rigid_body,
-                    system=self.pneumatic_system,
-                    gas=self.gas_network,
-                    method="Radau",
-                )
+            body_disp = Y + x_i * phi_z + z_i * theta_x
+            relative_disp = road_disp - body_disp
 
-                if result.success:
-                    self.physics_state = result.y_final
-                else:
-                    self.performance.integration_failures += 1
-                    self.logger.warning(f"Integration failed: {result.message}")
+            angle = float(
+                np.clip(relative_disp / max(self.lever_length, 1e-6), -0.75, 0.75)
+            )
+            lever_angles[wheel] = angle
 
-            except Exception as e:
-                self.performance.integration_failures += 1
-                self.logger.error(f"Integration error: {e}")
+        try:
+            self.pneumatic_system.update_system_from_lever_angles(lever_angles)
+        except Exception as exc:
+            raise RuntimeError(f"Failed to update lever kinematics: {exc}") from exc
+
+        line_prev_masses = {
+            line: state.m for line, state in self.gas_network.lines.items()
+        }
+        tank_prev_mass = self.gas_network.tank.m
+
+        self.gas_network.master_isolation_open = self.master_isolation_open
+        volumes = self.gas_network.compute_line_volumes()
+        for line, volume in volumes.items():
+            self.gas_network.lines[line].set_volume(max(volume, 1e-9))
+
+        self.gas_network.update_pressures_due_to_volume(self.thermo_mode)
+        self.gas_network.apply_valves_and_flows(self.dt_physics, log=self.logger)
+
+        for wheel in Wheel:
+            cylinder = self.pneumatic_system.cylinders[wheel]
+            piston_position = float(cylinder.x)
+            prev_position = self._prev_piston_positions.get(wheel, piston_position)
+            piston_velocity = (piston_position - prev_position) / self.dt_physics
+            self._prev_piston_positions[wheel] = piston_position
+
+            angle = lever_angles[wheel]
+            prev_angle = self._prev_lever_angles.get(wheel, angle)
+            self._prev_lever_angles[wheel] = angle
+
+            road_disp = road_per_wheel[wheel]
+            self._prev_road_inputs[wheel] = road_disp
+            road_velocity = road_velocities[wheel]
+
+            x_i, z_i = self.rigid_body.attachment_points.get(wheel.value, (0.0, 0.0))
+            body_disp = Y + x_i * phi_z + z_i * theta_x
+            body_velocity = dY + x_i * dphi_z + z_i * dtheta_x
+            relative_disp = road_disp - body_disp
+            relative_velocity = road_velocity - body_velocity
+
+            vol_head = float(cylinder.vol_head())
+            vol_rod = float(cylinder.vol_rod())
+
+            line_map = self._wheel_line_mapping.get(wheel)
+            if not line_map:
+                raise RuntimeError(f"Missing pneumatic line mapping for {wheel.value}")
+            line_head = line_map.get(Port.HEAD)
+            line_rod = line_map.get(Port.ROD)
+            if line_head is None or line_rod is None:
+                raise RuntimeError(f"Incomplete line mapping for wheel {wheel.value}")
+
+            head_state = self.gas_network.lines[line_head]
+            rod_state = self.gas_network.lines[line_rod]
+            geom = cylinder.spec.geometry
+            area_head = geom.area_head(cylinder.spec.is_front)
+            area_rod = geom.area_rod(cylinder.spec.is_front)
+
+            force_pneumatic = head_state.p * area_head - rod_state.p * area_rod
+
+            k_spring = 50_000.0
+            c_damper = 2_000.0
+            force_spring = -k_spring * relative_disp
+            force_damper = -c_damper * relative_velocity
+
+            wheel_state = WheelState(
+                wheel=wheel,
+                lever_angle=float(angle),
+                piston_position=piston_position,
+                piston_velocity=float(piston_velocity),
+                vol_head=vol_head,
+                vol_rod=vol_rod,
+                joint_x=float(x_i),
+                joint_y=float(road_disp),
+                joint_z=float(z_i),
+                force_pneumatic=float(force_pneumatic),
+                force_spring=float(force_spring),
+                force_damper=float(force_damper),
+                road_excitation=float(road_disp),
+            )
+
+            self._wheel_state_cache[wheel] = wheel_state
+
+        for line_name, line_state in self.gas_network.lines.items():
+            prev_mass = line_prev_masses.get(line_name, line_state.m)
+            mass_diff = line_state.m - prev_mass
+            flow_atmo = max(mass_diff, 0.0) / self.dt_physics
+            flow_tank = max(-mass_diff, 0.0) / self.dt_physics
+
+            pneumo_line = self.pneumatic_system.lines[line_name]
+            self._line_state_cache[line_name] = LineState(
+                line=line_name,
+                pressure=float(line_state.p),
+                temperature=float(line_state.T),
+                mass=float(line_state.m),
+                volume=float(line_state.V_curr),
+                cv_atmo_open=pneumo_line.cv_atmo.is_open(PA_ATM, line_state.p),
+                cv_tank_open=pneumo_line.cv_tank.is_open(
+                    line_state.p, self.gas_network.tank.p
+                ),
+                flow_atmo=float(flow_atmo),
+                flow_tank=float(flow_tank),
+            )
+            self._prev_line_masses[line_name] = line_state.m
+
+        tank_state = self.gas_network.tank
+        tank_mass_diff = tank_state.m - tank_prev_mass
+        relief_min = self._relief_thresholds.get("min", 0.0)
+        relief_stiff = self._relief_thresholds.get("stiff", 0.0)
+        relief_safety = self._relief_thresholds.get("safety", 0.0)
+
+        self._tank_state_cache = TankState(
+            pressure=float(tank_state.p),
+            temperature=float(tank_state.T),
+            mass=float(tank_state.m),
+            volume=float(tank_state.V),
+            relief_min_open=relief_min > 0.0 and tank_state.p >= relief_min,
+            relief_stiff_open=relief_stiff > 0.0 and tank_state.p >= relief_stiff,
+            relief_safety_open=relief_safety > 0.0 and tank_state.p >= relief_safety,
+            flow_min=
+            max(tank_mass_diff, 0.0) / self.dt_physics
+            if relief_min > 0.0 and tank_state.p >= relief_min
+            else 0.0,
+            flow_stiff=0.0,
+            flow_safety=
+            max(tank_mass_diff, 0.0) / self.dt_physics
+            if relief_safety > 0.0 and tank_state.p >= relief_safety
+            else 0.0,
+        )
+        self._tank_state_cache.volume = self.receiver_volume
+        self._prev_tank_mass = tank_state.m
+
+        try:
+            result = step_dynamics(
+                y0=self.physics_state,
+                t0=self.simulation_time,
+                dt=self.dt_physics,
+                params=self.rigid_body,
+                system=self.pneumatic_system,
+                gas=self.gas_network,
+                method="Radau",
+            )
+        except Exception as exc:
+            self.performance.integration_failures += 1
+            raise RuntimeError(f"Integration error: {exc}") from exc
+
+        if result.success:
+            self.physics_state = result.y_final
+        else:
+            self.performance.integration_failures += 1
+            raise RuntimeError(f"Integration failed: {result.message}")
 
-        # Update simulation time and step counter
         self.simulation_time += self.dt_physics
         self.step_counter += 1
 
     def _get_road_inputs(self) -> Dict[str, float]:
         """Get road excitation for all wheels"""
         if self.road_input:
             try:
-                return self.road_input.get_wheel_excitation(self.simulation_time)
+                excitation = self.road_input.get_wheel_excitation(
+                    self.simulation_time
+                )
+                mapping = {"LF": "LP", "RF": "PP", "LR": "LZ", "RR": "PZ"}
+                return {
+                    target: float(excitation.get(source, 0.0))
+                    for source, target in mapping.items()
+                }
             except Exception as e:
                 self.logger.warning(f"Road input error: {e}")
 
         # Return zero excitation as fallback
         return {"LP": 0.0, "PP": 0.0, "LZ": 0.0, "PZ": 0.0}
 
     def _create_state_snapshot(self) -> Optional[StateSnapshot]:
         """Create current state snapshot"""
         try:
             snapshot = StateSnapshot()
 
             # Basic timing info
             snapshot.simulation_time = self.simulation_time
             snapshot.dt_physics = self.dt_physics
             snapshot.step_number = self.step_counter
 
             # Frame state from physics integration
             if len(self.physics_state) >= 6:
                 Y, phi_z, theta_x, dY, dphi_z, dtheta_x = self.physics_state
 
                 snapshot.frame = FrameState(
                     heave=float(Y),
                     roll=float(phi_z),
                     pitch=float(theta_x),
                     heave_rate=float(dY),
                     roll_rate=float(dphi_z),
                     pitch_rate=float(dtheta_x),
                 )
 
             # Road excitations
             road_excitations = self._get_road_inputs()
 
             # Wheel states
-            for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
-                wheel_state = WheelState(wheel=wheel)
+            for wheel in Wheel:
+                if wheel in self._wheel_state_cache:
+                    wheel_state = replace(self._wheel_state_cache[wheel])
+                else:
+                    wheel_state = WheelState(wheel=wheel)
 
-                # Add road excitation
-                wheel_key = wheel.value  # LP, PP, LZ, PZ
+                wheel_key = wheel.value
                 if wheel_key in road_excitations:
-                    wheel_state.road_excitation = road_excitations[wheel_key]
-
-                # TODO: Add actual wheel state from pneumatic system
+                    wheel_state.road_excitation = float(road_excitations[wheel_key])
 
                 snapshot.wheels[wheel] = wheel_state
 
-            # Line states (placeholder)
-            for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
-                line_state = LineState(line=line)
-                # TODO: Get actual line state from gas network
+            for line in Line:
+                if line in self._line_state_cache:
+                    line_state = replace(self._line_state_cache[line])
+                else:
+                    line_state = LineState(line=line)
                 snapshot.lines[line] = line_state
 
-            # Tank state (placeholder)
-            snapshot.tank = TankState()
-
-            # NEW: Update tank volume from receiver settings
+            snapshot.tank = replace(self._tank_state_cache)
             snapshot.tank.volume = self.receiver_volume
 
-            # System aggregates
+            if self.rigid_body is not None:
+                heave_rate = snapshot.frame.heave_rate
+                roll_rate = snapshot.frame.roll_rate
+                pitch_rate = snapshot.frame.pitch_rate
+
+                kinetic_energy = 0.5 * self.rigid_body.M * (heave_rate ** 2)
+                kinetic_energy += 0.5 * self.rigid_body.Iz * (roll_rate ** 2)
+                kinetic_energy += 0.5 * self.rigid_body.Ix * (pitch_rate ** 2)
+                potential_energy = (
+                    self.rigid_body.M * self.rigid_body.g * snapshot.frame.heave
+                )
+            else:
+                kinetic_energy = 0.0
+                potential_energy = 0.0
+
+            pneumatic_energy = snapshot.tank.pressure * snapshot.tank.volume
+
+            total_flow_in = sum(
+                max(line_state.flow_atmo, 0.0) for line_state in snapshot.lines.values()
+            )
+            total_flow_out = sum(
+                max(line_state.flow_tank, 0.0) for line_state in snapshot.lines.values()
+            )
+
             snapshot.aggregates = SystemAggregates(
+                kinetic_energy=float(kinetic_energy),
+                potential_energy=float(potential_energy),
+                pneumatic_energy=float(pneumatic_energy),
+                total_flow_in=float(total_flow_in),
+                total_flow_out=float(total_flow_out),
+                net_flow=float(total_flow_in - total_flow_out),
+                valve_switches=sum(
+                    1
+                    for line_state in snapshot.lines.values()
+                    if line_state.cv_atmo_open or line_state.cv_tank_open
+                ),
+                relief_activations=sum(
+                    1
+                    for flag in [
+                        snapshot.tank.relief_min_open,
+                        snapshot.tank.relief_stiff_open,
+                        snapshot.tank.relief_safety_open,
+                    ]
+                    if flag
+                ),
                 physics_step_time=self.performance.avg_step_time,
                 integration_steps=self.step_counter,
                 integration_failures=self.performance.integration_failures,
             )
 
             # Configuration
             snapshot.master_isolation_open = self.master_isolation_open
             snapshot.thermo_mode = (
                 self.thermo_mode.name
                 if hasattr(self.thermo_mode, "name")
                 else str(self.thermo_mode)
             )
 
             return snapshot
 
         except Exception as e:
             self.logger.error(f"Failed to create state snapshot: {e}")
             return None
 
 
 class SimulationManager(QObject):
     """High-level simulation manager
 
     Manages PhysicsWorker in separate thread and provides
     unified interface for UI interaction.
diff --git a/tests/runtime/test_sim_loop.py b/tests/runtime/test_sim_loop.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb63f5a919e0e2c0504684fc06e09a2fb5e5b6a5
--- /dev/null
+++ b/tests/runtime/test_sim_loop.py
@@ -0,0 +1,41 @@
+import math
+import sys
+from pathlib import Path
+
+import pytest
+
+project_root = Path(__file__).resolve().parents[2]
+src_path = project_root / "src"
+if str(src_path) not in sys.path:
+    sys.path.insert(0, str(src_path))
+
+pytest.importorskip("PySide6")
+
+from runtime.sim_loop import PhysicsWorker  # noqa: E402
+from src.common.units import PA_ATM  # noqa: E402
+
+
+def test_physics_worker_generates_dynamic_state():
+    worker = PhysicsWorker()
+    worker.configure()
+
+    for _ in range(5):
+        worker._execute_physics_step()
+
+    snapshot = worker._create_state_snapshot()
+
+    angles = [abs(w.lever_angle) for w in snapshot.wheels.values()]
+    assert any(angle > 1e-6 for angle in angles)
+
+    pressures = [line.pressure for line in snapshot.lines.values()]
+    assert any(not math.isclose(p, PA_ATM, abs_tol=1.0) for p in pressures)
+
+
+def test_physics_worker_raises_when_dependencies_missing():
+    worker = PhysicsWorker()
+    worker.configure()
+
+    worker.gas_network = None
+
+    with pytest.raises(RuntimeError):
+        worker._execute_physics_step()
diff --git a/src/app_runner.py b/src/app_runner.py
index adf24c3ffec9af10c0e0298c7f5a72cf8b197d03..7bf73de468ba01e3de15ac981f2b356cc0c823e8 100644
--- a/src/app_runner.py
+++ b/src/app_runner.py
@@ -155,95 +155,177 @@ class ApplicationRunner:
                 self.app_logger.warning(
                     "MainWindow: refactored import failed, using default import"
                 )
 
         window = MW(use_qml_3d=self.use_qml_3d_schema)
         self.window_instance = window
 
         window.show()
         window.raise_()
         window.activateWindow()
 
         if self.app_logger:
             self.app_logger.info("MainWindow created and shown")
 
     def _validate_settings_file(self) -> None:
         """Строгая валидация конфигурации до создания MainWindow.
 
         Проверяем:
         - Путь к файлу и источник (ENV/CWD/PROJECT)
         - Наличие файла и корректность JSON
         - Обязательные ключи graphics.materials
         - Права на запись в каталог config (создание temp-файла)
         """
         from PySide6.QtWidgets import QMessageBox
         from src.common.settings_manager import get_settings_manager
+        from src.common.settings_requirements import (
+            BOOL_PNEUMATIC_KEYS,
+            NUMERIC_PNEUMATIC_KEYS,
+            NUMERIC_SIMULATION_KEYS,
+            RECEIVER_VOLUME_LIMIT_KEYS,
+            REQUIRED_CURRENT_SECTIONS,
+            STRING_PNEUMATIC_KEYS,
+        )
         import os
 
         sm = get_settings_manager()
         cfg_path = Path(sm.settings_file).absolute()
 
         def _fail(message: str, exc_type: type[Exception] = ValueError) -> None:
             if self.app_logger:
                 self.app_logger.critical(message)
             QMessageBox.critical(None, "Ошибка конфигурации", message)
             raise exc_type(message)
 
         # Определяем источник пути
         src = "CWD"
         if os.environ.get("PSS_SETTINGS_FILE"):
             src = "ENV"
         else:
             # Попробуем угадать project path
             try:
                 project_candidate = (
                     Path(__file__).resolve().parents[1].parent
                     / "config"
                     / "app_settings.json"
                 )
                 if cfg_path.samefile(project_candidate):
                     src = "PROJECT"
             except Exception:
                 pass
 
         msg_base = f"Settings file: {cfg_path} [source={src}]"
         print(msg_base)
         if self.app_logger:
             self.app_logger.info(msg_base)
 
         # 1) Существование
         if not cfg_path.exists():
             _fail(f"Файл настроек не найден: {cfg_path}")
 
         # 2) Чтение и JSON
         try:
             with open(cfg_path, "r", encoding="utf-8") as f:
                 data = json.load(f)
         except Exception as ex:
             _fail(f"Некорректный JSON в файле настроек: {cfg_path}\n{ex}")
 
-        # 3) Обязательные ключи материалов
+        if not isinstance(data, dict):
+            _fail("Файл настроек должен содержать JSON-объект на верхнем уровне")
+
+        current = data.get("current")
+        if not isinstance(current, dict):
+            _fail("Отсутствует секция current с текущими настройками")
+
+        def _get_path(payload: dict, path: str) -> Any:
+            node: Any = payload
+            for part in path.split("."):
+                if not isinstance(node, dict) or part not in node:
+                    raise KeyError(path)
+                node = node[part]
+            return node
+
+        def _require_dict(path: str) -> dict:
+            try:
+                value = _get_path(data, path)
+            except KeyError:
+                _fail(f"Отсутствует обязательная секция {path}")
+            if not isinstance(value, dict):
+                _fail(f"Секция {path} должна быть объектом")
+            return value
+
+        def _require_number(path: str) -> float:
+            try:
+                value = _get_path(data, path)
+            except KeyError:
+                _fail(f"Отсутствует обязательный числовой параметр {path}")
+            if isinstance(value, bool) or not isinstance(value, (int, float)):
+                _fail(f"Параметр {path} должен быть числом")
+            return float(value)
+
+        def _require_string(path: str) -> str:
+            try:
+                value = _get_path(data, path)
+            except KeyError:
+                _fail(f"Отсутствует обязательный текстовый параметр {path}")
+            if not isinstance(value, str) or not value.strip():
+                _fail(f"Параметр {path} должен быть непустой строкой")
+            return value
+
+        def _require_bool(path: str) -> bool:
+            try:
+                value = _get_path(data, path)
+            except KeyError:
+                _fail(f"Отсутствует обязательный логический параметр {path}")
+            if isinstance(value, bool):
+                return value
+            if isinstance(value, (int, float)) and not isinstance(value, bool):
+                return bool(value)
+            _fail(f"Параметр {path} должен быть логическим значением (true/false)")
+
+        # 3) Обязательные секции current.*
+        for section in REQUIRED_CURRENT_SECTIONS:
+            _require_dict(section)
+
+        # 4) Обязательные числовые параметры
+        for key in NUMERIC_SIMULATION_KEYS:
+            _require_number(f"current.simulation.{key}")
+
+        for key in NUMERIC_PNEUMATIC_KEYS:
+            _require_number(f"current.pneumatic.{key}")
+
+        for key in RECEIVER_VOLUME_LIMIT_KEYS:
+            _require_number(f"current.pneumatic.receiver_volume_limits.{key}")
+
+        # 5) Обязательные текстовые и логические параметры
+        for key in STRING_PNEUMATIC_KEYS:
+            _require_string(f"current.pneumatic.{key}")
+
+        for key in BOOL_PNEUMATIC_KEYS:
+            _require_bool(f"current.pneumatic.{key}")
+
+        # 6) Обязательные ключи материалов
         try:
             current = data.get("current", {}) if isinstance(data, dict) else {}
             graphics = current.get("graphics", {}) if isinstance(current, dict) else {}
             materials = (
                 graphics.get("materials", {}) if isinstance(graphics, dict) else {}
             )
             required_keys = {
                 "frame",
                 "lever",
                 "tail",
                 "cylinder",
                 "piston_body",
                 "piston_rod",
                 "joint_tail",
                 "joint_arm",
                 "joint_rod",
             }
             present = set(materials.keys()) if isinstance(materials, dict) else set()
             missing = sorted(list(required_keys - present))
             if missing:
                 _fail(
                     "Отсутствуют обязательные материалы в current.graphics.materials: "
                     + ", ".join(missing)
                 )
         except Exception:
diff --git a/src/common/settings_requirements.py b/src/common/settings_requirements.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f23c0bd0b4f4771d279e4be60242818ea3ff2f8
--- /dev/null
+++ b/src/common/settings_requirements.py
@@ -0,0 +1,59 @@
+"""Список обязательных секций и ключей для файла настроек."""
+from __future__ import annotations
+
+from typing import Iterable, Tuple
+
+
+NUMERIC_SIMULATION_KEYS: Tuple[str, ...] = (
+    "physics_dt",
+    "render_vsync_hz",
+    "max_steps_per_frame",
+    "max_frame_time",
+)
+
+NUMERIC_PNEUMATIC_KEYS: Tuple[str, ...] = (
+    "receiver_volume",
+)
+
+BOOL_PNEUMATIC_KEYS: Tuple[str, ...] = (
+    "master_isolation_open",
+)
+
+STRING_PNEUMATIC_KEYS: Tuple[str, ...] = (
+    "volume_mode",
+    "thermo_mode",
+)
+
+RECEIVER_VOLUME_LIMIT_KEYS: Tuple[str, ...] = (
+    "min_m3",
+    "max_m3",
+)
+
+REQUIRED_CURRENT_SECTIONS: Tuple[str, ...] = (
+    "current.simulation",
+    "current.pneumatic",
+    "current.geometry",
+    "current.pneumatic.receiver_volume_limits",
+)
+
+
+def iter_all_required_paths() -> Iterable[str]:
+    """Перечислить все обязательные пути в current.*"""
+
+    for section in REQUIRED_CURRENT_SECTIONS:
+        yield section
+
+    for key in NUMERIC_SIMULATION_KEYS:
+        yield f"current.simulation.{key}"
+
+    for key in NUMERIC_PNEUMATIC_KEYS:
+        yield f"current.pneumatic.{key}"
+
+    for key in BOOL_PNEUMATIC_KEYS:
+        yield f"current.pneumatic.{key}"
+
+    for key in STRING_PNEUMATIC_KEYS:
+        yield f"current.pneumatic.{key}"
+
+    for key in RECEIVER_VOLUME_LIMIT_KEYS:
+        yield f"current.pneumatic.receiver_volume_limits.{key}"
diff --git a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py
index 5c5cd8a5cbf74de1fb9c45e10b05d2d192f36355..f2113f711d557341ad844f66734af6f4bca03c47 100644
--- a/src/runtime/sim_loop.py
+++ b/src/runtime/sim_loop.py
@@ -25,50 +25,57 @@ from .sync import (
     PerformanceMetrics,
     TimingAccumulator,
     ThreadSafeCounter,
 )
 
 # Измененные импорты на абсолютные пути
 from src.physics.odes import RigidBody3DOF, create_initial_conditions
 from src.physics.integrator import (
     step_dynamics,
     create_default_rigid_body,
 )
 from src.pneumo.enums import (
     Wheel,
     Line,
     ThermoMode,
 )
 from src.pneumo.receiver import ReceiverState
 from src.pneumo.system import create_standard_diagonal_system
 from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
 from src.pneumo.network import GasNetwork
 from src.road.engine import RoadInput
 from src.road.scenarios import get_preset_by_name
 
 # Settings manager (используем абсолютный импорт, т.к. общий модуль)
 from src.common.settings_manager import get_settings_manager
+from src.common.settings_requirements import (
+    BOOL_PNEUMATIC_KEYS,
+    NUMERIC_PNEUMATIC_KEYS,
+    NUMERIC_SIMULATION_KEYS,
+    RECEIVER_VOLUME_LIMIT_KEYS,
+    STRING_PNEUMATIC_KEYS,
+)
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
@@ -151,92 +158,112 @@ class PhysicsWorker(QObject):
             raise RuntimeError(f"Missing numeric setting: {category}.{key}")
 
         def _require_bool(category: str, key: str) -> bool:
             value = _current(f"{category}.{key}")
             if isinstance(value, bool):
                 return value
             if isinstance(value, (int, float)) and not isinstance(value, bool):
                 return bool(value)
             fallback = _default(category, key)
             if isinstance(fallback, bool):
                 return fallback
             if isinstance(fallback, (int, float)) and not isinstance(fallback, bool):
                 return bool(fallback)
             raise RuntimeError(f"Missing boolean setting: {category}.{key}")
 
         def _require_str(category: str, key: str) -> str:
             value = _current(f"{category}.{key}")
             if isinstance(value, str) and value.strip():
                 return value.strip()
             fallback = _default(category, key)
             if isinstance(fallback, str) and fallback.strip():
                 return fallback.strip()
             raise RuntimeError(f"Missing text setting: {category}.{key}")
 
         try:
-            self.dt_physics = _require_number("simulation", "physics_dt")
-            self.vsync_render_hz = _require_number("simulation", "render_vsync_hz")
+            sim_values = {
+                key: _require_number("simulation", key) for key in NUMERIC_SIMULATION_KEYS
+            }
+            self.dt_physics = sim_values["physics_dt"]
+            self.vsync_render_hz = sim_values["render_vsync_hz"]
             self.max_steps_per_frame = max(
-                1, int(round(_require_number("simulation", "max_steps_per_frame")))
+                1, int(round(sim_values["max_steps_per_frame"]))
             )
-            self.max_frame_time = _require_number("simulation", "max_frame_time")
+            self.max_frame_time = sim_values["max_frame_time"]
 
             limits = self.settings_manager.get("pneumatic.receiver_volume_limits", None)
             if not isinstance(limits, dict) or not limits:
                 limits = _default("pneumatic", "receiver_volume_limits")
             if not isinstance(limits, dict):
                 raise RuntimeError("Missing pneumatic.receiver_volume_limits")
             min_limit = limits.get("min_m3")
             max_limit = limits.get("max_m3")
             if not isinstance(min_limit, (int, float)) or not isinstance(
                 max_limit, (int, float)
             ):
                 raise RuntimeError("Invalid receiver volume limits in settings")
             min_limit = float(min_limit)
             max_limit = float(max_limit)
             if max_limit <= min_limit or min_limit <= 0:
                 raise RuntimeError("Receiver volume limits must satisfy0 < min < max")
             self._volume_limits = (min_limit, max_limit)
 
-            self.receiver_volume = _require_number("pneumatic", "receiver_volume")
+            for key in RECEIVER_VOLUME_LIMIT_KEYS:
+                if key not in limits:
+                    raise RuntimeError(
+                        "Missing pneumatic.receiver_volume_limits." + key
+                    )
+
+            pneumatic_numbers = {
+                key: _require_number("pneumatic", key)
+                for key in NUMERIC_PNEUMATIC_KEYS
+            }
+            self.receiver_volume = pneumatic_numbers["receiver_volume"]
             if not (
                 self._volume_limits[0] <= self.receiver_volume <= self._volume_limits[1]
             ):
                 raise RuntimeError(
                     f"Receiver volume {self.receiver_volume} outside limits {self._volume_limits}"
                 )
 
-            mode = _require_str("pneumatic", "volume_mode").upper()
+            pneumatic_strings = {
+                key: _require_str("pneumatic", key)
+                for key in STRING_PNEUMATIC_KEYS
+            }
+
+            mode = pneumatic_strings["volume_mode"].upper()
             if mode not in {"MANUAL", "GEOMETRIC"}:
                 raise RuntimeError(f"Unsupported receiver volume mode: {mode}")
             self.receiver_volume_mode = mode
 
-            self.master_isolation_open = _require_bool(
-                "pneumatic", "master_isolation_open"
-            )
+            pneumatic_bools = {
+                key: _require_bool("pneumatic", key)
+                for key in BOOL_PNEUMATIC_KEYS
+            }
+            self.master_isolation_open = pneumatic_bools["master_isolation_open"]
 
-            thermo = _require_str("pneumatic", "thermo_mode").upper()
+            thermo = pneumatic_strings["thermo_mode"].upper()
             try:
                 self.thermo_mode = ThermoMode[thermo]
             except KeyError as exc:
                 raise RuntimeError(f"Unsupported thermo_mode: {thermo}") from exc
         except Exception as exc:
             self.logger.critical(f"Failed to load physics settings: {exc}")
             raise
 
     def _apply_timing_configuration(self) -> None:
         """Recreate timing accumulator with current configuration"""
         self.timing_accumulator = TimingAccumulator(
             self.dt_physics,
             self.max_steps_per_frame,
             self.max_frame_time,
         )
         self.performance.target_dt = self.dt_physics
 
     def configure(
         self,
         dt_phys: Optional[float] = None,
         vsync_render_hz: Optional[float] = None,
         max_steps_per_frame: Optional[int] = None,
         max_frame_time: Optional[float] = None,
     ):
         """Configure physics parameters"""
diff --git a/tests/test_settings_smoke.py b/tests/test_settings_smoke.py
index 499c7a7908b84c3d0e7cf2fdbb38e6ed606a8832..4c3b13d1c800526450f17c7d4c37a645af6dbaf5 100644
--- a/tests/test_settings_smoke.py
+++ b/tests/test_settings_smoke.py
@@ -1,22 +1,44 @@
 import json
 from pathlib import Path
 
-from src.common.settings_manager import SettingsManager
+from src.common.settings_manager import SettingsManager, get_settings_manager
+from src.common import settings_manager as settings_manager_module
 
 
 def test_settings_manager_si_units_migration(tmp_path):
     source = Path("config/app_settings.json")
     data = json.loads(source.read_text(encoding="utf-8"))
     data.setdefault("metadata", {})["units_version"] = "legacy"
 
     target_dir = tmp_path / "config"
     target_dir.mkdir()
     target_file = target_dir / "app_settings.json"
     target_file.write_text(
         json.dumps(data, ensure_ascii=False, indent=2),
         encoding="utf-8",
     )
 
     manager = SettingsManager(settings_file=target_file)
 
     assert manager._metadata.get("units_version") == "si_v2"
+
+
+def test_get_settings_manager_si_units(tmp_path, monkeypatch):
+    source = Path("config/app_settings.json")
+    data = json.loads(source.read_text(encoding="utf-8"))
+    data.setdefault("metadata", {})["units_version"] = "legacy"
+
+    target_dir = tmp_path / "config"
+    target_dir.mkdir()
+    target_file = target_dir / "app_settings.json"
+    target_file.write_text(
+        json.dumps(data, ensure_ascii=False, indent=2),
+        encoding="utf-8",
+    )
+
+    monkeypatch.setenv("PSS_SETTINGS_FILE", str(target_file))
+    monkeypatch.setattr(settings_manager_module, "_settings_manager", None)
+
+    manager = get_settings_manager()
+
+    assert manager._metadata.get("units_version") == "si_v2"
diff --git a/tests/unit/test_settings_validation.py b/tests/unit/test_settings_validation.py
index b466fb60e452733adf92bed0ccda60e67f946515..bd7759139bd5368f77a10b7dc5fbe3be9cc64d8c 100644
--- a/tests/unit/test_settings_validation.py
+++ b/tests/unit/test_settings_validation.py
@@ -89,55 +89,83 @@ def write_config(tmp_path: Path, monkeypatch):
         )
         monkeypatch.setenv("PSS_SETTINGS_FILE", str(path))
         monkeypatch.setattr(settings_manager_module, "_settings_manager", None)
         return path
 
     return _write
 
 
 # Helper to get last QMessageBox error
 def _last_error(stub_qmessagebox) -> str:
     assert stub_qmessagebox.calls, "QMessageBox.critical was not called"
     return stub_qmessagebox.calls[-1][2]
 
 
 # Test cases
 def test_validate_settings_missing_simulation_section(
     runner: ApplicationRunner, write_config, stub_qmessagebox
 ):
     settings = _base_settings()
     settings["current"].pop("simulation")
     write_config(settings)
 
     with pytest.raises(ValueError) as exc:
         runner._validate_settings_file()
 
-    assert "current.simulation" in str(exc.value)
+    assert "обязательная секция current.simulation" in str(exc.value)
     assert "current.simulation" in _last_error(stub_qmessagebox)
 
 
 def test_validate_settings_missing_physics_dt(
     runner: ApplicationRunner, write_config, stub_qmessagebox
 ):
     settings = _base_settings()
     settings["current"]["simulation"].pop("physics_dt")
     write_config(settings)
 
     with pytest.raises(ValueError) as exc:
         runner._validate_settings_file()
 
-    assert "current.simulation.physics_dt" in str(exc.value)
+    assert "physics_dt" in str(exc.value)
     assert "physics_dt" in _last_error(stub_qmessagebox)
 
 
 def test_validate_settings_missing_receiver_limit(
     runner: ApplicationRunner, write_config, stub_qmessagebox
 ):
     settings = _base_settings()
     settings["current"]["pneumatic"]["receiver_volume_limits"].pop("min_m3")
     write_config(settings)
 
     with pytest.raises(ValueError) as exc:
         runner._validate_settings_file()
 
     assert "receiver_volume_limits" in str(exc.value)
     assert "receiver_volume_limits" in _last_error(stub_qmessagebox)
+
+
+def test_validate_settings_missing_geometry_section(
+    runner: ApplicationRunner, write_config, stub_qmessagebox
+):
+    settings = _base_settings()
+    settings["current"].pop("geometry")
+    write_config(settings)
+
+    with pytest.raises(ValueError) as exc:
+        runner._validate_settings_file()
+
+    assert "current.geometry" in str(exc.value)
+    assert "geometry" in _last_error(stub_qmessagebox)
+
+
+def test_validate_settings_missing_volume_mode(
+    runner: ApplicationRunner, write_config, stub_qmessagebox
+):
+    settings = _base_settings()
+    settings["current"]["pneumatic"].pop("volume_mode")
+    write_config(settings)
+
+    with pytest.raises(ValueError) as exc:
+        runner._validate_settings_file()
+
+    assert "volume_mode" in str(exc.value)
+    assert "volume_mode" in _last_error(stub_qmessagebox)
diff --git a/.gitignore b/.gitignore
index 9207d6b247f19857d41c64b199ee4c1956036d89..cf6df74a333a7eabb7262b266fbc733d7e53a66e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -836,27 +836,28 @@ archive/old/
 # ================================================================================================
 !.vs/launch.vs.json
 !.vscode/
 !.vscode/launch.json
 !.vscode/tasks.json
 !.vscode/settings.json
 !.vscode/extensions.json
 !.vscode/profile.ps1
 !.vscode/copilot.json
 
 # HDR assets policy: keep placeholder and README, ignore binaries in repo root
 assets/hdr/*.hdr
 assets/hdr/*.exr
 !assets/hdr/README.md
 !assets/hdr/.gitignore
 !assets/hdr/studio.hdr.placeholder
 
 # Yandex Disk temporary download files
 *.yandex_disk_download
 
 # Allow targeted unit tests for schema validation
 !tests/unit/test_environment_schema.py
 !tests/unit/test_geometry_schema.py
 !tests/unit/test_settings_validation.py
 !tests/test_settings_smoke.py
+!tests/system/test_physics_integration.py
 
 # END OF .GITIGNORE
diff --git a/src/physics/integrator.py b/src/physics/integrator.py
index 9d5a40b4ce4757226b4a14834fcff1350df196b7..0062f2d2038152886db4904b7290e52a9ce3ab10 100644
--- a/src/physics/integrator.py
+++ b/src/physics/integrator.py
@@ -163,72 +163,76 @@ def step_dynamics(
     solve_time = time.perf_counter() - start_time
     return IntegrationResult(
         success=False,
         y_final=y0,  # Return original state
         t_final=t0,
         message=f"All integration methods failed. Last error: {last_error}",
         method_used="FAILED",
         n_evaluations=0,
         solve_time=solve_time,
     )
 
 
 def clamp_state(y: np.ndarray, params: RigidBody3DOF) -> np.ndarray:
     """Clamp state vector to valid ranges
 
     Args:
         y: State vector [Y, ?z, ?x, dY, d?z, d?x]
         params: System parameters with limits
 
     Returns:
         Clamped state vector
     """
     y_clamped = y.copy()
 
     # Clamp angles to limits
-    y_clamped[1] = np.clip(y[1], -params.angle_limit, params.angle_limit)  # ?z
-    y_clamped[2] = np.clip(y[2], -params.angle_limit, params.angle_limit)  # ?x
+    y_clamped[1] = np.clip(y[1], -params.angle_limit, params.angle_limit)
+    y_clamped[2] = np.clip(y[2], -params.angle_limit, params.angle_limit)
 
     # Clamp velocities to reasonable ranges
     max_velocity = 10.0  # 10 m/s heave
     max_angular_velocity = 10.0  # 10 rad/s
 
-    y_clamped[3] = np.clip(y[3], -max_velocity, max_velocity)  # dY
-    y_clamped[4] = np.clip(y[4], -max_angular_velocity, max_angular_velocity)  # d?z
-    y_clamped[5] = np.clip(y[5], -max_angular_velocity, max_angular_velocity)  # d?x
+    y_clamped[3] = np.clip(y[3], -max_velocity, max_velocity)
+    y_clamped[4] = np.clip(y[4], -max_angular_velocity, max_angular_velocity)
+    y_clamped[5] = np.clip(y[5], -max_angular_velocity, max_angular_velocity)
 
     # Remove NaN/inf
     y_clamped = np.nan_to_num(y_clamped, nan=0.0, posinf=0.0, neginf=0.0)
 
     return y_clamped
 
 
 class PhysicsLoop:
-    """Physics simulation loop with fixed timestep and render synchronization"""
+    """Physics simulation loop with fixed timestep and render sync."""
 
     def __init__(
-        self, config: PhysicsLoopConfig, params: RigidBody3DOF, system: Any, gas: Any
+        self,
+        config: PhysicsLoopConfig,
+        params: RigidBody3DOF,
+        system: Any,
+        gas: Any,
     ):
         self.config = config
         self.params = params
         self.system = system
         self.gas = gas
 
         # State
         self.time_physics = 0.0
         self.time_render = 0.0
         self.time_accumulator = 0.0
         self.step_count = 0
 
         # Statistics
         self.successful_steps = 0
         self.failed_steps = 0
         self.total_solve_time = 0.0
 
         # Logging
         self.logger = logging.getLogger(__name__)
 
     def reset(self, y0: np.ndarray, t0: float = 0.0):
         """Reset physics loop to initial conditions"""
         self.y_current = y0.copy()
         self.time_physics = t0
         self.time_render = t0
@@ -259,136 +263,89 @@ class PhysicsLoop:
             # Update gas system before physics step
             # TODO: Integrate with actual gas network
 
             # Take physics step
             result = step_dynamics(
                 y0=self.y_current,
                 t0=self.time_physics,
                 dt=self.config.dt_physics,
                 params=self.params,
                 system=self.system,
                 gas=self.gas,
                 method="Radau",
                 rtol=self.config.rtol,
                 atol=self.config.atol,
                 max_step=self.config.max_step,
             )
 
             results.append(result)
 
             if result.success:
                 self.y_current = result.y_final
                 self.time_physics = result.t_final
                 self.successful_steps += 1
             else:
                 self.failed_steps += 1
-                self.logger.warning(f"Physics step failed: {result.message}")
-                # Keep current state, advance time anyway to prevent infinite loop
+                self.logger.warning(
+                    "Physics step failed: %s", result.message
+                )
+                # Keep state but advance time to avoid stalls
                 self.time_physics += self.config.dt_physics
 
             self.total_solve_time += result.solve_time
             self.time_accumulator -= self.config.dt_physics
             steps_taken += 1
             self.step_count += 1
 
         # Check if render update is due
-        render_due = (self.time_physics - self.time_render) >= self.config.dt_render
+        render_due = (
+            self.time_physics - self.time_render
+        ) >= self.config.dt_render
         if render_due:
             self.time_render = self.time_physics
 
         return {
             "steps_taken": steps_taken,
             "physics_time": self.time_physics,
             "render_due": render_due,
             "y_current": self.y_current.copy(),
             "results": results,
             "stats": self.get_statistics(),
         }
 
     def get_statistics(self) -> Dict[str, Any]:
         """Get performance statistics"""
         total_steps = self.successful_steps + self.failed_steps
+        denominator = max(total_steps, 1)
 
         return {
             "total_steps": total_steps,
             "successful_steps": self.successful_steps,
             "failed_steps": self.failed_steps,
-            "success_rate": self.successful_steps / max(total_steps, 1),
-            "average_solve_time": self.total_solve_time / max(total_steps, 1),
+            "success_rate": self.successful_steps / denominator,
+            "average_solve_time": self.total_solve_time / denominator,
             "physics_frequency": 1.0 / self.config.dt_physics,
             "render_frequency": 1.0 / self.config.dt_render,
         }
 
 
 def create_default_rigid_body() -> RigidBody3DOF:
     """Create default rigid body parameters for testing
 
     Returns:
         RigidBody3DOF with typical vehicle parameters
     """
     # Typical medium vehicle parameters
     M = 1500.0  # 1500 kg total mass
     Ix = 2000.0  # Pitch inertia (kg?m?)
     Iz = 3000.0  # Roll inertia (kg?m?)
 
     return RigidBody3DOF(
         M=M,
         Ix=Ix,
         Iz=Iz,
         g=9.81,
         track=1.6,
         wheelbase=3.2,
         angle_limit=0.5,
         damping_coefficient=0.1,
     )
-
-
-def run_integration_test(duration: float = 5.0, dt: float = 0.001) -> Dict[str, Any]:
-    """Run integration test with default parameters
-
-    Args:
-        duration: Test duration (s)
-        dt: Time step (s)
-
-    Returns:
-        Test results and statistics
-    """
-    # Create test setup
-    params = create_default_rigid_body()
-
-    # TODO: Create minimal system and gas stubs for testing
-    system = None  # Placeholder
-    gas = None  # Placeholder
-
-    # Initial conditions (at rest)
-    y0 = np.zeros(6)
-
-    # Run simulation
-    t = 0.0
-    y = y0.copy()
-    results = []
-
-    steps = int(duration / dt)
-
-    for i in range(steps):
-        result = step_dynamics(y, t, dt, params, system, gas)
-        results.append(result)
-
-        if result.success:
-            y = result.y_final
-            t = result.t_final
-        else:
-            print(f"Step {i} failed: {result.message}")
-            break
-
-    # Analyze results
-    successful = sum(1 for r in results if r.success)
-    failed = len(results) - successful
-
-    return {
-        "total_steps": len(results),
-        "successful_steps": successful,
-        "failed_steps": failed,
-        "final_state": y,
-        "final_time": t,
-        "success_rate": successful / len(results) if results else 0,
-    }
diff --git a/tests/system/test_physics_integration.py b/tests/system/test_physics_integration.py
new file mode 100644
index 0000000000000000000000000000000000000000..45c93eeaf12615e25ca8da78cb058b13f67e4f9b
--- /dev/null
+++ b/tests/system/test_physics_integration.py
@@ -0,0 +1,163 @@
+"""System-level checks for the 3-DOF physics integrator."""
+
+from __future__ import annotations
+
+import math
+from typing import Iterable
+
+import numpy as np
+import pytest
+
+from physics.integrator import (
+    create_default_rigid_body,
+    step_dynamics,
+)
+from physics.odes import (
+    RigidBody3DOF,
+    create_initial_conditions,
+    f_rhs,
+)
+
+pytestmark = pytest.mark.system
+
+_SPRING_STIFFNESS = 50_000.0
+
+
+def _suspension_displacements(
+    params: RigidBody3DOF, state: np.ndarray
+) -> Iterable[float]:
+    """Return vertical displacements of all suspension points."""
+    y, roll, pitch, *_ = state
+    for x_pos, z_pos in params.attachment_points.values():
+        yield y + x_pos * roll + z_pos * pitch
+
+
+def _total_mechanical_energy(
+    params: RigidBody3DOF, state: np.ndarray
+) -> float:
+    """Approximate total mechanical energy of the rigid body state."""
+    y, roll, pitch, dy, droll, dpitch = state
+
+    kinetic = 0.5 * params.M * dy**2
+    kinetic += 0.5 * params.Iz * droll**2
+    kinetic += 0.5 * params.Ix * dpitch**2
+
+    gravitational = params.M * params.g * y
+
+    suspension = sum(
+        0.5 * _SPRING_STIFFNESS * disp**2
+        for disp in _suspension_displacements(params, state)
+    )
+
+    return kinetic + gravitational + suspension
+
+
+@pytest.fixture(scope="module")
+def default_params() -> RigidBody3DOF:
+    return create_default_rigid_body()
+
+
+@pytest.fixture(scope="module")
+def nominal_state() -> np.ndarray:
+    return create_initial_conditions(heave=0.01, roll=0.005, pitch=0.002)
+
+
+def test_step_dynamics_stable_response(
+    default_params: RigidBody3DOF,
+    nominal_state: np.ndarray,
+    capsys: pytest.CaptureFixture[str],
+) -> None:
+    """Integrator should remain stable for small perturbations."""
+    dt = 0.001
+    t = 0.0
+    y = nominal_state.copy()
+
+    max_energy = 0.0
+    max_angle = 0.0
+
+    for _ in range(500):
+        result = step_dynamics(
+            y,
+            t,
+            dt,
+            default_params,
+            system=None,
+            gas=None,
+            method="Radau",
+        )
+        assert result.success, result.message
+        assert np.all(np.isfinite(result.y_final)), (
+            "State vector must remain finite"
+        )
+        assert result.n_evaluations > 0
+        assert result.t_final > t
+
+        y = result.y_final
+        t = result.t_final
+
+        max_energy = max(
+            max_energy,
+            _total_mechanical_energy(default_params, y),
+        )
+        max_angle = max(
+            max_angle,
+            float(np.max(np.abs(y[1:3]))),
+        )
+
+    captured = capsys.readouterr()
+    assert captured.out == ""
+    assert captured.err == ""
+
+    assert math.isclose(t, 0.5, rel_tol=0.0, abs_tol=1e-12)
+    assert max_energy < 5_000.0, (
+        "Energy growth indicates unstable integration"
+    )
+    assert max_angle < math.radians(5.0), (
+        "Angular deviation should stay within 5 degrees"
+    )
+
+    accelerations = f_rhs(t, y, default_params, None, None)[3:]
+    assert np.linalg.norm(accelerations) < 5.0, (
+        "Accelerations should remain bounded"
+    )
+
+
+def test_step_dynamics_invalid_method(
+    default_params: RigidBody3DOF, nominal_state: np.ndarray
+) -> None:
+    """Unknown integration methods must report a failure without crashing."""
+    result = step_dynamics(
+        nominal_state,
+        t0=0.0,
+        dt=0.01,
+        params=default_params,
+        system=None,
+        gas=None,
+        method="NotAMethod",
+    )
+
+    assert not result.success
+    assert "failed" in result.message.lower()
+    assert result.method_used == "FAILED"
+
+
+def test_step_dynamics_invalid_inertia_matrix(
+    nominal_state: np.ndarray,
+) -> None:
+    """Degenerate inertia matrices should surface integration errors."""
+    bad_params = RigidBody3DOF(M=1500.0, Ix=0.0, Iz=3000.0)
+
+    with pytest.warns(RuntimeWarning):
+        result = step_dynamics(
+            nominal_state,
+            t0=0.0,
+            dt=0.01,
+            params=bad_params,
+            system=None,
+            gas=None,
+            method="Radau",
+        )
+
+    assert not result.success
+    assert "failed" in result.message.lower()
+    assert result.method_used == "FAILED"
diff --git a/tests/test_physics_integration.py b/tests/test_physics_integration.py
deleted file mode 100644
index 172d343116235ea5dbba42bbb1a625509448a632..0000000000000000000000000000000000000000
--- a/tests/test_physics_integration.py
+++ /dev/null
@@ -1,237 +0,0 @@
-"""
-Test 3-DOF dynamics integration with gas system
-"""
-
-import numpy as np
-import sys
-import os
-
-# Add src to path
-sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "src"))
-
-
-def test_physics_gas_integration():
-    """Test integration between physics and gas systems"""
-    print("=== Testing Physics-Gas Integration ===")
-
-    try:
-        # Test physics module imports
-        from physics.integrator import step_dynamics, create_default_rigid_body
-        from physics.forces import compute_cylinder_force, compute_spring_force
-
-        print("? Physics modules imported successfully")
-
-        # Create test rigid body
-        rigid_body = create_default_rigid_body()
-        print(f"? Rigid body created: M={rigid_body.M}kg, Ix={rigid_body.Ix}kg?m?")
-
-        # Test force calculations
-        F_cyl = compute_cylinder_force(
-            110000, 100000, 0.005, 0.004
-        )  # 1bar pressure diff
-        print(f"? Cylinder force calculation: {F_cyl:.1f}N")
-
-        F_spring = compute_spring_force(0.05, 0.1, 50000)  # 5cm compression
-        print(f"? Spring force calculation: {F_spring:.1f}N")
-
-        # Test state vector operations
-        y0 = create_initial_conditions(heave=0.01, roll=0.02, pitch=0.01)
-        print(f"? Initial conditions: heave={y0[0]:.3f}m, roll={y0[1]:.3f}rad")
-
-        # Test basic integration step (without full gas coupling)
-        result = step_dynamics(
-            y0=y0,
-            t0=0.0,
-            dt=0.01,
-            params=rigid_body,
-            system=None,  # Placeholder
-            gas=None,  # Placeholder
-            method="Radau",
-        )
-
-        if result.success:
-            print(f"? Integration step successful: method={result.method_used}")
-            print(f"  Final state: heave={result.y_final[0]:.6f}m")
-        else:
-            print(f"? Integration failed: {result.message}")
-            return False
-
-        print("? All integration tests passed")
-        return True
-
-    except ImportError as e:
-        print(f"? Import error: {e}")
-        return False
-    except Exception as e:
-        print(f"? Test error: {e}")
-        import traceback
-
-        traceback.print_exc()
-        return False
-
-
-def test_coordinate_system():
-    """Test coordinate system consistency"""
-    print("\n=== Testing Coordinate System ===")
-
-    try:
-        from physics.odes import axis_vertical_projection, RigidBody3DOF
-
-        # Test coordinate system: Y down positive
-        eY_down = np.array([0.0, 1.0, 0.0])
-        eX_right = np.array([1.0, 0.0, 0.0])
-
-        # Test vertical projection
-        F_vertical = axis_vertical_projection(1000.0, eY_down)
-        assert abs(F_vertical - 1000.0) < 1e-6, "Vertical force projection failed"
-
-        F_horizontal = axis_vertical_projection(1000.0, eX_right)
-        assert (
-            abs(F_horizontal) < 1e-6
-        ), "Horizontal force should have zero vertical component"
-
-        print("? Coordinate system Y-down confirmed")
-
-        # Test attachment points layout
-        rigid_body = RigidBody3DOF(M=1500, Ix=2000, Iz=3000)
-        points = rigid_body.attachment_points
-
-        # Verify standard layout
-        assert points["LP"][0] < 0, "Left front should have negative X"
-        assert points["PP"][0] > 0, "Right front should have positive X"
-        assert points["LP"][1] < 0, "Front wheels should have negative Z"
-        assert points["LZ"][1] > 0, "Rear wheels should have positive Z"
-
-        print("? Attachment points layout verified")
-
-        # Test moment arm calculations
-        # Roll moment: force ? lateral distance (X)
-        # Pitch moment: force ? longitudinal distance (Z)
-
-        F_left = 1000.0  # Force at left wheel
-        x_left = points["LP"][0]  # Negative X
-        z_front = points["LP"][1]  # Negative Z
-
-        tau_roll = F_left * x_left  # Should be negative (left wheel down)
-        tau_pitch = F_left * z_front  # Should be negative (nose down)
-
-        print(f"? Moment calculation: roll={tau_roll:.1f}N?m, pitch={tau_pitch:.1f}N?m")
-
-        return True
-
-    except Exception as e:
-        print(f"? Coordinate system test failed: {e}")
-        return False
-
-
-def run_small_scenario():
-    """Run a small 5-second scenario as specified in prompt"""
-    print("\n=== Running 5-Second Scenario ===")
-
-    try:
-        from physics.integrator import step_dynamics, create_default_rigid_body
-        from physics.odes import create_initial_conditions, validate_state
-
-        # Parameters
-        duration = 5.0  # 5 seconds
-        dt_phys = 0.001  # 1ms timestep
-
-        # Create system
-        params = create_default_rigid_body()
-
-        # Initial conditions (small perturbation)
-        y0 = create_initial_conditions(heave=0.01, roll=0.005, pitch=0.002)
-
-        print(f"Running {duration}s simulation with dt={dt_phys}s...")
-        print(
-            f"Initial: heave={y0[0]:.3f}m, roll={y0[1]*180/np.pi:.2f}�, pitch={y0[2]*180/np.pi:.2f}�"
-        )
-
-        # Run simulation
-        t = 0.0
-        y = y0.copy()
-        step_count = 0
-        max_angles = [0.0, 0.0]  # max |roll|, max |pitch|
-        max_heave = 0.0
-
-        steps = int(duration / dt_phys)
-
-        for i in range(steps):
-            result = step_dynamics(y, t, dt_phys, params, None, None, method="Radau")
-
-            if not result.success:
-                print(f"? Integration failed at step {i}: {result.message}")
-                break
-
-            y = result.y_final
-            t = result.t_final
-            step_count += 1
-
-            # Track maxima
-            max_angles[0] = max(max_angles[0], abs(y[1]))  # roll
-            max_angles[1] = max(max_angles[1], abs(y[2]))  # pitch
-            max_heave = max(max_heave, abs(y[0]))
-
-            # Check for NaN/inf
-            if not np.all(np.isfinite(y)):
-                print(f"? Non-finite values detected at step {i}")
-                break
-
-        print(f"? Completed {step_count} steps successfully")
-        print(
-            f"Final: heave={y[0]:.3f}m, roll={y[1]*180/np.pi:.2f}�, pitch={y[2]*180/np.pi:.2f}�"
-        )
-        print(
-            f"Maxima: |roll|={max_angles[0]*180/np.pi:.2f}�, |pitch|={max_angles[1]*180/np.pi:.2f}�, |heave|={max_heave:.3f}m"
-        )
-
-        # Validate final state
-        is_valid, msg = validate_state(y, params)
-        if is_valid:
-            print("? Final state is valid")
-        else:
-            print(f"? Final state invalid: {msg}")
-            return False
-
-        return True
-
-    except Exception as e:
-        print(f"? Scenario test failed: {e}")
-        import traceback
-
-        traceback.print_exc()
-        return False
-
-
-def main():
-    """Run comprehensive physics integration tests"""
-    print("=" * 60)
-    print("3-DOF PHYSICS INTEGRATION TESTS")
-    print("=" * 60)
-
-    tests = [test_physics_gas_integration, test_coordinate_system, run_small_scenario]
-
-    passed = 0
-
-    for test_func in tests:
-        if test_func():
-            passed += 1
-        else:
-            print("Test failed!")
-
-    print(f"\n{'='*60}")
-    print(f"RESULTS: {passed}/{len(tests)} tests passed")
-
-    if passed == len(tests):
-        print("? ALL PHYSICS TESTS PASSED - SYSTEM READY!")
-    else:
-        print("? Some tests failed")
-
-    print("=" * 60)
-
-    return passed == len(tests)
-
-
-if __name__ == "__main__":
-    success = main()
-    exit(0 if success else 1)
diff --git a/assets/qml/geometry/Frame.qml b/assets/qml/geometry/Frame.qml
index ae9b4d257c0089794524740e15444c600be2bf5b..fb0c73af09af577b3aae3ab3ee971a50ff4a3b10 100644
--- a/assets/qml/geometry/Frame.qml
+++ b/assets/qml/geometry/Frame.qml
@@ -1,66 +1,66 @@
 import QtQuick
 import QtQuick3D
 
 /*
  * Frame Component - U-shaped frame (3 beams)
  * Extracted from main.qml for modular QML architecture
  *
  * Constructs a U-frame with:
  * - Bottom horizontal beam (along Z axis)
  * - Front vertical beam (at front end)
  * - Rear vertical beam (at rear end)
  */
 Node {
     id: frame
 
     // ===============================================================
     // REQUIRED PROPERTIES
     // ===============================================================
 
     required property Node worldRoot
-    required property real beamSize       // mm - cross-section size
-    required property real frameHeight    // mm - height of vertical beams
-    required property real frameLength    // mm - length along Z axis
+    required property real beamSize       // m - cross-section size
+    required property real frameHeight    // m - height of vertical beams
+    required property real frameLength    // m - length along Z axis
     required property var frameMaterial
 
     // ===============================================================
     // FRAME GEOMETRY (3 beams forming U-shape)
     // Центрируем U-раму относительно нуля координат по оси Z.
     // Нижняя балка проходит от -L/2 до +L/2, стойки на концах.
     // ===============================================================
 
     // 1. BOTTOM BEAM (horizontal, along Z axis) — центр по Z в 0
     Model {
         parent: worldRoot
         source: "#Cube"
         position: Qt.vector3d(0, beamSize/2, 0)
-        scale: Qt.vector3d(beamSize/100, beamSize/100, frameLength/100)
+        scale: Qt.vector3d(beamSize, beamSize, frameLength)
         materials: [frameMaterial]
     }
 
     // 2. FRONT VERTICAL BEAM (at Z = -frameLength/2 + beamSize/2)
     Model {
         parent: worldRoot
         source: "#Cube"
         position: Qt.vector3d(0, beamSize + frameHeight/2, -frameLength/2 + beamSize/2)
-        scale: Qt.vector3d(beamSize/100, frameHeight/100, beamSize/100)
+        scale: Qt.vector3d(beamSize, frameHeight, beamSize)
         materials: [frameMaterial]
     }
 
     // 3. REAR VERTICAL BEAM (at Z = +frameLength/2 - beamSize/2)
     Model {
         parent: worldRoot
         source: "#Cube"
         position: Qt.vector3d(0, beamSize + frameHeight/2, frameLength/2 - beamSize/2)
-        scale: Qt.vector3d(beamSize/100, frameHeight/100, beamSize/100)
+        scale: Qt.vector3d(beamSize, frameHeight, beamSize)
         materials: [frameMaterial]
     }
 
     // ===============================================================
     // INITIALIZATION
     // ===============================================================
 
     Component.onCompleted: {
-        console.log("🏗️ Frame initialized (centered): " + beamSize + " × " + frameHeight + " × " + frameLength + " mm")
+        console.log("🏗️ Frame initialized (centered): " + beamSize + " × " + frameHeight + " × " + frameLength + " m")
     }
 }
diff --git a/assets/qml/geometry/SuspensionCorner.qml b/assets/qml/geometry/SuspensionCorner.qml
index fecb805d34630c544632d5231e6891648d965ca6..eb53e15684b67d24a98ad1a3d4ef20f97f87a5a4 100644
--- a/assets/qml/geometry/SuspensionCorner.qml
+++ b/assets/qml/geometry/SuspensionCorner.qml
@@ -1,247 +1,264 @@
 import QtQuick
 import QtQuick3D
 
 /*
  * Suspension Corner Component - Complete suspension assembly
  * Extracted from main.qml for modular QML architecture
  *
  * Includes:
  * - Lever (arm)
  * - Tail rod
  * - Cylinder body (transparent)
  * - Piston (animated)
  * - Piston rod (from piston to j_rod)
  * - 3 Cylindrical joints (tail, arm, rod)
  */
 Node {
     id: suspensionCorner
 
     // ===============================================================
     // REQUIRED PROPERTIES - Joint positions and geometry
     // ===============================================================
 
     required property vector3d j_arm      // Arm pivot point
     required property vector3d j_tail     // Tail attachment point
-    required property real leverAngle     // Lever rotation angle (degrees)
-    required property real pistonPositionFromPython  // Piston position from simulation (mm)
+    required property real leverAngleRad  // Lever rotation angle (radians)
+    required property real pistonPositionM  // Piston position from simulation (m)
 
     // ===============================================================
     // GEOMETRY PARAMETERS (from root or defaults)
     // ===============================================================
 
-    property real leverLength: 800        // мм
+    property real leverLength: 0.8        // m
     property real rodPosition: 0.6        // Fraction (0.0 - 1.0)
-    property real cylinderLength: 500     // мм
-    property real boreHead: 80            // мм
-    property real rodDiameter: 35         // мм
-    property real pistonThickness: 25     // мм
-    property real pistonRodLength: 200    // мм
+    property real cylinderLength: 0.5     // m
+    property real boreHead: 0.08          // m
+    property real rodDiameter: 0.035      // m
+    property real pistonThickness: 0.025  // m
+    property real pistonRodLength: 0.2    // m
     property int cylinderSegments: 64
     property int cylinderRings: 8
     // Новый параметр длины хвостовика цилиндра (отрезок от j_tail до начала цилиндра)
-    property real tailRodLength: 100      // мм
+    property real tailRodLength: 0.1      // m
 
     // Масштабы шарниров (радиус/высота) как множители базовых значений
     property real jointTailScale: 1.0
     property real jointArmScale: 1.0
     property real jointRodScale: 1.0
 
     // ===============================================================
     // MATERIAL PROPERTIES (required from parent)
     // ===============================================================
 
     required property var leverMaterial
     required property var tailRodMaterial
     required property var cylinderMaterial
     required property var pistonBodyMaterial
     required property var pistonRodMaterial
     required property var jointTailMaterial
     required property var jointArmMaterial
     required property var jointRodMaterial
 
     // ===============================================================
     // CALCULATED PROPERTIES - Geometry calculations
     // ===============================================================
 
-    readonly property real baseAngle: (j_arm.x < 0) ? 180 : 0  // Left: 180°, Right: 0°
-    readonly property real totalAngle: baseAngle + leverAngle
+    readonly property real baseAngleRad: (j_arm.x < 0) ? Math.PI : 0
+    readonly property real baseAngle: baseAngleRad * 180 / Math.PI
+    readonly property real totalAngleRad: baseAngleRad + leverAngleRad
+    readonly property real totalAngle: totalAngleRad * 180 / Math.PI
+    property real leverAngle: leverAngleRad * 180 / Math.PI
 
     // Calculate j_rod position (rod attachment point on lever)
     readonly property vector3d j_rod: Qt.vector3d(
-        j_arm.x + (leverLength * rodPosition) * Math.cos(totalAngle * Math.PI / 180),
-        j_arm.y + (leverLength * rodPosition) * Math.sin(totalAngle * Math.PI / 180),
+        j_arm.x + (leverLength * rodPosition) * Math.cos(totalAngleRad),
+        j_arm.y + (leverLength * rodPosition) * Math.sin(totalAngleRad),
         j_arm.z
     )
 
     // Cylinder axis direction
     readonly property vector3d cylDirection: Qt.vector3d(j_rod.x - j_tail.x, j_rod.y - j_tail.y, 0)
     readonly property real cylDirectionLength: Math.hypot(cylDirection.x, cylDirection.y)
     readonly property vector3d cylDirectionNorm: Qt.vector3d(
         cylDirection.x / cylDirectionLength,
         cylDirection.y / cylDirectionLength,
         0
     )
 
     // Tail rod end position (cylinder starts here)
     readonly property vector3d tailRodEnd: Qt.vector3d(
         j_tail.x + cylDirectionNorm.x * tailRodLength,
         j_tail.y + cylDirectionNorm.y * tailRodLength,
         j_tail.z
     )
     readonly property vector3d cylStart: tailRodEnd
 
     // Cylinder end position
     readonly property vector3d cylEnd: Qt.vector3d(
         cylStart.x + cylDirectionNorm.x * cylinderLength,
         cylStart.y + cylDirectionNorm.y * cylinderLength,
         cylStart.z
     )
 
     // Piston center position (from Python simulation)
     readonly property vector3d pistonCenter: Qt.vector3d(
-        cylStart.x + cylDirectionNorm.x * pistonPositionFromPython,
-        cylStart.y + cylDirectionNorm.y * pistonPositionFromPython,
+        cylStart.x + cylDirectionNorm.x * pistonPositionM,
+        cylStart.y + cylDirectionNorm.y * pistonPositionM,
         cylStart.z
     )
 
+    readonly property real pistonPositionFromPython: pistonPositionM * 1000.0
+
     // ===============================================================
     // ERROR CHECKING - Rod length consistency
     // ===============================================================
 
     readonly property real rodLengthError: {
         const dx = j_rod.x - pistonCenter.x
         const dy = j_rod.y - pistonCenter.y
         const actualLength = Math.hypot(dx, dy)
         return Math.abs(actualLength - pistonRodLength)
     }
 
+    function metersToScale(value) {
+        return value * 10.0
+    }
+
+    readonly property real leverScale: metersToScale(leverLength)
+    readonly property real tailRodScale: metersToScale(tailRodLength)
+    readonly property real cylinderScale: metersToScale(cylinderLength)
+    readonly property real pistonThicknessScale: metersToScale(pistonThickness)
+    readonly property real pistonRodScale: metersToScale(pistonRodLength)
+    readonly property real boreHeadScale: metersToScale(boreHead)
+    readonly property real rodDiameterScale: metersToScale(rodDiameter)
+
     // ===============================================================
     // VISUAL COMPONENTS
     // ===============================================================
 
     // 1. LEVER (rotating arm)
     Model {
         source: "#Cube"
         position: Qt.vector3d(
-            j_arm.x + (leverLength/2) * Math.cos(totalAngle * Math.PI / 180),
-            j_arm.y + (leverLength/2) * Math.sin(totalAngle * Math.PI / 180),
+            j_arm.x + (leverLength/2) * Math.cos(totalAngleRad),
+            j_arm.y + (leverLength/2) * Math.sin(totalAngleRad),
             j_arm.z
         )
-        scale: Qt.vector3d(leverLength/100, 0.8, 0.8)
+        scale: Qt.vector3d(leverScale, 0.8, 0.8)
         eulerRotation: Qt.vector3d(0, 0, totalAngle)
         materials: [leverMaterial]
     }
 
     // 2. TAIL ROD (from j_tail to cylinder start)
     Model {
         source: "#Cylinder"
         position: Qt.vector3d(
             (j_tail.x + tailRodEnd.x)/2,
             (j_tail.y + tailRodEnd.y)/2,
             j_tail.z
         )
-        scale: Qt.vector3d(0.5, tailRodLength/100, 0.5)
+        scale: Qt.vector3d(0.5, tailRodScale, 0.5)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(tailRodEnd.y - j_tail.y, tailRodEnd.x - j_tail.x) * 180 / Math.PI + 90)
         materials: [tailRodMaterial]
     }
 
     // 3. CYLINDER BODY (transparent, fixed)
     Model {
         source: "#Cylinder"
         position: Qt.vector3d(
             (cylStart.x + cylEnd.x)/2,
             (cylStart.y + cylEnd.y)/2,
             cylStart.z
         )
-        scale: Qt.vector3d(boreHead/100 * 1.2, cylinderLength/100, boreHead/100 * 1.2)
+        scale: Qt.vector3d(boreHeadScale * 1.2, cylinderScale, boreHeadScale * 1.2)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(cylEnd.y - cylStart.y, cylEnd.x - cylStart.x) * 180 / Math.PI + 90)
         materials: [cylinderMaterial]
     }
 
     // 4. PISTON (moving, position from Python)
     Model {
         source: "#Cylinder"
         position: pistonCenter
         // ✅ ЕДИНОЕ масштабирование /100 для согласованности
-        scale: Qt.vector3d(boreHead/100 * 1.08, pistonThickness/100, boreHead/100 * 1.08)
+        scale: Qt.vector3d(boreHeadScale * 1.08, pistonThicknessScale, boreHeadScale * 1.08)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(cylDirection.y, cylDirection.x) * 180 / Math.PI + 90)
         materials: [pistonBodyMaterial]
     }
 
     // 5. PISTON ROD (from piston to j_rod, CONSTANT length)
     Model {
         source: "#Cylinder"
 
         // Direction from piston to j_rod
         property real rodDirX: j_rod.x - pistonCenter.x
         property real rodDirY: j_rod.y - pistonCenter.y
         property real rodDirLen: Math.hypot(rodDirX, rodDirY)
 
         // Normalized direction
         property real rodDirNormX: rodDirX / rodDirLen
         property real rodDirNormY: rodDirY / rodDirLen
 
         // Rod end position (piston + rodLength in direction of j_rod)
         property vector3d rodEnd: Qt.vector3d(
             pistonCenter.x + rodDirNormX * pistonRodLength,
             pistonCenter.y + rodDirNormY * pistonRodLength,
             pistonCenter.z
         )
 
         position: Qt.vector3d(
             (pistonCenter.x + rodEnd.x)/2,
             (pistonCenter.y + rodEnd.y)/2,
             pistonCenter.z
         )
         // ✅ ЕДИНОЕ масштабирование /100 для согласованности
-        scale: Qt.vector3d(rodDiameter/100 * 0.5, pistonRodLength/100, rodDiameter/100 * 0.5)
+        scale: Qt.vector3d(rodDiameterScale * 0.5, pistonRodScale, rodDiameterScale * 0.5)
         eulerRotation: Qt.vector3d(0, 0, Math.atan2(rodEnd.y - pistonCenter.y, rodEnd.x - pistonCenter.x) * 180 / Math.PI + 90)
         materials: [pistonRodMaterial]
     }
 
     // ===============================================================
     // JOINTS (cylindrical, Z-axis oriented)
     // ===============================================================
 
     // 6. TAIL JOINT (blue, at j_tail)
     Model {
         source: "#Cylinder"
         position: j_tail
         // Масштабируем базовые значения через множитель jointTailScale
         scale: Qt.vector3d(1.2 * jointTailScale, 2.4 * jointTailScale, 1.2 * jointTailScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointTailMaterial]
     }
 
     // 7. ARM JOINT (orange, at j_arm)
     Model {
         source: "#Cylinder"
         position: j_arm
         scale: Qt.vector3d(1.0 * jointArmScale, 2.0 * jointArmScale, 1.0 * jointArmScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointArmMaterial]
     }
 
     // 8. ROD JOINT (green, at j_rod)
     Model {
         source: "#Cylinder"
         position: j_rod
         scale: Qt.vector3d(0.8 * jointRodScale, 1.6 * jointRodScale, 0.8 * jointRodScale)
         eulerRotation: Qt.vector3d(90, 0, 0)
         materials: [jointRodMaterial]
     }
 
     // ===============================================================
     // INITIALIZATION
     // ===============================================================
 
     Component.onCompleted: {
         console.log("🔧 SuspensionCorner initialized:")
         console.log("   j_arm:", j_arm.x, j_arm.y, j_arm.z)
         console.log("   j_tail:", j_tail.x, j_tail.y, j_tail.z)
         console.log("   j_rod:", j_rod.x, j_rod.y, j_rod.z)
-        console.log("   leverAngle:", leverAngle, "deg")
-        console.log("   pistonPosition:", pistonPositionFromPython, "mm")
-        console.log("   rodLengthError:", rodLengthError.toFixed(2), "mm")
+        console.log("   leverAngle:", leverAngleRad.toFixed(3), "rad")
+        console.log("   pistonPosition:", pistonPositionM.toFixed(3), "m")
+        console.log("   rodLengthError:", rodLengthError.toFixed(4), "m")
     }
 }
diff --git a/src/ui/geometry_bridge.py b/src/ui/geometry_bridge.py
index 2e70fb51efc06fa7552da80f8c9371060f38f678..1c3f48dc2a378bd21f0ecaf1e73e951dea18c04d 100644
--- a/src/ui/geometry_bridge.py
+++ b/src/ui/geometry_bridge.py
@@ -1,73 +1,102 @@
 # -*- coding: utf-8 -*-
 """
 Geometry-to-3D bridge module
 Converts 2D kinematics geometry to 3D visualization coordinates
 INTEGRATED WITH USER INTERFACE CONTROLS
 """
 import numpy as np
 from PySide6.QtGui import QVector3D
 from PySide6.QtCore import QObject, Signal, Property
 from typing import Dict, Any, Optional
 
-from ..core.settings import SettingsManager
+from src.common.settings_manager import SettingsManager, get_settings_manager
 from ..core.geometry import GeometryParams
 
 
 class GeometryTo3DConverter(QObject):
     """Converts 2D geometry parameters to 3D visualization coordinates
     WITH USER INTERFACE INTEGRATION"""
 
     # Signals for parameter changes
     geometryChanged = Signal()
     frameChanged = Signal()
 
-    def __init__(self, geometry: GeometryParams):
+    def __init__(
+        self,
+        geometry: GeometryParams,
+        settings_manager: Optional[SettingsManager] = None,
+    ):
         """Initialize geometry bridge converter"""
         super().__init__()
         self.geometry = geometry
 
+        self._settings_manager = settings_manager or get_settings_manager()
+
+        defaults = self._load_defaults()
+
         # USER-CONTROLLABLE PARAMETERS (will be connected to UI)
-        self._frame_beam_size = 120.0  # mm - beam size
-        self._frame_height = 650.0  # mm - horn height
-        self._frame_length = 2000.0  # mm - frame length (2 meters!)
-        self._lever_length = 315.0  # mm - lever length
-        self._cylinder_body_length = 250.0  # mm - cylinder working length
-        self._tail_rod_length = 100.0  # mm - tail extension length
+        self._frame_beam_size = defaults["frame_beam_size_m"]
+        self._frame_height = defaults["frame_height_m"]
+        self._frame_length = defaults["frame_length_m"]
+        self._lever_length = defaults["lever_length_m"]
+        self._cylinder_body_length = defaults["cylinder_body_length_m"]
+        self._tail_rod_length = defaults["tail_rod_length_m"]
 
         # Z-coordinates for front/rear - calculated from frame length
-        self._front_z = -self._frame_length / 2.0  # Front at -1000mm
-        self._rear_z = self._frame_length / 2.0  # Rear at +1000mm
+        self._front_z = -self._frame_length / 2.0
+        self._rear_z = self._frame_length / 2.0
+
+    def _load_defaults(self) -> Dict[str, float]:
+        geometry_defaults = {
+            "frame_beam_size_m": 0.12,
+            "frame_height_m": 0.65,
+            "frame_length_m": 2.0,
+            "lever_length_m": 0.315,
+            "cylinder_body_length_m": 0.25,
+            "tail_rod_length_m": 0.1,
+        }
 
-        print("    GeometryBridge initialized:")
-        print(
-            f"      Frame: {self._frame_length:.0f}x{self._frame_height:.0f}x{self._frame_beam_size:.0f}mm"
-        )
-        print(f"      Lever: {self._lever_length:.0f}mm")
-        print(
-            f"      Cylinder: {self._cylinder_body_length:.0f}mm + {self._tail_rod_length:.0f}mm tail"
-        )
+        if self._settings_manager is None:
+            return geometry_defaults
+
+        settings = self._settings_manager.get_category("geometry") or {}
+
+        def _value_for(key: str, fallback: float) -> float:
+            value = settings.get(key)
+            if isinstance(value, (int, float)):
+                return float(value)
+            legacy_key = key.replace("_m", "_mm")
+            legacy_value = settings.get(legacy_key)
+            if isinstance(legacy_value, (int, float)):
+                return float(legacy_value) / 1000.0
+            return fallback
+
+        for key, fallback in geometry_defaults.items():
+            geometry_defaults[key] = _value_for(key, fallback)
+
+        return geometry_defaults
 
     # USER-CONTROLLABLE PROPERTIES (connected to UI sliders/spinboxes)
 
     @Property(float, notify=frameChanged)
     def frameLength(self):
         return self._frame_length
 
     @frameLength.setter
     def frameLength(self, value):
         if self._frame_length != value:
             self._frame_length = value
             self._front_z = -value / 2.0
             self._rear_z = value / 2.0
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=frameChanged)
     def frameHeight(self):
         return self._frame_height
 
     @frameHeight.setter
     def frameHeight(self, value):
         if self._frame_height != value:
             self._frame_height = value
             self.frameChanged.emit()
@@ -130,167 +159,167 @@ class GeometryTo3DConverter(QObject):
     ) -> Dict[str, Any]:
         """Convert 2D kinematics to 3D coordinates for one corner
         USING CORRECTED SUSPENSION MECHANICS FROM test_2m_suspension.py
 
         Args:
             corner: 'fl', 'fr', 'rl', 'rr'
             lever_angle_deg: Current lever angle in degrees
             cylinder_state: Optional CylinderState from physics simulation
 
         Returns:
             Dictionary with 3D coordinates for QML (compatible with CorrectedSuspensionCorner)
         """
         # Determine side and position
         is_left = corner.endswith("l")  # fl, rl = left side
         is_front = corner.startswith("f")  # fl, fr = front
 
         # Side multiplier for mirroring
         side_mult = -1.0 if is_left else 1.0
 
         # Z position (longitudinal)
         z_plane = self._front_z if is_front else self._rear_z
 
         # FIXED FRAME ATTACHMENT POINTS (never change)
 
         # Lever pivot (j_arm) - FIXED attachment to frame
-        pivot_offset_x = 150.0  # mm from center
+        pivot_offset_x = 0.15  # m from center
         pivot_height = self._frame_beam_size / 2.0  # ON BEAM AXIS
 
         j_arm = QVector3D(
             pivot_offset_x * side_mult,  # ±150mm from center
             pivot_height,  # beam axis height
             z_plane,  # EXACTLY in plane
         )
 
         # Cylinder tail (j_tail) - FIXED attachment to frame
         horn_height = self._frame_beam_size + self._frame_height  # total horn height
         tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset
-        tail_offset_x = 100.0  # mm from center
+        tail_offset_x = 0.1  # m from center
 
         j_tail = QVector3D(
             tail_offset_x * side_mult,  # ±100mm from center
             tail_height,  # horn height
             z_plane,  # EXACTLY in plane
         )
 
         # MOVING PARTS (depend on lever angle)
 
         # Base angle: LEFT side points LEFT (180°), RIGHT side points RIGHT (0°)
         base_angle_deg = 180.0 if is_left else 0.0
         total_angle_deg = base_angle_deg + lever_angle_deg
         total_angle_rad = np.deg2rad(total_angle_deg)
 
         # Rod attachment point on lever (at lever end)
         rod_attach_x = j_arm.x() + self._lever_length * np.cos(total_angle_rad)
         rod_attach_y = j_arm.y() + self._lever_length * np.sin(total_angle_rad)
 
         j_rod = QVector3D(rod_attach_x, rod_attach_y, z_plane)
 
         # PISTON POSITION CALCULATION
         # Calculate from GEOMETRY (correct kinematics!)
         # Distance from tail to rod attachment point
         tail_to_rod_dist = np.sqrt(
             (j_rod.x() - j_tail.x()) ** 2 + (j_rod.y() - j_tail.y()) ** 2
         )
 
         # Total assembly: tail_rod + cylinder_body + piston_rod
         # tail_rod = FIXED 100mm
         # cylinder_body = FIXED 250mm
         # piston_rod = VARIABLE (depends on lever angle!)
 
         # Calculate baseline distance (lever horizontal)
         base_angle_rad = np.deg2rad(base_angle_deg)
         base_rod_x = j_arm.x() + self._lever_length * np.cos(base_angle_rad)
         base_rod_y = j_arm.y() + self._lever_length * np.sin(base_angle_rad)
         base_dist = np.sqrt(
             (base_rod_x - j_tail.x()) ** 2 + (base_rod_y - j_tail.y()) ** 2
         )
 
         # Change in distance from baseline
         delta_dist = tail_to_rod_dist - base_dist
 
         # Piston position inside cylinder:
         # When lever is horizontal (baseline), piston is centered
         # When lever rotates, distance changes ? piston moves
         # Piston moves IN SAME DIRECTION as rod extension
         # (if rod extends/distance increases, piston moves toward rod end/increases)
         # CORRECTED: Use PLUS (not minus) because piston follows rod extension
-        piston_position_mm = (self._cylinder_body_length / 2.0) + delta_dist
+        piston_position_m = (self._cylinder_body_length / 2.0) + delta_dist
 
         # Clip to safe range (10% to 90% of cylinder length)
-        piston_position_mm = float(
+        piston_position_m = float(
             np.clip(
-                piston_position_mm,
-                self._cylinder_body_length
-                * 0.1,  # 10% minimum (25mm for 250mm cylinder)
-                self._cylinder_body_length
-                * 0.9,  # 90% maximum (225mm for 250mm cylinder)
+                piston_position_m,
+                self._cylinder_body_length * 0.1,
+                self._cylinder_body_length * 0.9,
             )
         )
 
         # Calculate ratio for QML
-        piston_ratio = float(piston_position_mm / self._cylinder_body_length)
+        piston_ratio = float(piston_position_m / self._cylinder_body_length)
 
         # If cylinder_state provided, OVERRIDE with physics data
         if cylinder_state is not None:
             # Use actual physics data from CylinderKinematics
-            stroke_mm = cylinder_state.stroke * 1000.0  # m to mm
-
             # Calculate piston position from stroke
             # Assuming stroke 0 = center of cylinder
-            max_stroke_mm = self._cylinder_body_length * 0.4  # ±40% stroke range
-            piston_ratio_physics = 0.5 + (stroke_mm / (2 * max_stroke_mm))
-            piston_ratio_physics = float(np.clip(piston_ratio_physics, 0.1, 0.9))
-            piston_position_mm_physics = (
-                piston_ratio_physics * self._cylinder_body_length
+            max_stroke = self._cylinder_body_length * 0.4  # ±40% stroke range
+            piston_ratio_physics = 0.5 + (
+                cylinder_state.stroke / (2 * max_stroke)
             )
+            piston_ratio_physics = float(np.clip(piston_ratio_physics, 0.1, 0.9))
+            piston_position_physics = piston_ratio_physics * self._cylinder_body_length
 
             # Use physics values
-            piston_position_mm = float(piston_position_mm_physics)
+            piston_position_m = float(piston_position_physics)
             piston_ratio = float(piston_ratio_physics)
 
         # Return data compatible with CorrectedSuspensionCorner.qml
         result = {
             # FIXED joints
             "j_arm": j_arm,  # Lever pivot (orange joint)
             "j_tail": j_tail,  # Cylinder mount (blue joint)
             "j_rod": j_rod,  # Rod attachment (green joint)
             # Animation
             "leverAngle": float(lever_angle_deg),
+            "leverAngleRad": float(np.deg2rad(lever_angle_deg)),
             # Dimensions (for QML calculations)
             "leverLength": float(self._lever_length),
+            "leverLengthM": float(self._lever_length),
             "cylinderBodyLength": float(self._cylinder_body_length),
+            "cylinderBodyLengthM": float(self._cylinder_body_length),
             "tailRodLength": float(self._tail_rod_length),
+            "tailRodLengthM": float(self._tail_rod_length),
             # PISTON POSITION (ALWAYS float, never None or empty!)
-            "pistonPositionMm": float(
-                piston_position_mm
-            ),  # Absolute position in cylinder (mm)
+            "pistonPositionM": float(piston_position_m),
             "pistonRatio": float(piston_ratio),  # Ratio 0..1 inside cylinder
             # Additional data for UI
             "corner": corner,
             "totalAngle": float(total_angle_deg),
+            "totalAngleRad": float(total_angle_rad),
             "baseAngle": float(base_angle_deg),
+            "baseAngleRad": float(np.deg2rad(base_angle_deg)),
             "side": "left" if is_left else "right",
             "position": "front" if is_front else "rear",
         }
 
         # If cylinder_state provided, add full physics data
         if cylinder_state is not None:
             result["cylinderPhysics"] = {
                 "stroke": cylinder_state.stroke,
                 "strokeVelocity": cylinder_state.stroke_velocity,
                 "volumeHead": cylinder_state.volume_head,
                 "volumeRod": cylinder_state.volume_rod,
                 "distance": cylinder_state.distance,
                 "axisAngle": cylinder_state.cylinder_axis_angle,
             }
 
         return result
 
     def get_all_corners_3d(
         self,
         lever_angles: Optional[Dict[str, float]] = None,
         cylinder_states: Optional[Dict[str, Any]] = None,
     ) -> Dict[str, Dict[str, Any]]:
         """Get 3D coordinates for all 4 corners
 
         Args:
@@ -381,97 +410,102 @@ class GeometryTo3DConverter(QObject):
         if (
             "frameBeamSize" in params
             and params["frameBeamSize"] != self._frame_beam_size
         ):
             self.frameBeamSize = params["frameBeamSize"]
             changed = True
 
         if "leverLength" in params and params["leverLength"] != self._lever_length:
             self.leverLength = params["leverLength"]
             changed = True
 
         if (
             "cylinderBodyLength" in params
             and params["cylinderBodyLength"] != self._cylinder_body_length
         ):
             self.cylinderBodyLength = params["cylinderBodyLength"]
             changed = True
 
         if (
             "tailRodLength" in params
             and params["tailRodLength"] != self._tail_rod_length
         ):
             self.tailRodLength = params["tailRodLength"]
             changed = True
 
-        if changed:
-            print(f"    GeometryBridge updated: {params}")
-
         # Persist changes to settings manager
         if persist:
             self.save_to_settings()
 
     def save_to_settings(self):
         """Save current geometry settings to persistent storage"""
-        # Collect settings data
-        settings_data = {
-            "frameLength": self._frame_length,
-            "frameHeight": self._frame_height,
-            "frameBeamSize": self._frame_beam_size,
-            "leverLength": self._lever_length,
-            "cylinderBodyLength": self._cylinder_body_length,
-            "tailRodLength": self._tail_rod_length,
+        if self._settings_manager is None:
+            return
+
+        updates = {
+            "frame.frame_length_m": self._frame_length,
+            "frame.frame_height_m": self._frame_height,
+            "frame.frame_beam_size_m": self._frame_beam_size,
+        }
+
+        geometry_updates = {
+            "geometry.frame_length_m": self._frame_length,
+            "geometry.frame_height_m": self._frame_height,
+            "geometry.frame_beam_size_m": self._frame_beam_size,
+            "geometry.lever_length_m": self._lever_length,
+            "geometry.cylinder_body_length_m": self._cylinder_body_length,
+            "geometry.tail_rod_length_m": self._tail_rod_length,
         }
 
-        # Update settings manager
-        SettingsManager.set_geometry_settings(settings_data)
+        for path, value in geometry_updates.items():
+            self._settings_manager.set(path, value, auto_save=False)
+
+        # The legacy frame.* keys are kept for compatibility if present
+        for path, value in updates.items():
+            if self._settings_manager.get(path) is not None:
+                self._settings_manager.set(path, value, auto_save=False)
 
-        print(f"    Geometry settings saved: {settings_data}")
+        self._settings_manager.save()
 
     def export_geometry_params(self) -> Dict[str, Any]:
         """Export current geometry parameters as dictionary
 
         Returns:
             Dictionary with geometry parameters for export
         """
         return {
             "frameLength": self._frame_length,
             "frameHeight": self._frame_height,
             "frameBeamSize": self._frame_beam_size,
             "leverLength": self._lever_length,
             "cylinderBodyLength": self._cylinder_body_length,
             "tailRodLength": self._tail_rod_length,
         }
 
 
 # Convenience function for easy integration
 def create_geometry_converter(
     wheelbase: float = 2.0,
     lever_length: float = 0.315,
     cylinder_diameter: float = 0.08,
-    settings_manager: Optional[Any] = None,
+    settings_manager: Optional[SettingsManager] = None,
 ) -> GeometryTo3DConverter:
     """Create geometry converter with common parameters
 
     Args:
         wheelbase: Vehicle track width in meters
         lever_length: Suspension lever length in meters
         cylinder_diameter: Cylinder bore diameter in meters
         settings_manager: Optional SettingsManager instance for persistent settings
 
     Returns:
         Configured GeometryTo3DConverter
     """
     geometry = GeometryParams()
     geometry.wheelbase = wheelbase
     geometry.lever_length = lever_length
     geometry.cylinder_inner_diameter = cylinder_diameter
     geometry.enforce_track_from_geometry()  # Ensure consistency
 
-    converter = GeometryTo3DConverter(geometry)
-
-    # Load settings from manager if available
-    if settings_manager is not None:
-        settings = settings_manager.get_geometry_settings()
-        converter.update_user_parameters(settings, persist=False)
+    converter = GeometryTo3DConverter(geometry, settings_manager=settings_manager)
 
     return converter
diff --git a/tests/ui/test_geometry_bridge_units.py b/tests/ui/test_geometry_bridge_units.py
new file mode 100644
index 0000000000000000000000000000000000000000..e283df73d30671a3d15d6cd7a675d5daab0552b3
--- /dev/null
+++ b/tests/ui/test_geometry_bridge_units.py
@@ -0,0 +1,176 @@
+import importlib.util
+import math
+import sys
+import types
+from pathlib import Path
+from typing import Any, Dict
+
+import numpy as np
+
+from src.core.geometry import GeometryParams
+
+
+def _install_pyside_stubs() -> None:
+    if "PySide6" in sys.modules:
+        return
+
+    qtcore = types.ModuleType("PySide6.QtCore")
+    qtgui = types.ModuleType("PySide6.QtGui")
+
+    class QObject:  # type: ignore
+        def __init__(self, *args: Any, **kwargs: Any) -> None:
+            pass
+
+    class Signal:  # type: ignore
+        def __init__(self, *args: Any, **kwargs: Any) -> None:
+            pass
+
+        def emit(self, *args: Any, **kwargs: Any) -> None:  # pragma: no cover - stub
+            pass
+
+    def Property(*args: Any, **kwargs: Any):  # type: ignore
+        def decorator(func):
+            return property(func)
+
+        return decorator
+
+    class QVector3D:  # type: ignore
+        def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0) -> None:
+            self._x = float(x)
+            self._y = float(y)
+            self._z = float(z)
+
+        def x(self) -> float:
+            return self._x
+
+        def y(self) -> float:
+            return self._y
+
+        def z(self) -> float:
+            return self._z
+
+        def __repr__(self) -> str:  # pragma: no cover - debug helper
+            return f"QVector3D({self._x}, {self._y}, {self._z})"
+
+    qtcore.QObject = QObject  # type: ignore[attr-defined]
+    qtcore.Signal = Signal  # type: ignore[attr-defined]
+    qtcore.Property = Property  # type: ignore[attr-defined]
+    qtgui.QVector3D = QVector3D  # type: ignore[attr-defined]
+
+    pyside = types.ModuleType("PySide6")
+    pyside.QtCore = qtcore  # type: ignore[attr-defined]
+    pyside.QtGui = qtgui  # type: ignore[attr-defined]
+
+    sys.modules["PySide6"] = pyside
+    sys.modules["PySide6.QtCore"] = qtcore
+    sys.modules["PySide6.QtGui"] = qtgui
+
+
+_install_pyside_stubs()
+
+project_root = Path(__file__).resolve().parents[2]
+MODULE_PATH = project_root / "src" / "ui" / "geometry_bridge.py"
+
+if "src" not in sys.modules:
+    src_pkg = types.ModuleType("src")
+    src_pkg.__path__ = [str(project_root / "src")]
+    sys.modules["src"] = src_pkg
+
+if "src.ui" not in sys.modules:
+    ui_pkg = types.ModuleType("src.ui")
+    ui_pkg.__path__ = [str(project_root / "src" / "ui")]
+    sys.modules["src.ui"] = ui_pkg
+
+spec = importlib.util.spec_from_file_location(
+    "src.ui.geometry_bridge", MODULE_PATH
+)
+geometry_bridge = importlib.util.module_from_spec(spec)
+assert spec is not None and spec.loader is not None
+spec.loader.exec_module(geometry_bridge)
+
+GeometryTo3DConverter = geometry_bridge.GeometryTo3DConverter
+
+
+class DummySettingsManager:
+    def __init__(self) -> None:
+        self._data: Dict[str, Any] = {
+            "geometry": {
+                "frame_length_mm": 2000.0,
+                "frame_height_mm": 650.0,
+                "frame_beam_size_mm": 120.0,
+                "lever_length_mm": 315.0,
+                "cylinder_body_length_mm": 250.0,
+                "tail_rod_length_mm": 100.0,
+            }
+        }
+        self.saved = False
+
+    def get_category(self, category: str) -> Dict[str, Any]:
+        value = self._data.get(category, {})
+        return {**value} if isinstance(value, dict) else {}
+
+    def set(self, path: str, value: Any, auto_save: bool = True) -> bool:
+        keys = path.split(".")
+        current = self._data
+        for key in keys[:-1]:
+            current = current.setdefault(key, {})
+        current[keys[-1]] = value
+        return True
+
+    def get(self, path: str, default: Any = None) -> Any:
+        keys = path.split(".")
+        current: Any = self._data
+        for key in keys:
+            if not isinstance(current, dict) or key not in current:
+                return default
+            current = current[key]
+        return current
+
+    def save(self) -> bool:
+        self.saved = True
+        return True
+
+
+def create_converter() -> GeometryTo3DConverter:
+    settings = DummySettingsManager()
+    geometry = GeometryParams()
+    return GeometryTo3DConverter(geometry, settings_manager=settings)
+
+
+def test_defaults_are_converted_to_meters() -> None:
+    converter = create_converter()
+
+    assert math.isclose(converter.frameLength, 2.0)
+    assert math.isclose(converter.frameHeight, 0.65)
+    assert math.isclose(converter.frameBeamSize, 0.12)
+    assert math.isclose(converter.leverLength, 0.315)
+    assert math.isclose(converter.cylinderBodyLength, 0.25)
+
+    frame_params = converter.get_frame_params()
+    assert math.isclose(frame_params["frameLength"], 2.0)
+    assert math.isclose(frame_params["frameHeight"], 0.65)
+    assert math.isclose(frame_params["beamSize"], 0.12)
+
+
+def test_corner_coordinates_use_si_units() -> None:
+    converter = create_converter()
+
+    coords_zero = converter.get_corner_3d_coords("fl", lever_angle_deg=0.0)
+    assert math.isclose(coords_zero["j_arm"].x(), -0.15, rel_tol=1e-6)
+    assert math.isclose(coords_zero["j_arm"].y(), 0.06, rel_tol=1e-6)
+    assert math.isclose(coords_zero["j_arm"].z(), -1.0, rel_tol=1e-6)
+    assert math.isclose(coords_zero["leverAngleRad"], 0.0)
+    assert math.isclose(coords_zero["totalAngleRad"], math.pi)
+    expected_j_rod_x = -0.15 + 0.315 * math.cos(math.pi)
+    expected_j_rod_y = 0.06 + 0.315 * math.sin(math.pi)
+    assert math.isclose(coords_zero["j_rod"].x(), expected_j_rod_x, rel_tol=1e-6)
+    assert math.isclose(coords_zero["j_rod"].y(), expected_j_rod_y, rel_tol=1e-6)
+    assert math.isclose(coords_zero["pistonPositionM"], coords_zero["pistonRatio"] * 0.25)
+
+    coords_offset = converter.get_corner_3d_coords("fr", lever_angle_deg=-15.0)
+    assert math.isclose(coords_offset["j_arm"].x(), 0.15, rel_tol=1e-6)
+    assert math.isclose(coords_offset["j_arm"].z(), -1.0, rel_tol=1e-6)
+    assert math.isclose(coords_offset["leverAngleRad"], np.deg2rad(-15.0))
+    total_angle_expected = np.deg2rad(-15.0)
+    assert math.isclose(coords_offset["totalAngleRad"], total_angle_expected)
+    assert coords_offset["pistonPositionM"] <= converter.cylinderBodyLength + 1e-9
diff --git a/.github/workflows/ci-cd.yml b/.github/workflows/ci-cd.yml
index f43ddb8cb44a5a72ea3236ef7a0173e3f3f46d65..f8031fc2d2959d29709d722572fa35fb53eed305 100644
--- a/.github/workflows/ci-cd.yml
+++ b/.github/workflows/ci-cd.yml
@@ -1,40 +1,42 @@
 name: CI/CD Pipeline
 
 on:
   push:
     branches: [ master, develop ]
   pull_request:
     branches: [ master, develop ]
 
 jobs:
   test:
     name: Test Suite
     runs-on: ${{ matrix.os }}
     env:
       QT_QPA_PLATFORM: offscreen
       QT_QUICK_BACKEND: software
+      QT_PLUGIN_PATH: ''
+      QML2_IMPORT_PATH: ''
     strategy:
       fail-fast: false
       matrix:
         os: [ubuntu-latest, windows-latest, macos-latest]
         python-version: ['3.10', '3.11', '3.12']
 
     steps:
     - name: Checkout code
       uses: actions/checkout@v4
 
     - name: Set up Python ${{ matrix.python-version }}
       uses: actions/setup-python@v5
       with:
         python-version: ${{ matrix.python-version }}
 
     - name: Install project and dependencies
       run: |
         python -m pip install --upgrade pip
         pip install .[dev]
 
     - name: Configure Qt runtime paths
       shell: python
       run: |
         import os
         from pathlib import Path
@@ -44,59 +46,73 @@ jobs:
                 return
             env_file = Path(os.environ["GITHUB_ENV"])
             with env_file.open("a", encoding="utf-8") as handle:
                 handle.write(f"{key}={value}\n")
 
         try:
             from PySide6.QtCore import QLibraryInfo, LibraryLocation
         except Exception as exc: # pragma: no cover - diagnostic output only
             print(f"Unable to configure Qt paths automatically: {exc}")
         else:
             write_env("QT_PLUGIN_PATH", QLibraryInfo.path(LibraryLocation.Plugins))
             write_env("QML2_IMPORT_PATH", QLibraryInfo.path(LibraryLocation.QmlImports))
 
     - name: Configure pytest command
       shell: bash
       run: |
         if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
           echo "PYTEST_PREFIX=xvfb-run -a" >> "$GITHUB_ENV"
         else
           echo "PYTEST_PREFIX=" >> "$GITHUB_ENV"
         fi
 
     - name: Run unit tests
       shell: bash
       run: |
-        ${PYTEST_PREFIX:-} pytest tests/unit/ -v --cov=src --cov-report=xml
+        if [ -n "${PYTEST_PREFIX:-}" ]; then
+          ${PYTEST_PREFIX} pytest tests/unit/ -v --cov=src --cov-report=xml
+        else
+          pytest tests/unit/ -v --cov=src --cov-report=xml
+        fi
 
     - name: Run integration tests
+      shell: bash
       run: |
-        pytest tests/integration/ -v --cov=src --cov-report=xml --cov-append
+        if [ -n "${PYTEST_PREFIX:-}" ]; then
+          ${PYTEST_PREFIX} pytest tests/integration/ -v --cov=src --cov-report=xml --cov-append
+        else
+          pytest tests/integration/ -v --cov=src --cov-report=xml --cov-append
+        fi
 
     - name: Run system tests
+      shell: bash
       run: |
-        pytest tests/system/ -v --cov=src --cov-report=xml --cov-append
+        if [ -n "${PYTEST_PREFIX:-}" ]; then
+          ${PYTEST_PREFIX} pytest tests/system/ -v --cov=src --cov-report=xml --cov-append
+        else
+          pytest tests/system/ -v --cov=src --cov-report=xml --cov-append
+        fi
 
     - name: Upload coverage to Codecov
       uses: codecov/codecov-action@v4
       with:
         file: ./coverage.xml
         flags: unit,integration,system
         name: codecov-${{ matrix.os }}-${{ matrix.python-version }}
 
   lint:
     name: Code Quality
     runs-on: ubuntu-latest
 
     steps:
     - name: Checkout code
       uses: actions/checkout@v4
 
     - name: Set up Python
       uses: actions/setup-python@v5
       with:
         python-version: '3.12'
 
     - name: Install lint dependencies
       run: |
         python -m pip install --upgrade pip
         pip install .[dev]
diff --git a/run_tests_after_exit.py b/run_tests_after_exit.py
index 8aa8e60f31b4017fc2f7fd9fefb54d874a6cebb2..add53e6a3d9ce2de4fda648bc444f9d68428d246 100644
--- a/run_tests_after_exit.py
+++ b/run_tests_after_exit.py
@@ -1,44 +1,46 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 """
 Post-Exit Test Runner
 Запускает тестовые скрипты ПОСЛЕ закрытия приложения
 """
 
 import os
 import sys
 import subprocess
 import time
 from functools import lru_cache
 from pathlib import Path
 from typing import Dict, List, Optional
 
 
 QT_ENV_DEFAULTS: Dict[str, str] = {
     "QT_QPA_PLATFORM": "offscreen",
     "QT_QUICK_BACKEND": "software",
+    "QT_PLUGIN_PATH": "",
+    "QML2_IMPORT_PATH": "",
 }
 
 
 @lru_cache(maxsize=1)
 def _detect_qt_environment() -> Dict[str, str]:
     """Возвращает значения переменных окружения для корректной работы Qt."""
 
     environment = dict(QT_ENV_DEFAULTS)
 
     try:
         from PySide6.QtCore import QLibraryInfo, LibraryLocation  # type: ignore
     except Exception as exc:  # pragma: no cover - диагностический вывод
         print(f"⚠️ Не удалось определить пути Qt автоматически: {exc}")
         return environment
 
     plugin_path = QLibraryInfo.path(LibraryLocation.Plugins)
     if plugin_path:
         environment["QT_PLUGIN_PATH"] = plugin_path
 
     qml_import_path = QLibraryInfo.path(LibraryLocation.QmlImports)
     if qml_import_path:
         environment["QML2_IMPORT_PATH"] = qml_import_path
 
     return environment
 
diff --git a/setup_environment.py b/setup_environment.py
index 9f7a9732af26eeb4ef3b7fdc545640d3e24fa7a0..91a294a9cd8f4e358a40144e1aba6dee472ad357 100644
--- a/setup_environment.py
+++ b/setup_environment.py
@@ -1,44 +1,46 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 """
 PneumoStabSim-Professional Environment Setup Script
 Скрипт для автоматической настройки окружения разработки
 """
 
 import os
 import sys
 import subprocess
 from functools import lru_cache
 from pathlib import Path
 from typing import Dict
 import platform
 
 
 QT_ENV_DEFAULTS: Dict[str, str] = {
     "QT_QPA_PLATFORM": "offscreen",
     "QT_QUICK_BACKEND": "software",
+    "QT_PLUGIN_PATH": "",
+    "QML2_IMPORT_PATH": "",
 }
 
 
 @lru_cache(maxsize=1)
 def _detect_qt_environment() -> Dict[str, str]:
     """Возвращает рекомендуемые переменные окружения Qt."""
 
     environment = dict(QT_ENV_DEFAULTS)
 
     try:
         from PySide6.QtCore import QLibraryInfo, LibraryLocation  # type: ignore
     except Exception as exc:  # pragma: no cover - диагностический вывод
         print(f"⚠️ Не удалось автоматически определить пути Qt: {exc}")
         return environment
 
     plugin_path = QLibraryInfo.path(LibraryLocation.Plugins)
     if plugin_path:
         environment["QT_PLUGIN_PATH"] = plugin_path
 
     qml_import_path = QLibraryInfo.path(LibraryLocation.QmlImports)
     if qml_import_path:
         environment["QML2_IMPORT_PATH"] = qml_import_path
 
     return environment
 
 diff --git a/SETUP_GUIDE.md b/SETUP_GUIDE.md
index d62e3dd671b3f05c30f4bbb97d73794fe9e3da83..fb38b105b6a8ab8c5e5f7644f2d220818f43fbd1 100644
--- a/SETUP_GUIDE.md
+++ b/SETUP_GUIDE.md
@@ -96,50 +96,79 @@ python -c "import scipy; print(f'SciPy {scipy.__version__}')"
 ```
 
 ---
 
 ## Настройка VS Code
 
 ### F5 - Запуск и отладка
 
 После настройки окружения нажмите **F5** в VS Code для запуска приложения с отладчиком.
 
 Доступные конфигурации:
 - **F5: PneumoStabSim (Главный)** - Основной запуск
 - **F5: Verbose** - С подробными логами
 - **F5: Test Mode** - Авто-закрытие через 5 сек
 - **F5: Current File** - Запуск текущего .py файла
 - **F5: Run Tests** - Запуск всех тестов
 
 ### Терминал VS Code
 
 При открытии нового терминала автоматически:
 - ✅ Активируется `venv`
 - ✅ Настраиваются переменные окружения (PYTHONPATH, Qt)
 - ✅ Устанавливается кодировка UTF-8
 - ✅ Показывается справка с полезными командами
 
+---
+
+## Обязательные поля конфигурации
+
+Перед запуском приложение валидирует `config/app_settings.json`. Убедитесь, что в файле присутствуют следующие ключи и что значения заданы в корректных единицах (СИ):
+
+- `current.simulation.physics_dt` — шаг физики в секундах.
+- `current.simulation.render_vsync_hz` — целевая частота отрисовки.
+- `current.simulation.max_steps_per_frame` — максимальное число шагов симуляции за кадр.
+- `current.simulation.max_frame_time` — ограничение длительности кадра симуляции.
+- `current.pneumatic.receiver_volume_limits.min_m3` / `max_m3` — допустимый диапазон объёма ресивера (0 < min < max).
+- `current.pneumatic.receiver_volume` — рабочий объём ресивера, лежит внутри диапазона.
+- `current.pneumatic.volume_mode` — режим расчёта объёма (`MANUAL` или `GEOMETRIC`).
+- `current.pneumatic.master_isolation_open` — состояние главного отсечного клапана.
+- `current.pneumatic.thermo_mode` — режим термодинамики (`ISOTHERMAL`, `ADIABATIC`, ...).
+- `current.geometry` — непустая секция с геометрическими параметрами (например, `wheelbase`, `track`, `lever_length_m`).
+- `current.graphics.materials` — содержит материалы `frame`, `lever`, `tail`, `cylinder`, `piston_body`, `piston_rod`, `joint_tail`, `joint_arm`, `joint_rod`.
+
+При отсутствии любого из перечисленных значений запуск будет прерван с диагностикой до создания окна.
+
+### Миграция единиц (legacy → SI)
+
+Если вы обновляетесь со старой версии настроек, выполните следующие шаги:
+
+1. Сделайте резервную копию `config/app_settings.json`.
+2. Приведите все значения геометрии к метрам, а давления — к Паскалям (см. комментарии в файле).
+3. Убедитесь, что секция `metadata.units_version` установлена в `"si_v2"`.
+4. Запустите приложение (`python app.py --test-mode` или `python app.py`) — при старте выполнится дополнительная проверка и будет выведено предупреждение, если какие-либо поля ещё требуют обновления.
+
 Доступные команды в терминале:
 ```powershell
 run              # Запустить приложение
 run -Verbose     # С подробными логами
 run -Test        # Тестовый режим
 test             # Запустить все тесты
 test -Coverage   # Тесты с покрытием
 fmt              # Форматировать код (black)
 typecheck        # Проверить типы (mypy)
 clean            # Очистить кэш Python
 install          # Установить зависимости
 update-pip       # Обновить pip
 info             # Показать справку
 ```
 
 ### Tasks (Ctrl+Shift+P → Tasks: Run Task)
 
 - **▶️ Запустить PneumoStabSim**
 - **🧪 Запустить все тесты (pytest)**
 - **🔍 Проверка типов (mypy)**
 - **✨ Форматирование кода (black)**
 - **📦 Установить зависимости (pip)**
 - **🔄 Обновить pip и setuptools**
 - **🧹 Очистка кэша Python**
 - **📊 Покрытие тестами (coverage)**
diff --git a/src/app_runner.py b/src/app_runner.py
index adf24c3ffec9af10c0e0298c7f5a72cf8b197d03..5cd01fccd7bbde573653ae727205b407cd91a627 100644
--- a/src/app_runner.py
+++ b/src/app_runner.py
@@ -150,102 +150,189 @@ class ApplicationRunner:
                 )
         except Exception:
             from src.ui.main_window import MainWindow as MW
 
             if self.app_logger:
                 self.app_logger.warning(
                     "MainWindow: refactored import failed, using default import"
                 )
 
         window = MW(use_qml_3d=self.use_qml_3d_schema)
         self.window_instance = window
 
         window.show()
         window.raise_()
         window.activateWindow()
 
         if self.app_logger:
             self.app_logger.info("MainWindow created and shown")
 
     def _validate_settings_file(self) -> None:
         """Строгая валидация конфигурации до создания MainWindow.
 
         Проверяем:
         - Путь к файлу и источник (ENV/CWD/PROJECT)
         - Наличие файла и корректность JSON
+        - Секции current.simulation/pneumatic/geometry и ключи PhysicsWorker
         - Обязательные ключи graphics.materials
         - Права на запись в каталог config (создание temp-файла)
         """
         from PySide6.QtWidgets import QMessageBox
         from src.common.settings_manager import get_settings_manager
         import os
 
         sm = get_settings_manager()
         cfg_path = Path(sm.settings_file).absolute()
 
         def _fail(message: str, exc_type: type[Exception] = ValueError) -> None:
             if self.app_logger:
                 self.app_logger.critical(message)
             QMessageBox.critical(None, "Ошибка конфигурации", message)
             raise exc_type(message)
 
         # Определяем источник пути
         src = "CWD"
         if os.environ.get("PSS_SETTINGS_FILE"):
             src = "ENV"
         else:
             # Попробуем угадать project path
             try:
                 project_candidate = (
                     Path(__file__).resolve().parents[1].parent
                     / "config"
                     / "app_settings.json"
                 )
                 if cfg_path.samefile(project_candidate):
                     src = "PROJECT"
             except Exception:
                 pass
 
         msg_base = f"Settings file: {cfg_path} [source={src}]"
         print(msg_base)
         if self.app_logger:
             self.app_logger.info(msg_base)
 
         # 1) Существование
         if not cfg_path.exists():
             _fail(f"Файл настроек не найден: {cfg_path}")
 
         # 2) Чтение и JSON
         try:
             with open(cfg_path, "r", encoding="utf-8") as f:
                 data = json.load(f)
         except Exception as ex:
             _fail(f"Некорректный JSON в файле настроек: {cfg_path}\n{ex}")
 
-        # 3) Обязательные ключи материалов
+        if not isinstance(data, dict):
+            _fail("Файл настроек должен содержать JSON-объект на верхнем уровне")
+
+        # 3) Обязательные секции current.*
+        current = data.get("current")
+        if not isinstance(current, dict):
+            _fail("Отсутствует секция current в файле настроек")
+
+        def _require_section(name: str) -> dict:
+            section = current.get(name)
+            if not isinstance(section, dict):
+                _fail(f"Отсутствует секция current.{name}")
+            return section
+
+        simulation = _require_section("simulation")
+        pneumatic = _require_section("pneumatic")
+        geometry = _require_section("geometry")
+
+        if not geometry:
+            _fail("Секция current.geometry не может быть пустой")
+
+        def _require_number(section: dict, key: str, path: str) -> float:
+            value = section.get(key)
+            if isinstance(value, bool) or not isinstance(value, (int, float)):
+                _fail(f"Отсутствует числовой параметр {path}")
+            return float(value)
+
+        def _require_bool(section: dict, key: str, path: str) -> bool:
+            value = section.get(key)
+            if not isinstance(value, bool):
+                _fail(f"Отсутствует булевый параметр {path}")
+            return value
+
+        def _require_str(section: dict, key: str, path: str) -> str:
+            value = section.get(key)
+            if not isinstance(value, str) or not value.strip():
+                _fail(f"Отсутствует строковый параметр {path}")
+            return value.strip()
+
+        # Параметры, которые использует PhysicsWorker
+        for key in (
+            "physics_dt",
+            "render_vsync_hz",
+            "max_steps_per_frame",
+            "max_frame_time",
+        ):
+            _require_number(simulation, key, f"current.simulation.{key}")
+
+        receiver_limits = pneumatic.get("receiver_volume_limits")
+        if not isinstance(receiver_limits, dict):
+            _fail("Отсутствует секция current.pneumatic.receiver_volume_limits")
+
+        min_limit = _require_number(
+            receiver_limits,
+            "min_m3",
+            "current.pneumatic.receiver_volume_limits.min_m3",
+        )
+        max_limit = _require_number(
+            receiver_limits,
+            "max_m3",
+            "current.pneumatic.receiver_volume_limits.max_m3",
+        )
+        if not (0 < min_limit < max_limit):
+            _fail(
+                "Пределы current.pneumatic.receiver_volume_limits должны удовлетворять "
+                "0 < min < max"
+            )
+
+        receiver_volume = _require_number(
+            pneumatic,
+            "receiver_volume",
+            "current.pneumatic.receiver_volume",
+        )
+        if not (min_limit <= receiver_volume <= max_limit):
+            _fail(
+                "Параметр current.pneumatic.receiver_volume выходит за пределы допустимого "
+                "диапазона"
+            )
+
+        _require_str(pneumatic, "volume_mode", "current.pneumatic.volume_mode")
+        _require_bool(
+            pneumatic,
+            "master_isolation_open",
+            "current.pneumatic.master_isolation_open",
+        )
+        _require_str(pneumatic, "thermo_mode", "current.pneumatic.thermo_mode")
+
+        # 4) Обязательные ключи материалов
         try:
-            current = data.get("current", {}) if isinstance(data, dict) else {}
             graphics = current.get("graphics", {}) if isinstance(current, dict) else {}
             materials = (
                 graphics.get("materials", {}) if isinstance(graphics, dict) else {}
             )
             required_keys = {
                 "frame",
                 "lever",
                 "tail",
                 "cylinder",
                 "piston_body",
                 "piston_rod",
                 "joint_tail",
                 "joint_arm",
                 "joint_rod",
             }
             present = set(materials.keys()) if isinstance(materials, dict) else set()
             missing = sorted(list(required_keys - present))
             if missing:
                 _fail(
                     "Отсутствуют обязательные материалы в current.graphics.materials: "
                     + ", ".join(missing)
                 )
         except Exception:
             raise
 
diff --git a/tests/config/__init__.py b/tests/config/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..939a5c69acdba3b3ddaa6f671ebf4276ebe5476b
--- /dev/null
+++ b/tests/config/__init__.py
@@ -0,0 +1 @@
+"""Configuration-level tests."""
diff --git a/tests/config/test_settings_validation.py b/tests/config/test_settings_validation.py
new file mode 100644
index 0000000000000000000000000000000000000000..6b3b7a6e42dd5b1e14b7383910be70df8edb92eb
--- /dev/null
+++ b/tests/config/test_settings_validation.py
@@ -0,0 +1,143 @@
+import copy
+import json
+import sys
+import types
+from pathlib import Path
+
+import pytest
+
+from src.app_runner import ApplicationRunner
+from src.common import settings_manager as settings_manager_module
+
+
+REQUIRED_MATERIALS = {
+    "frame",
+    "lever",
+    "tail",
+    "cylinder",
+    "piston_body",
+    "piston_rod",
+    "joint_tail",
+    "joint_arm",
+    "joint_rod",
+}
+
+
+def _base_settings() -> dict:
+    current = {
+        "simulation": {
+            "physics_dt": 0.001,
+            "render_vsync_hz": 60,
+            "max_steps_per_frame": 8,
+            "max_frame_time": 0.25,
+        },
+        "pneumatic": {
+            "receiver_volume_limits": {"min_m3": 0.01, "max_m3": 0.05},
+            "receiver_volume": 0.02,
+            "volume_mode": "MANUAL",
+            "master_isolation_open": True,
+            "thermo_mode": "ADIABATIC",
+        },
+        "geometry": {
+            "wheelbase": 2.0,
+            "track": 1.0,
+        },
+        "graphics": {
+            "materials": {name: {"id": name} for name in REQUIRED_MATERIALS}
+        },
+    }
+    return {
+        "current": current,
+        "defaults_snapshot": copy.deepcopy(current),
+        "metadata": {"units_version": "si_v2"},
+    }
+
+
+@pytest.fixture(autouse=True)
+def stub_qmessagebox(monkeypatch):
+    class DummyMessageBox:
+        calls = []
+
+        @classmethod
+        def critical(cls, parent, title, text):
+            cls.calls.append((parent, title, text))
+
+    qtwidgets = types.ModuleType("PySide6.QtWidgets")
+    qtwidgets.QMessageBox = DummyMessageBox
+    pyside = types.ModuleType("PySide6")
+    setattr(pyside, "QtWidgets", qtwidgets)
+
+    monkeypatch.setitem(sys.modules, "PySide6", pyside)
+    monkeypatch.setitem(sys.modules, "PySide6.QtWidgets", qtwidgets)
+
+    DummyMessageBox.calls = []
+    return DummyMessageBox
+
+
+@pytest.fixture
+def runner() -> ApplicationRunner:
+    return ApplicationRunner(
+        object,
+        lambda *args, **kwargs: None,
+        object,
+        object,
+    )
+
+
+@pytest.fixture
+def write_config(tmp_path: Path, monkeypatch):
+    def _write(data: dict) -> Path:
+        path = tmp_path / "settings.json"
+        path.write_text(
+            json.dumps(data, ensure_ascii=False, indent=2),
+            encoding="utf-8",
+        )
+        monkeypatch.setenv("PSS_SETTINGS_FILE", str(path))
+        monkeypatch.setattr(settings_manager_module, "_settings_manager", None)
+        return path
+
+    return _write
+
+
+def _last_error(stub_qmessagebox) -> str:
+    assert stub_qmessagebox.calls, "QMessageBox.critical was not called"
+    return stub_qmessagebox.calls[-1][2]
+
+
+def test_missing_geometry_section(runner, write_config, stub_qmessagebox):
+    settings = _base_settings()
+    settings["current"].pop("geometry")
+    write_config(settings)
+
+    with pytest.raises(ValueError) as exc:
+        runner._validate_settings_file()
+
+    assert "current.geometry" in str(exc.value)
+    assert "current.geometry" in _last_error(stub_qmessagebox)
+    assert runner.window_instance is None
+
+
+def test_missing_simulation_key(runner, write_config, stub_qmessagebox):
+    settings = _base_settings()
+    settings["current"]["simulation"].pop("physics_dt")
+    write_config(settings)
+
+    with pytest.raises(ValueError) as exc:
+        runner._validate_settings_file()
+
+    assert "current.simulation.physics_dt" in str(exc.value)
+    assert "physics_dt" in _last_error(stub_qmessagebox)
+    assert runner.window_instance is None
+
+
+def test_invalid_receiver_limits(runner, write_config, stub_qmessagebox):
+    settings = _base_settings()
+    settings["current"]["pneumatic"]["receiver_volume_limits"]["min_m3"] = 0.0
+    write_config(settings)
+
+    with pytest.raises(ValueError) as exc:
+        runner._validate_settings_file()
+
+    assert "receiver_volume_limits" in str(exc.value)
+    assert "receiver_volume_limits" in _last_error(stub_qmessagebox)
+    assert runner.window_instance is None
diff --git a/tests/unit/__init__.py b/tests/unit/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..ea3f8b923c2804f646990530711c8d6fe09d129b
--- /dev/null
+++ b/tests/unit/__init__.py
@@ -0,0 +1 @@
+"""Unit tests package."""
diff --git a/pyproject.toml b/pyproject.toml
index 1967eee98a79c9fef7a96688aa4d4d5e7f26aa5a..60121e9a016a2c45ee34c0844a55c25817236409 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -6,57 +6,58 @@ build-backend = "setuptools.build_meta"
 name = "pneumostabsim"
 version = "1.0.0"
 description = "Pneumatic Stabilizer Simulator - Professional 3D visualization and simulation system"
 authors = [
     {name = "PneumoStabSim Team", email = "dev@pneumostabsim.com"}
 ]
 readme = "README.md"
 license = {text = "MIT"}
 requires-python = ">=3.10,<3.13"
 keywords = ["pneumatic", "stabilizer", "simulation", "3d", "qt", "pyside6"]
 classifiers = [
     "Development Status :: 4 - Beta",
     "Intended Audience :: Science/Research",
     "License :: OSI Approved :: MIT License",
     "Programming Language :: Python :: 3",
     "Programming Language :: Python :: 3.10",
     "Programming Language :: Python :: 3.11",
     "Programming Language :: Python :: 3.12",
     "Topic :: Scientific/Engineering :: Visualization",
 ]
 
 dependencies = [
     "numpy>=1.24.0,<3.0",
     "scipy>=1.10.0,<2.0",
     "PySide6>=6.10.0,<7.0.0",
-    "shiboken6",
+    "shiboken6>=6.10.0,<7.0.0",
     "PyOpenGL>=3.1.0",
     "PyOpenGL-accelerate>=3.1.0",
     "matplotlib>=3.5.0",
     "Pillow>=8.0.0",
     "psutil>=5.8.0",
     "python-dotenv>=1.0.0",
+    "PyYAML>=6.0",
 ]
 
 [project.optional-dependencies]
 dev = [
     "pytest>=7.0",
     "pytest-qt>=4.0",
     "black>=23.0",
     "flake8>=6.0",
     "mypy>=1.6.0",
     "pre-commit>=2.15",
 ]
 docs = [
     "sphinx>=4.0",
     "sphinx-rtd-theme>=1.0",
 ]
 performance = [
     "numba>=0.56.0",
     "cython>=0.29.0",
 ]
 
 [project.urls]
 "Homepage" = "https://github.com/barmaleii77-hub/PneumoStabSim-Professional"
 "Bug Reports" = "https://github.com/barmaleii77-hub/PneumoStabSim-Professional/issues"
 "Source" = "https://github.com/barmaleii77-hub/PneumoStabSim-Professional"
 "Documentation" = "https://pneumostabsim-professional.readthedocs.io/"
diff --git a/requirements.txt b/requirements.txt
index daf42989e5c65e5f7a44fea9bb45516261d118f9..64ed5164a760df4ae3fdf2c50da3483ea2cdefee 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,32 +1,32 @@
 # PneumoStabSim Professional - Production Dependencies
 # Проверено для Python 3.10-3.12 (рекомендуется 3.12)
 
 # === КРИТИЧЕСКИЕ ЗАВИСИМОСТИ ===
 # Qt Framework - основа GUI и 3D рендеринга
 PySide6>=6.10.0,<7.0.0   # Qt6.10+ (ExtendedSceneEnvironment, Fog, dithering)
-shiboken6                 # Qt6 bindings generator
+shiboken6>=6.10.0,<7.0.0 # Qt6 bindings generator
 
 # Numerical computing - основа физических расчетов
 numpy>=1.24.0,<3.0.0      # Векторные вычисления
 scipy>=1.10.0,<2.0.0      # Научные вычисления и ODE solver
 
 # === ДОПОЛНИТЕЛЬНЫЕ ПАКЕТЫ ===
 # Visualization и анализ данных
 matplotlib>=3.5.0         # Графики и чарты
 pillow>=9.0.0             # Обработка изображений для HDR текстур
 
 # Testing и development
 pytest>=7.0.0             # Тестирование
 PyYAML>=6.0               # Конфигурационные файлы
 python-dotenv>=1.0.0      # Переменные окружения из .env
 psutil>=5.8.0             # Мониторинг
 
 # === ОПЦИОНАЛЬНЫЕ УЛУЧШЕНИЯ ===
 # trimesh>=3.15.0         # 3D mesh обработка (опционально)
 # pyqtgraph>=0.12.0       # Быстрые графики (опционально)
 # numba>=0.56.0           # JIT компиляция (опционально)
 # cython>=0.29.0          # C расширения (опционально)
 
 # === СОВМЕСТИМОСТЬ ===
 # Проверено на:
 # - Windows 10/11 (Python 3.10-3.12)
diff --git a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py
index 5c5cd8a5cbf74de1fb9c45e10b05d2d192f36355..1eba9c38d57dca3e80ab7be7a3f7486e67b55023 100644
--- a/src/runtime/sim_loop.py
+++ b/src/runtime/sim_loop.py
@@ -1,113 +1,196 @@
-"""
-Physics simulation loop with fixed timestep
-Runs in dedicated QThread with QTimer for precise timing
+"""Physics simulation loop with fixed timestep.
+
+Runs in dedicated :class:`QThread` with :class:`QTimer` for precise timing.
+The module performs dynamic imports for the domain packages to ensure we
+surface clear diagnostics when optional components are missing.
 """
 
-import time
+from __future__ import annotations
+
+import importlib
 import logging
-from typing import Optional, Dict, Any
-import numpy as np
+import math
+import time
+from typing import Any, Dict, Iterable, Optional, Tuple
 
-from PySide6.QtCore import QObject, QTimer, Signal, Slot, Qt
-from PySide6.QtCore import QThread
+import numpy as np
+from PySide6.QtCore import QObject, QThread, QTimer, Qt, Signal, Slot
 
 from .state import (
-    StateSnapshot,
-    StateBus,
     FrameState,
-    WheelState,
     LineState,
-    TankState,
+    StateBus,
+    StateSnapshot,
     SystemAggregates,
+    TankState,
+    WheelState,
 )
 from .sync import (
     LatestOnlyQueue,
     PerformanceMetrics,
-    TimingAccumulator,
     ThreadSafeCounter,
+    TimingAccumulator,
 )
+from src.common.settings_manager import get_settings_manager
+from src.common.units import PA_ATM, T_AMBIENT
+
+
+def _require(module_name: str, attributes: Iterable[str]) -> Tuple[Any, ...]:
+    """Import *module_name* and return the requested attributes.
+
+    Raises a descriptive :class:`ImportError` when the domain packages are not
+    installed instead of silently falling back to incomplete stubs.
+    """
+
+    try:
+        module = importlib.import_module(module_name)
+    except ImportError as exc:  # pragma: no cover - exercised via tests
+        package_hint = module_name.split(".", 2)[1] if "." in module_name else module_name
+        raise ImportError(
+            "Required PneumoStabSim component '"
+            f"{package_hint}' is missing. Ensure the '{module_name}' module "
+            "is installed and importable."
+        ) from exc
+
+    missing = [name for name in attributes if not hasattr(module, name)]
+    if missing:  # pragma: no cover - defensive guard
+        raise ImportError(
+            f"Module '{module_name}' is missing required attributes: {', '.join(missing)}"
+        )
 
-# Измененные импорты на абсолютные пути
-from src.physics.odes import RigidBody3DOF, create_initial_conditions
-from src.physics.integrator import (
-    step_dynamics,
-    create_default_rigid_body,
+    return tuple(getattr(module, name) for name in attributes)
+
+
+(RigidBody3DOF, create_initial_conditions) = _require(
+    "src.physics.odes", ("RigidBody3DOF", "create_initial_conditions")
+)
+(step_dynamics, create_default_rigid_body) = _require(
+    "src.physics.integrator", ("step_dynamics", "create_default_rigid_body")
 )
-from src.pneumo.enums import (
+(
     Wheel,
     Line,
     ThermoMode,
+    ReceiverVolumeMode,
+    CheckValveKind,
+) = _require(
+    "src.pneumo.enums",
+    ("Wheel", "Line", "ThermoMode", "ReceiverVolumeMode", "CheckValveKind"),
 )
-from src.pneumo.receiver import ReceiverState
-from src.pneumo.system import create_standard_diagonal_system
-from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
-from src.pneumo.network import GasNetwork
-from src.road.engine import RoadInput
-from src.road.scenarios import get_preset_by_name
-
-# Settings manager (используем абсолютный импорт, т.к. общий модуль)
-from src.common.settings_manager import get_settings_manager
+(ReceiverState, ReceiverSpec) = _require(
+    "src.pneumo.receiver", ("ReceiverState", "ReceiverSpec")
+)
+(FrameGeom, LeverGeom, CylinderGeom) = _require(
+    "src.pneumo.geometry", ("FrameGeom", "LeverGeom", "CylinderGeom")
+)
+(CylinderSpec,) = _require("src.pneumo.cylinder", ("CylinderSpec",))
+(create_standard_diagonal_system,) = _require(
+    "src.pneumo.system", ("create_standard_diagonal_system",)
+)
+(
+    create_line_gas_state,
+    create_tank_gas_state,
+    apply_instant_volume_change,
+) = _require(
+    "src.pneumo.gas_state",
+    ("create_line_gas_state", "create_tank_gas_state", "apply_instant_volume_change"),
+)
+(GasNetwork,) = _require("src.pneumo.network", ("GasNetwork",))
+(CheckValve,) = _require("src.pneumo.valves", ("CheckValve",))
+(RoadInput,) = _require("src.road.engine", ("RoadInput",))
+(
+    RoadConfig,
+    SourceKind,
+    CorrelationSpec,
+) = _require("src.road.types", ("RoadConfig", "SourceKind", "CorrelationSpec"))
+(get_preset_by_name,) = _require("src.road.scenarios", ("get_preset_by_name",))
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
         self.max_frame_time: float = 0.05
 
         # Simulation state
         self.is_running = False
         self.is_configured = False
         self.simulation_time = 0.0
         self.step_counter = 0
 
         # Physics objects (will be initialized in configure)
         self.rigid_body: Optional[RigidBody3DOF] = None
         self.road_input: Optional[Any] = None  # Changed type hint
         self.pneumatic_system: Optional[Any] = None
         self.gas_network: Optional[Any] = None
 
+        # Cached geometry and kinematic helpers
+        self._frame_geom: Optional[Any] = None
+        self._lever_geom: Optional[Any] = None
+        self._cylinder_geom: Optional[Any] = None
+        self._half_track: float = 0.0
+        self._half_wheelbase: float = 0.0
+
+        # Per-wheel dynamic quantities
+        self._lever_angles: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+        self._piston_positions: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+        self._piston_velocities: Dict[Wheel, float] = {
+            wheel: 0.0 for wheel in Wheel
+        }
+        self._last_road_inputs: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+
+        # Frame dynamics caches for acceleration calculations
+        self._previous_frame_rates: Optional[np.ndarray] = None
+
+        # Road excitation parameters from configuration
+        self._road_amplitude: float = 0.0
+        self._road_frequency: float = 0.0
+        self._road_base_phase: float = 0.0
+        self._road_phase_offsets: Dict[Wheel, float] = {wheel: 0.0 for wheel in Wheel}
+        self._road_duration: float = 10.0
+        self._road_velocity: float = 10.0
+
         # Current physics state
         self.physics_state: np.ndarray = np.zeros(6)  # [Y, φz, θx, dY, dφz, dθx]
 
         # Simulation modes (overridden by persisted settings)
         self.thermo_mode = ThermoMode.ISOTHERMAL
         self.master_isolation_open = False
 
         # Receiver parameters and limits (loaded from settings)
         self.receiver_volume: float = 0.0
         self.receiver_volume_mode: str = ""
         self._volume_limits: tuple[float, float] = (0.0, 0.0)
 
         # Threading objects (created in target thread)
         self.physics_timer: Optional[QTimer] = None
 
         # Performance monitoring
         self.performance = PerformanceMetrics()
         self.timing_accumulator: Optional[TimingAccumulator] = None
         self.step_time_samples = []
 
         # Thread safety
         self.error_counter = ThreadSafeCounter()
 
         # Load persisted configuration
         self._load_initial_settings()
@@ -245,101 +328,259 @@ class PhysicsWorker(QObject):
         if isinstance(vsync_render_hz, (int, float)) and not isinstance(
             vsync_render_hz, bool
         ):
             self.vsync_render_hz = float(vsync_render_hz)
         if isinstance(max_steps_per_frame, (int, float)) and not isinstance(
             max_steps_per_frame, bool
         ):
             self.max_steps_per_frame = max(1, int(round(max_steps_per_frame)))
         if isinstance(max_frame_time, (int, float)) and not isinstance(
             max_frame_time, bool
         ):
             self.max_frame_time = float(max_frame_time)
 
         # Update timing accumulator
         self._apply_timing_configuration()
 
         # Create default physics objects
         self._initialize_physics_objects()
 
         self.is_configured = True
         self.logger.info(
             f"Physics configured: dt={self.dt_physics*1000:.3f}ms, render={self.vsync_render_hz:.1f}Hz"
         )
 
     def _initialize_physics_objects(self):
-        """Initialize physics simulation objects"""
+        """Initialize physics simulation objects using configuration data."""
+
+        def _require_float(payload: Dict[str, Any], key: str) -> float:
+            value = payload.get(key)
+            if isinstance(value, (int, float)) and not isinstance(value, bool):
+                return float(value)
+            raise RuntimeError(f"Missing numeric setting: {key}")
+
+        def _require_bool(payload: Dict[str, Any], key: str) -> bool:
+            value = payload.get(key)
+            if isinstance(value, bool):
+                return value
+            if isinstance(value, (int, float)) and not isinstance(value, bool):
+                return bool(value)
+            raise RuntimeError(f"Missing boolean setting: {key}")
+
         try:
-            # Create 3-DOF rigid body
             self.rigid_body = create_default_rigid_body()
-
-            # Initialize physics state (at rest)
             self.physics_state = create_initial_conditions()
 
-            # TODO: Initialize pneumatic system and gas network
-            # For now, create minimal stubs
-            self.pneumatic_system = None  # Will be set up later
-            self.gas_network = None
+            geometry_cfg = self.settings_manager.get_category("geometry") or {}
+            pneumatic_cfg = self.settings_manager.get_category("pneumatic") or {}
+            modes_cfg = self.settings_manager.get_category("modes") or {}
+
+            if not geometry_cfg:
+                raise RuntimeError("Geometry configuration is empty")
+            if not pneumatic_cfg:
+                raise RuntimeError("Pneumatic configuration is empty")
+
+            wheelbase = _require_float(geometry_cfg, "wheelbase")
+            track = _require_float(geometry_cfg, "track")
+            lever_length = _require_float(geometry_cfg, "lever_length")
+            rod_position = _require_float(geometry_cfg, "rod_position")
+            frame_to_pivot = _require_float(geometry_cfg, "frame_to_pivot")
+            cyl_diameter = _require_float(geometry_cfg, "cyl_diam_m")
+            stroke = _require_float(geometry_cfg, "stroke_m")
+            dead_gap = _require_float(geometry_cfg, "dead_gap_m")
+            rod_diameter = _require_float(geometry_cfg, "rod_diameter_m")
+            piston_thickness = _require_float(geometry_cfg, "piston_thickness_m")
+
+            frame_height = float(geometry_cfg.get("frame_height_m", 0.0) or 0.0)
+            tail_offset = float(geometry_cfg.get("tail_mount_offset_m", 0.0) or 0.0)
+            link_rods = bool(geometry_cfg.get("link_rod_diameters", False))
+
+            rod_fraction = max(0.1, min(0.9, float(rod_position)))
+            wall_thickness = max(cyl_diameter * 0.05, 0.005)
+            outer_diameter = cyl_diameter + 2.0 * wall_thickness
+            inner_length = stroke + 2.0 * dead_gap + piston_thickness
+
+            self._frame_geom = FrameGeom(L_wb=wheelbase)
+            self._lever_geom = LeverGeom(
+                L_lever=lever_length,
+                rod_joint_frac=rod_fraction,
+                d_frame_to_lever_hinge=frame_to_pivot,
+            )
+            self._cylinder_geom = CylinderGeom(
+                D_in_front=cyl_diameter,
+                D_in_rear=cyl_diameter,
+                D_out_front=outer_diameter,
+                D_out_rear=outer_diameter,
+                L_inner=inner_length,
+                t_piston=piston_thickness,
+                D_rod=rod_diameter,
+                link_rod_diameters_front_rear=link_rods,
+                L_dead_head=dead_gap,
+                L_dead_rod=dead_gap,
+                Y_tail=tail_offset if tail_offset else track / 2.0,
+                Z_axle=frame_height,
+            )
 
-            # TODO: Initialize road input
-            # For now, create minimal stub
-            self.road_input = None
+            self._half_track = track / 2.0
+            self._half_wheelbase = wheelbase / 2.0
+
+            cylinder_specs = {
+                Wheel.LP: CylinderSpec(self._cylinder_geom, True, self._lever_geom),
+                Wheel.PP: CylinderSpec(self._cylinder_geom, True, self._lever_geom),
+                Wheel.LZ: CylinderSpec(self._cylinder_geom, False, self._lever_geom),
+                Wheel.PZ: CylinderSpec(self._cylinder_geom, False, self._lever_geom),
+            }
+
+            volume_limits = pneumatic_cfg.get("receiver_volume_limits", {})
+            if not isinstance(volume_limits, dict) or not volume_limits:
+                raise RuntimeError("receiver_volume_limits missing in pneumatic settings")
+            receiver_spec = ReceiverSpec(
+                V_min=_require_float(volume_limits, "min_m3"),
+                V_max=_require_float(volume_limits, "max_m3"),
+            )
 
-            # NEW: Initialize road input with default scenario
-            road_scenario = "default_scenario"  # Заменить на нужный пресет
-            road_config = get_preset_by_name(road_scenario)
-            if road_config:
-                self.road_input = RoadInput(config=road_config)
-                self.logger.info(
-                    f"Road input initialized with scenario: {road_scenario}"
-                )
+            receiver_volume = _require_float(pneumatic_cfg, "receiver_volume")
+            atmo_temp_c = float(pneumatic_cfg.get("atmo_temp", 20.0) or 20.0)
+            atmo_temp_k = atmo_temp_c + 273.15
+            volume_mode = str(pneumatic_cfg.get("volume_mode", "MANUAL")).upper()
+            if volume_mode == "MANUAL":
+                receiver_mode = ReceiverVolumeMode.NO_RECALC
+            elif volume_mode == "GEOMETRIC":
+                receiver_mode = ReceiverVolumeMode.ADIABATIC_RECALC
             else:
-                self.logger.warning(f"Road scenario not found: {road_scenario}")
-                self.road_input = None  # Использовать заглушку
+                raise RuntimeError(f"Unsupported receiver volume mode: {volume_mode}")
+
+            receiver_state = ReceiverState(
+                spec=receiver_spec,
+                V=receiver_volume,
+                p=float(pneumatic_cfg.get("receiver_pressure", PA_ATM) or PA_ATM),
+                T=atmo_temp_k,
+                mode=receiver_mode,
+            )
 
-            # NEW: Initialize pneumatic system with standard configuration
-            try:
-                self.pneumatic_system = create_standard_diagonal_system()
-                self.logger.info(
-                    "Pneumatic system initialized with standard configuration"
+            cv_atmo_dp = _require_float(pneumatic_cfg, "cv_atmo_dp")
+            cv_tank_dp = _require_float(pneumatic_cfg, "cv_tank_dp")
+            cv_atmo_dia = _require_float(pneumatic_cfg, "cv_atmo_dia") / 1000.0
+            cv_tank_dia = _require_float(pneumatic_cfg, "cv_tank_dia") / 1000.0
+
+            line_config = {
+                line: {
+                    "cv_atmo": CheckValve(
+                        kind=CheckValveKind.ATMO_TO_LINE,
+                        delta_open_min=cv_atmo_dp,
+                        d_eq=cv_atmo_dia,
+                    ),
+                    "cv_tank": CheckValve(
+                        kind=CheckValveKind.LINE_TO_TANK,
+                        delta_open_min=cv_tank_dp,
+                        d_eq=cv_tank_dia,
+                    ),
+                    "p_line": float(pneumatic_cfg.get("initial_line_pressure", PA_ATM)),
+                }
+                for line in (Line.A1, Line.B1, Line.A2, Line.B2)
+            }
+
+            master_isolation = _require_bool(pneumatic_cfg, "master_isolation_open")
+            self.master_isolation_open = master_isolation
+
+            self.pneumatic_system = create_standard_diagonal_system(
+                cylinder_specs=cylinder_specs,
+                line_configs=line_config,
+                receiver=receiver_state,
+                master_isolation_open=master_isolation,
+            )
+
+            line_states = {}
+            for line, volumes in self.pneumatic_system.get_line_volumes().items():
+                line_states[line] = create_line_gas_state(
+                    name=line,
+                    p_initial=line_config[line]["p_line"],
+                    T_initial=atmo_temp_k,
+                    V_initial=volumes["total_volume"],
                 )
-            except Exception as e:
-                self.logger.warning(f"Failed to create standard pneumatic system: {e}")
-                self.pneumatic_system = None  # Использовать заглушку
 
-            # NEW: Initialize gas network with default parameters
-            try:
-                self.gas_network = GasNetwork()
-                self.logger.info("Gas network initialized with default parameters")
-            except Exception as e:
-                self.logger.warning(f"Failed to create gas network: {e}")
-                self.gas_network = None  # Использовать заглушку
+            tank_state = create_tank_gas_state(
+                V_initial=receiver_volume,
+                p_initial=float(pneumatic_cfg.get("receiver_pressure", PA_ATM) or PA_ATM),
+                T_initial=atmo_temp_k,
+                mode=receiver_mode,
+            )
+
+            self.gas_network = GasNetwork(
+                lines=line_states,
+                tank=tank_state,
+                system_ref=self.pneumatic_system,
+                master_isolation_open=master_isolation,
+            )
+
+            self._road_amplitude = float(modes_cfg.get("amplitude", 0.0) or 0.0)
+            self._road_frequency = float(modes_cfg.get("frequency", 0.0) or 0.0)
+            self._road_base_phase = math.radians(float(modes_cfg.get("phase", 0.0) or 0.0))
+            self._road_duration = float(modes_cfg.get("duration", 20.0) or 20.0)
+            self._road_velocity = float(modes_cfg.get("velocity", 15.0) or 15.0)
+
+            for wheel_key, setting_key in [
+                (Wheel.LP, "lf_phase"),
+                (Wheel.PP, "rf_phase"),
+                (Wheel.LZ, "lr_phase"),
+                (Wheel.PZ, "rr_phase"),
+            ]:
+                self._road_phase_offsets[wheel_key] = math.radians(
+                    float(modes_cfg.get(setting_key, 0.0) or 0.0)
+                )
+
+            preset_name = str(modes_cfg.get("mode_preset", ""))
+            preset = get_preset_by_name(preset_name) if preset_name else None
+            if preset:
+                road_config = RoadConfig(
+                    source=preset.source_kind,
+                    preset=preset,
+                    wheelbase=wheelbase,
+                    track=track,
+                )
+            else:
+                road_config = RoadConfig(
+                    source=SourceKind.SINE,
+                    preset=None,
+                    velocity=self._road_velocity,
+                    duration=self._road_duration,
+                    amplitude=self._road_amplitude,
+                    frequency=max(self._road_frequency, 0.01),
+                    phase=self._road_base_phase,
+                    wheelbase=wheelbase,
+                    track=track,
+                    correlation=CorrelationSpec(rho_LR=0.8),
+                )
+
+            self.road_input = RoadInput()
+            self.road_input.configure(road_config, system=self.pneumatic_system)
+            self.road_input.prime(duration=self._road_duration)
 
             self.logger.info("Physics objects initialized successfully")
 
-        except Exception as e:
-            self.logger.error(f"Failed to initialize physics objects: {e}")
+        except Exception as exc:
+            self.logger.error(f"Failed to initialize physics objects: {exc}")
             raise
 
     @Slot()
     def start_simulation(self):
         """Start physics simulation (called from UI thread)"""
         if not self.is_configured:
             self.error_occurred.emit("Physics worker not configured")
             return
 
         if self.is_running:
             self.logger.warning("Simulation already running")
             return
 
         # Create timer in this thread (will be moved to physics thread)
         if self.physics_timer is None:
             self.physics_timer = QTimer()
             self.physics_timer.timeout.connect(self._physics_step)
             self.physics_timer.setSingleShot(False)
 
         # Start timer with high precision
         timer_interval_ms = max(1, int(self.dt_physics * 1000))  # At least 1ms
         self.physics_timer.start(timer_interval_ms)
 
         self.is_running = True
         self.timing_accumulator.reset()
@@ -456,55 +697,61 @@ class PhysicsWorker(QObject):
 
         self.logger.info(f"Thermo mode set to: {mode}")
 
     @Slot(bool)
     def set_master_isolation(self, open: bool):
         """Set master isolation valve state"""
         self.master_isolation_open = open
         self.logger.info(f"Master isolation: {'OPEN' if open else 'CLOSED'}")
 
     @Slot(float, str)
     def set_receiver_volume(self, volume: float, mode: str):
         """Set receiver volume and recalculation mode
 
         Args:
             volume: New receiver volume in m?
             mode: Recalculation mode ('NO_RECALC' or 'ADIABATIC_RECALC')
         """
         if volume <= 0 or volume > 1.0:  # Reasonable limits (0-1000L)
             self.error_occurred.emit(f"Invalid receiver volume: {volume} m?")
             return
 
         # Store volume and mode for gas network updates
         self.receiver_volume = volume
         self.receiver_volume_mode = mode
 
-        # TODO: Update actual ReceiverState when gas network is integrated
-        # For now, just log the change
-        self.logger.info(f"Receiver volume set: {volume:.3f}m? (mode: {mode})")
+        if self.gas_network:
+            try:
+                apply_instant_volume_change(self.gas_network.tank, volume)
+                if mode:
+                    normalized = mode.upper()
+                    if normalized in ReceiverVolumeMode.__members__:
+                        self.gas_network.tank.mode = ReceiverVolumeMode[normalized]
+            except Exception as exc:
+                self.logger.warning(f"Failed to update receiver volume: {exc}")
 
-        print(f"?? PhysicsWorker: Receiver volume={volume*1000:.1f}L, mode={mode}")
+        self.logger.info(f"Receiver volume set: {volume:.3f}m³ (mode: {mode})")
 
     @Slot(float)
     def set_physics_dt(self, dt: float):
         """Change physics timestep"""
         if dt <= 0 or dt > 0.1:  # Reasonable limits
             self.error_occurred.emit(f"Invalid physics dt: {dt}")
             return
 
         old_dt = self.dt_physics
         self.dt_physics = dt
         self.timing_accumulator = TimingAccumulator(dt)
         self.performance.target_dt = dt
 
         # Restart timer if running
         if self.is_running and self.physics_timer:
             self.physics_timer.stop()
             timer_interval_ms = max(1, int(dt * 1000))
             self.physics_timer.start(timer_interval_ms)
 
         self.logger.info(f"Physics dt changed: {old_dt*1000:.3f}ms ? {dt*1000:.3f}ms")
 
     @Slot()
     def _physics_step(self):
         """Single physics simulation step (called by QTimer)"""
         if not self.is_running:
@@ -522,205 +769,298 @@ class PhysicsWorker(QObject):
             # Update performance metrics
             step_end_time = time.perf_counter()
             step_time = step_end_time - step_start_time
             self.performance.update_step_time(step_time)
 
             # Emit performance update periodically
             if self.step_counter % 100 == 0:  # Every 100 steps
                 self.performance_update.emit(self.performance.get_summary())
 
             # Create and emit state snapshot
             snapshot = self._create_state_snapshot()
             if snapshot and snapshot.validate():
                 self.state_ready.emit(snapshot)
             else:
                 self.error_counter.increment()
                 if self.error_counter.get() > 10:  # Too many invalid states
                     self.error_occurred.emit("Too many invalid state snapshots")
                     self.stop_simulation()
 
         except Exception as e:
             self.logger.error(f"Physics step failed: {e}")
             self.error_occurred.emit(f"Physics step error: {str(e)}")
             self.stop_simulation()
 
     def _execute_physics_step(self):
-        """Execute single physics timestep"""
-        # 1. Get road inputs
+        """Execute single physics timestep."""
+
         road_inputs = self._get_road_inputs()
+        self._last_road_inputs = dict(road_inputs)
 
-        # 2. Update geometry/kinematics
-        if self.rigid_body:
+        if self.pneumatic_system:
             try:
-                # Update lever angles and piston positions from road inputs
-                if self.pneumatic_system:
-                    for wheel, input_value in road_inputs.items():
-                        if wheel in {Wheel.LP.value, Wheel.PP.value}:  # Левые колеса
-                            cylinder = self.pneumatic_system.left_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-                        elif wheel in {Wheel.LZ.value, Wheel.PZ.value}:  # Правые колеса
-                            cylinder = self.pneumatic_system.right_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-            except Exception as e:
-                self.logger.warning(f"Failed to update kinematics: {e}")
-
-        # 3. Update gas system
+                lever_length = self._lever_geom.L_lever if self._lever_geom else 1.0
+                lever_length = max(float(lever_length), 1e-6)
+                lever_angles: Dict[Wheel, float] = {}
+
+                for wheel, excitation in road_inputs.items():
+                    ratio = max(-1.0, min(1.0, excitation / lever_length))
+                    angle = math.asin(ratio) if lever_length > 0 else 0.0
+                    lever_angles[wheel] = angle
+
+                if lever_angles:
+                    self.pneumatic_system.update_system_from_lever_angles(lever_angles)
+
+                    for wheel, angle in lever_angles.items():
+                        self._lever_angles[wheel] = angle
+                        cylinder = self.pneumatic_system.cylinders.get(wheel)
+                        if cylinder is not None:
+                            previous = self._piston_positions.get(wheel, 0.0)
+                            current = float(cylinder.x)
+                            self._piston_velocities[wheel] = (current - previous) / max(
+                                self.dt_physics, 1e-9
+                            )
+                            self._piston_positions[wheel] = current
+            except Exception as exc:  # pragma: no cover - defensive logging
+                self.logger.warning(f"Failed to update kinematics: {exc}")
+
         if self.gas_network:
             try:
-                # Получаем текущее состояние газа в трубопроводах и резервуарах
-                line_gas_states = create_line_gas_state(self.gas_network)
-                tank_gas_states = create_tank_gas_state(self.gas_network)
-
-                # Обновляем состояния резервуаров в системе
-                for state in tank_gas_states:
-                    if state.receiver_id == "default_receiver":
-                        # Применяем новое состояние газа к резервуару
-                        receiver_state = ReceiverState(
-                            pressure=state.pressure,
-                            temperature=state.temperature,
-                            volume=self.receiver_volume,
-                        )
-                        self.gas_network.update_receiver_state(receiver_state)
+                self.gas_network.master_isolation_open = self.master_isolation_open
+                if self.pneumatic_system:
+                    self.gas_network.update_pressures_due_to_volume(self.thermo_mode)
+                self.gas_network.apply_valves_and_flows(self.dt_physics, log=self.logger)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update gas network: {exc}")
 
-            except Exception as e:
-                self.logger.warning(f"Failed to update gas network: {e}")
+        prev_rates = None
+        if len(self.physics_state) >= 6:
+            prev_rates = self.physics_state[3:6].copy()
 
-        # 4. Integrate 3-DOF dynamics
         if self.rigid_body:
             try:
-                # Use placeholder system/gas for now
                 result = step_dynamics(
                     y0=self.physics_state,
                     t0=self.simulation_time,
                     dt=self.dt_physics,
                     params=self.rigid_body,
                     system=self.pneumatic_system,
                     gas=self.gas_network,
                     method="Radau",
                 )
 
                 if result.success:
+                    if prev_rates is not None:
+                        self._previous_frame_rates = prev_rates
                     self.physics_state = result.y_final
                 else:
                     self.performance.integration_failures += 1
                     self.logger.warning(f"Integration failed: {result.message}")
-
-            except Exception as e:
+            except Exception as exc:
                 self.performance.integration_failures += 1
-                self.logger.error(f"Integration error: {e}")
+                self.logger.error(f"Integration error: {exc}")
 
-        # Update simulation time and step counter
         self.simulation_time += self.dt_physics
         self.step_counter += 1
 
-    def _get_road_inputs(self) -> Dict[str, float]:
-        """Get road excitation for all wheels"""
+    def _get_road_inputs(self) -> Dict[Wheel, float]:
+        """Get road excitation for all wheels in meters."""
+
+        raw_inputs: Dict[str, float] = {}
         if self.road_input:
             try:
-                return self.road_input.get_wheel_excitation(self.simulation_time)
-            except Exception as e:
-                self.logger.warning(f"Road input error: {e}")
+                raw_inputs = self.road_input.get_wheel_excitation(self.simulation_time)
+            except Exception as exc:
+                self.logger.warning(f"Road input error: {exc}")
+
+        wheel_map = {
+            Wheel.LP: ("LF", Wheel.LP.value),
+            Wheel.PP: ("RF", Wheel.PP.value),
+            Wheel.LZ: ("LR", Wheel.LZ.value),
+            Wheel.PZ: ("RR", Wheel.PZ.value),
+        }
+
+        freq = max(self._road_frequency, 0.0)
+        time_now = self.simulation_time
+
+        outputs: Dict[Wheel, float] = {}
+        for wheel, keys in wheel_map.items():
+            candidate = None
+            for key in keys:
+                if key in raw_inputs:
+                    candidate = float(raw_inputs[key])
+                    break
+
+            if freq > 0.0 and (abs(self._road_amplitude) > 0.0 or wheel in self._road_phase_offsets):
+                manual = self._road_amplitude * math.sin(
+                    2.0 * math.pi * freq * time_now
+                    + self._road_base_phase
+                    + self._road_phase_offsets.get(wheel, 0.0)
+                )
+                if candidate is None or abs(self._road_phase_offsets.get(wheel, 0.0)) > 1e-12:
+                    candidate = manual
+                else:
+                    candidate = float(candidate)
+            else:
+                candidate = float(candidate or 0.0)
+
+            outputs[wheel] = candidate
 
-        # Return zero excitation as fallback
-        return {"LP": 0.0, "PP": 0.0, "LZ": 0.0, "PZ": 0.0}
+        return outputs
 
     def _create_state_snapshot(self) -> Optional[StateSnapshot]:
-        """Create current state snapshot"""
+        """Create current state snapshot with resolved physical values."""
+
         try:
             snapshot = StateSnapshot()
-
-            # Basic timing info
             snapshot.simulation_time = self.simulation_time
             snapshot.dt_physics = self.dt_physics
             snapshot.step_number = self.step_counter
 
-            # Frame state from physics integration
             if len(self.physics_state) >= 6:
                 Y, phi_z, theta_x, dY, dphi_z, dtheta_x = self.physics_state
+                heave_accel = roll_accel = pitch_accel = 0.0
+
+                if self._previous_frame_rates is not None:
+                    prev = np.array(self._previous_frame_rates, dtype=float)
+                    accel = (
+                        np.array([dY, dphi_z, dtheta_x], dtype=float) - prev
+                    ) / max(self.dt_physics, 1e-9)
+                    heave_accel, roll_accel, pitch_accel = accel.tolist()
 
                 snapshot.frame = FrameState(
                     heave=float(Y),
                     roll=float(phi_z),
                     pitch=float(theta_x),
                     heave_rate=float(dY),
                     roll_rate=float(dphi_z),
                     pitch_rate=float(dtheta_x),
+                    heave_accel=float(heave_accel),
+                    roll_accel=float(roll_accel),
+                    pitch_accel=float(pitch_accel),
                 )
 
-            # Road excitations
-            road_excitations = self._get_road_inputs()
+                self._previous_frame_rates = np.array(
+                    [dY, dphi_z, dtheta_x], dtype=float
+                )
 
-            # Wheel states
-            for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
+            for wheel in Wheel:
                 wheel_state = WheelState(wheel=wheel)
+                wheel_state.road_excitation = float(
+                    self._last_road_inputs.get(wheel, 0.0)
+                )
+                wheel_state.lever_angle = float(self._lever_angles.get(wheel, 0.0))
+                wheel_state.piston_position = float(
+                    self._piston_positions.get(wheel, 0.0)
+                )
+                wheel_state.piston_velocity = float(
+                    self._piston_velocities.get(wheel, 0.0)
+                )
 
-                # Add road excitation
-                wheel_key = wheel.value  # LP, PP, LZ, PZ
-                if wheel_key in road_excitations:
-                    wheel_state.road_excitation = road_excitations[wheel_key]
-
-                # TODO: Add actual wheel state from pneumatic system
+                if self.pneumatic_system:
+                    cylinder = self.pneumatic_system.cylinders.get(wheel)
+                    if cylinder is not None:
+                        wheel_state.vol_head = float(cylinder.vol_head())
+                        wheel_state.vol_rod = float(cylinder.vol_rod())
+
+                if self._lever_geom and self._cylinder_geom:
+                    rod_x, rod_y = self._lever_geom.rod_joint_pos(wheel_state.lever_angle)
+                    lateral = self._half_track if wheel in (Wheel.LP, Wheel.LZ) else -self._half_track
+                    longitudinal = (
+                        self._half_wheelbase
+                        if wheel in (Wheel.LP, Wheel.PP)
+                        else -self._half_wheelbase
+                    )
+                    base_height = float(getattr(self._cylinder_geom, "Z_axle", 0.0))
+                    wheel_state.joint_x = float(longitudinal)
+                    wheel_state.joint_y = float(lateral + rod_x)
+                    wheel_state.joint_z = float(base_height + rod_y)
 
                 snapshot.wheels[wheel] = wheel_state
 
-            # Line states (placeholder)
-            for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
-                line_state = LineState(line=line)
-                # TODO: Get actual line state from gas network
-                snapshot.lines[line] = line_state
+            if self.gas_network and self.pneumatic_system:
+                for line, gas_state in self.gas_network.lines.items():
+                    line_snapshot = LineState(
+                        line=line,
+                        pressure=float(gas_state.p),
+                        temperature=float(gas_state.T),
+                        mass=float(gas_state.m),
+                        volume=float(gas_state.V_curr),
+                    )
 
-            # Tank state (placeholder)
-            snapshot.tank = TankState()
+                    pneumo_line = self.pneumatic_system.lines.get(line)
+                    if pneumo_line:
+                        try:
+                            line_snapshot.cv_atmo_open = pneumo_line.cv_atmo.is_open(
+                                PA_ATM, gas_state.p
+                            )
+                        except Exception:
+                            line_snapshot.cv_atmo_open = False
+                        try:
+                            line_snapshot.cv_tank_open = pneumo_line.cv_tank.is_open(
+                                gas_state.p, self.gas_network.tank.p
+                            )
+                        except Exception:
+                            line_snapshot.cv_tank_open = False
+
+                    snapshot.lines[line] = line_snapshot
+
+                tank = self.gas_network.tank
+                snapshot.tank = TankState(
+                    pressure=float(tank.p),
+                    temperature=float(tank.T),
+                    mass=float(tank.m),
+                    volume=float(tank.V),
+                )
+            else:
+                snapshot.tank.volume = self.receiver_volume
 
-            # NEW: Update tank volume from receiver settings
-            snapshot.tank.volume = self.receiver_volume
+            pneumatic_energy = 0.0
+            if self.gas_network:
+                pneumatic_energy = sum(
+                    float(state.p) * float(state.V_curr)
+                    for state in self.gas_network.lines.values()
+                )
 
-            # System aggregates
             snapshot.aggregates = SystemAggregates(
                 physics_step_time=self.performance.avg_step_time,
                 integration_steps=self.step_counter,
                 integration_failures=self.performance.integration_failures,
+                pneumatic_energy=float(pneumatic_energy),
             )
 
-            # Configuration
             snapshot.master_isolation_open = self.master_isolation_open
             snapshot.thermo_mode = (
                 self.thermo_mode.name
                 if hasattr(self.thermo_mode, "name")
                 else str(self.thermo_mode)
             )
 
             return snapshot
 
-        except Exception as e:
-            self.logger.error(f"Failed to create state snapshot: {e}")
+        except Exception as exc:  # pragma: no cover - defensive logging
+            self.logger.error(f"Failed to create state snapshot: {exc}")
             return None
 
 
 class SimulationManager(QObject):
     """High-level simulation manager
 
     Manages PhysicsWorker in separate thread and provides
     unified interface for UI interaction.
     """
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Create physics thread and worker
         self.physics_thread = QThread()
         self.physics_worker = PhysicsWorker()
 
         # Move worker to physics thread
         self.physics_worker.moveToThread(self.physics_thread)
 
         # Create state bus for communication
         self.state_bus = StateBus()
 
         # Create state queue for latest-only semantics
         self.state_queue = LatestOnlyQueue()
diff --git a/tests/integration/test_sim_loop_execution.py b/tests/integration/test_sim_loop_execution.py
new file mode 100644
index 0000000000000000000000000000000000000000..844fb5c60673d15cbb403b71284541de5bf9aea3
--- /dev/null
+++ b/tests/integration/test_sim_loop_execution.py
@@ -0,0 +1,19 @@
+from src.runtime.sim_loop import PhysicsWorker
+from src.pneumo.enums import Line, Wheel
+
+
+def test_physics_worker_generates_dynamic_state():
+    worker = PhysicsWorker()
+    worker.configure()
+
+    for _ in range(10):
+        worker._execute_physics_step()
+
+    snapshot = worker._create_state_snapshot()
+    assert snapshot is not None
+
+    lever_angles = [abs(snapshot.wheels[wheel].lever_angle) for wheel in Wheel]
+    assert any(angle > 1e-6 for angle in lever_angles)
+
+    line_pressures = [snapshot.lines[line].pressure for line in Line]
+    assert any(pressure > 0.0 for pressure in line_pressures)
diff --git a/tests/unit/test_sim_loop_dependencies.py b/tests/unit/test_sim_loop_dependencies.py
new file mode 100644
index 0000000000000000000000000000000000000000..b7237f5e305b52eef11cee4be0eb21ddbd74f80e
--- /dev/null
+++ b/tests/unit/test_sim_loop_dependencies.py
@@ -0,0 +1,33 @@
+import importlib
+import sys
+
+import pytest
+
+
+@pytest.mark.parametrize(
+    "missing_module, expected_hint",
+    [
+        ("src.physics.odes", "physics"),
+        ("src.pneumo.enums", "pneumo"),
+        ("src.road.engine", "road"),
+    ],
+)
+def test_sim_loop_missing_dependency(monkeypatch, missing_module, expected_hint):
+    target_module = "src.runtime.sim_loop"
+    sys.modules.pop(target_module, None)
+
+    original_import = importlib.import_module
+
+    def fake_import(name, *args, **kwargs):
+        if name == missing_module:
+            raise ImportError("module not available")
+        return original_import(name, *args, **kwargs)
+
+    monkeypatch.setattr(importlib, "import_module", fake_import)
+
+    with pytest.raises(ImportError) as excinfo:
+        importlib.import_module(target_module)
+
+    assert expected_hint in str(excinfo.value)
+
+    sys.modules.pop(target_module, None)
diff --git a/assets/qml/main_v2_realism.qml b/assets/qml/main_v2_realism.qml
index 0879d26ad879933dec4a1dab4ff6a2e4a258046d..3485b8e3445cdb7789be9240fe1fce2b431d1424 100644
--- a/assets/qml/main_v2_realism.qml
+++ b/assets/qml/main_v2_realism.qml
@@ -1,193 +1,311 @@
 import QtQuick
 import QtQuick3D
 import QtQuick3D.Helpers   // === FIXED: Remove version number for Qt 6.9.3 compatibility
 
 Item {
     id: root
     anchors.fill: parent
 
+    // --- Batched updates from Python ---
+    property var pendingPythonUpdates: null
+    signal batchUpdatesApplied(var summary)
+
     // --- Camera/control properties with fixed orbit around bottom beam center ---
-    property real cameraDistance: 3200
-    property real minDistance: 150
-    property real maxDistance: 30000
+    property real cameraDistance: 35
+    property real minDistance: 5
+    property real maxDistance: 500
     property real yawDeg: 30            // === CHANGED: Better initial angle
     property real pitchDeg: -10
-    property vector3d pivot: Qt.vector3d(0, userBeamSize/2, userFrameLength/2)   // === FIXED: Center of bottom beam
+    property vector3d pivot: Qt.vector3d(0, toScene(userBeamSize) / 2, toScene(userFrameLength) / 2)
     property real panX: 0               // === ADDED: Pan offset in rig's local X
     property real panY: 0               // === ADDED: Pan offset in rig's local Y
     property bool autoRotate: false
     property real autoRotateSpeed: 0.5
     property real cameraFov: 50.0
     property real cameraNear: 5.0       // === CHANGED: Better near clip
     property real cameraFar: 50000.0
     property real cameraSpeed: 1.0
 
     // === Lighting properties ===
     property real keyLightBrightness: 2.5
     property string keyLightColor: "#ffffff"
     property real keyLightAngleX: -45
     property real keyLightAngleY: 45
     property real fillLightBrightness: 0.8
     property string fillLightColor: "#f0f0ff"
     property real pointLightBrightness: 1.5
-    property real pointLightY: 2000
+    property real pointLightY: 2.0
 
     // --- Environment/quality properties ---
     property string backgroundColor: "#2a2a2a"
     property bool skyboxEnabled: true
     property bool iblEnabled: true
     property real iblIntensity: 1.3     // === CHANGED: Better exposure
 
     property int antialiasingMode: 2     // 0 NoAA, 1 SSAA, 2 MSAA
     property int antialiasingQuality: 2  // 0 Low, 1 Medium, 2 High
     property bool shadowsEnabled: true
     property int shadowQuality: 2
     property real shadowSoftness: 0.5
 
     // --- Effects properties ---
     property bool bloomEnabled: true
     property real bloomThreshold: 1.0
     property real bloomIntensity: 0.6    // === CHANGED: More balanced for filmic
     property bool ssaoEnabled: true
     property real ssaoRadius: 200        // === CHANGED: Scene units for better visibility
     property real ssaoIntensity: 70      // === CHANGED: Proper strength value
     property bool tonemapEnabled: true
     property int tonemapMode: 3          // 0=None, 1=Linear, 2=Reinhard, 3=Filmic
 
     property bool depthOfFieldEnabled: false
-    property real dofFocusDistance: 2000
-    property real dofFocusRange: 900
-
-    // --- Geometry/animation properties (unchanged) ---
-    property real userFrameLength: 3200
-    property real userFrameHeight: 650
-    property real userBeamSize: 120
-    property real userLeverLength: 800
-    property real userCylinderLength: 500
-    property real userTrackWidth: 1600
-    property real userFrameToPivot: 600
+    property real dofFocusDistance: 20
+    property real dofFocusRange: 9
+
+    // --- Geometry properties in meters ---
+    property real sceneScale: 10.0
+    property real userFrameLength: 3.2
+    property real userFrameHeight: 0.65
+    property real userBeamSize: 0.12
+    property real userLeverLength: 0.8
+    property real userCylinderLength: 0.5
+    property real userTrackWidth: 1.6
+    property real userFrameToPivot: 0.6
     property real userRodPosition: 0.6
-    property real userBoreHead: 80
-    property real userRodDiameter: 35
-    property real userPistonThickness: 25
-    property real userPistonRodLength: 200
+    property real userBoreHead: 0.08
+    property real userRodDiameter: 0.035
+    property real userPistonThickness: 0.025
+    property real userPistonRodLength: 0.2
+
+    // --- Simulation state (radians/meters/pascals) ---
+    property var leverAngles: ({ fl: 0.0, fr: 0.0, rl: 0.0, rr: 0.0 })
+    property var pistonPositions: ({ fl: 0.0, fr: 0.0, rl: 0.0, rr: 0.0 })
+    property var lineStates: ({})
+    property var aggregateState: ({})
+    property var frameState: ({})
+
     property bool isRunning: false
     property real animationTime: 0.0
-    property real userAmplitude: 8.0
-    property real userFrequency: 1.0
-    property real userPhaseGlobal: 0.0
-    property real userPhaseFL: 0.0
-    property real userPhaseFR: 0.0
-    property real userPhaseRL: 0.0
-    property real userPhaseRR: 0.0
-    property real fl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseFL) * Math.PI / 180) : 0.0
-    property real fr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseFR) * Math.PI / 180) : 0.0
-    property real rl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseRL) * Math.PI / 180) : 0.0
-    property real rr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency * 2 * Math.PI + (userPhaseGlobal + userPhaseRR) * Math.PI / 180) : 0.0
+
+    function toScene(value) {
+        return Number(value) * sceneScale
+    }
+
+    function leverAngleRadFor(name) {
+        if (!leverAngles || leverAngles[name] === undefined)
+            return 0.0
+        const v = leverAngles[name]
+        return typeof v === "number" ? v : Number(v)
+    }
+
+    function pistonPositionFor(name) {
+        if (!pistonPositions || pistonPositions[name] === undefined)
+            return 0.0
+        const v = pistonPositions[name]
+        return typeof v === "number" ? v : Number(v)
+    }
+
+    function updatePivot() {
+        pivot = Qt.vector3d(0, toScene(userBeamSize) / 2, toScene(userFrameLength) / 2)
+    }
+
+    onUserFrameLengthChanged: updatePivot()
+    onUserBeamSizeChanged: updatePivot()
+
+    onPendingPythonUpdatesChanged: {
+        if (!pendingPythonUpdates)
+            return
+        try {
+            applyBatchedUpdates(pendingPythonUpdates)
+        } finally {
+            pendingPythonUpdates = null
+        }
+    }
+
+    function applyBatchedUpdates(updates) {
+        if (!updates)
+            return
+        var applied = {}
+        if (updates.geometry) { applyGeometryUpdates(updates.geometry); applied.geometry = true }
+        if (updates.camera) { applyCameraUpdates(updates.camera); applied.camera = true }
+        if (updates.lighting) { applyLightingUpdates(updates.lighting); applied.lighting = true }
+        if (updates.environment) { applyEnvironmentUpdates(updates.environment); applied.environment = true }
+        if (updates.quality) { applyQualityUpdates(updates.quality); applied.quality = true }
+        if (updates.materials) { applyMaterialUpdates(updates.materials); applied.materials = true }
+        if (updates.effects) { applyEffectsUpdates(updates.effects); applied.effects = true }
+        if (updates.animation) { applyAnimationUpdates(updates.animation); applied.animation = true }
+        if (updates.simulation) { applySimulationUpdates(updates.simulation); applied.simulation = true }
+
+        batchUpdatesApplied(applied)
+    }
+
+    function applySimulationUpdates(params) {
+        if (!params)
+            return
+        if (params.levers)
+            leverAngles = Object.assign({}, leverAngles, params.levers)
+        if (params.pistons)
+            pistonPositions = Object.assign({}, pistonPositions, params.pistons)
+        if (params.lines)
+            lineStates = params.lines
+        if (params.aggregates)
+            aggregateState = params.aggregates
+        if (params.frame)
+            frameState = params.frame
+    }
+
+    function applyGeometryUpdates(params) { updateGeometry(params) }
+    function applyLightingUpdates(params) { updateLighting(params) }
+    function applyEnvironmentUpdates(params) { updateEnvironment(params) }
+    function applyQualityUpdates(params) { updateQuality(params) }
+    function applyMaterialUpdates(params) { updateMaterials(params) }
+    function applyEffectsUpdates(params) { updateEffects(params) }
+    function applyCameraUpdates(params) { updateCamera(params) }
+    function applyAnimationUpdates(params) { updateAnimation(params) }
 
     // === HDR probe with fallback ===
     Texture {
         id: hdrProbe
         source: "assets/studio_small_09_2k.hdr"  // === FIXED: Relative path
     }
 
     // === Smooth camera animations ===
     Behavior on yawDeg         { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on pitchDeg       { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on cameraDistance { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
     Behavior on panX           { NumberAnimation { duration: 120; easing.type: Easing.OutCubic } }
     Behavior on panY           { NumberAnimation { duration: 120; easing.type: Easing.OutCubic } }
 
     // === Python integration functions ===
     function updateGeometry(params) {
         console.log("QML: updateGeometry called with", JSON.stringify(params))
 
         if (params.frameLength !== undefined) userFrameLength = params.frameLength
         if (params.frameHeight !== undefined) userFrameHeight = params.frameHeight
         if (params.frameBeamSize !== undefined) userBeamSize = params.frameBeamSize
         if (params.leverLength !== undefined) userLeverLength = params.leverLength
         if (params.cylinderBodyLength !== undefined) userCylinderLength = params.cylinderBodyLength
         if (params.trackWidth !== undefined) userTrackWidth = params.trackWidth
         if (params.frameToPivot !== undefined) userFrameToPivot = params.frameToPivot
         if (params.rodPosition !== undefined) userRodPosition = params.rodPosition
 
+        updatePivot()
         resetView() // Update camera after geometry changes
     }
 
     function updateLighting(params) {
         console.log("QML: updateLighting called with", JSON.stringify(params))
 
         if (params.key_light) {
             var kl = params.key_light
             if (kl.brightness !== undefined) keyLightBrightness = kl.brightness
             if (kl.color !== undefined) keyLightColor = kl.color
             if (kl.angle_x !== undefined) keyLightAngleX = kl.angle_x
             if (kl.angle_y !== undefined) keyLightAngleY = kl.angle_y
         }
 
         if (params.fill_light) {
             var fl = params.fill_light
             if (fl.brightness !== undefined) fillLightBrightness = fl.brightness
             if (fl.color !== undefined) fillLightColor = fl.color
         }
 
         if (params.point_light) {
             var pl = params.point_light
             if (pl.brightness !== undefined) pointLightBrightness = pl.brightness
             if (pl.position_y !== undefined) pointLightY = pl.position_y
         }
     }
 
     function updateEnvironment(params) {
         console.log("QML: updateEnvironment called with", JSON.stringify(params))
 
         if (params.background_color !== undefined) backgroundColor = params.background_color
         if (params.skybox_enabled !== undefined) skyboxEnabled = params.skybox_enabled
         if (params.ibl_enabled !== undefined) iblEnabled = params.ibl_enabled
         if (params.ibl_intensity !== undefined) iblIntensity = params.ibl_intensity
     }
 
     function updateQuality(params) {
         console.log("QML: updateQuality called with", JSON.stringify(params))
 
         if (params.antialiasing !== undefined) antialiasingMode = params.antialiasing
         if (params.aa_quality !== undefined) antialiasingQuality = params.aa_quality
         if (params.shadows_enabled !== undefined) shadowsEnabled = params.shadows_enabled
         if (params.shadow_quality !== undefined) shadowQuality = params.shadow_quality
         if (params.shadow_softness !== undefined) shadowSoftness = params.shadow_softness
     }
 
+    function updateMaterials(params) {
+        if (!params)
+            return
+        console.log("QML: updateMaterials called with", JSON.stringify(params))
+    }
+
+    function updateEffects(params) {
+        if (!params)
+            return
+        console.log("QML: updateEffects called with", JSON.stringify(params))
+        if (params.bloomEnabled !== undefined) bloomEnabled = !!params.bloomEnabled
+        if (params.bloomIntensity !== undefined) bloomIntensity = Number(params.bloomIntensity)
+        if (params.bloomThreshold !== undefined) bloomThreshold = Number(params.bloomThreshold)
+        if (params.ssaoEnabled !== undefined) ssaoEnabled = !!params.ssaoEnabled
+    }
+
+    function updateCamera(params) {
+        if (!params)
+            return
+        console.log("QML: updateCamera called with", JSON.stringify(params))
+        if (params.distance !== undefined) cameraDistance = Number(params.distance)
+        if (params.yaw !== undefined) yawDeg = Number(params.yaw)
+        if (params.pitch !== undefined) pitchDeg = Number(params.pitch)
+        if (params.panX !== undefined) panX = Number(params.panX)
+        if (params.panY !== undefined) panY = Number(params.panY)
+        if (params.pivot) {
+            var p = params.pivot
+            try { pivot = Qt.vector3d(Number(p.x||p[0]), Number(p.y||p[1]), Number(p.z||p[2])) } catch(e) { }
+        }
+    }
+
+    function updateAnimation(params) {
+        if (!params)
+            return
+        console.log("QML: updateAnimation called with", JSON.stringify(params))
+        if (params.isRunning !== undefined) isRunning = !!params.isRunning
+        if (params.animationTime !== undefined) animationTime = Number(params.animationTime)
+    }
+
     // === Fixed camera functions - pivot always at bottom beam center ===
     function computePivot() {
-        return Qt.vector3d(0, userBeamSize/2, userFrameLength/2)
+        return Qt.vector3d(0, toScene(userBeamSize)/2, toScene(userFrameLength)/2)
     }
 
     function autoFitFrame(marginFactor) {
-        const L = Math.max(1, userFrameLength)
-        const T = Math.max(1, userTrackWidth)
-        const H = Math.max(1, userFrameHeight)
+        const L = Math.max(0.01, toScene(userFrameLength))
+        const T = Math.max(0.01, toScene(userTrackWidth))
+        const H = Math.max(0.01, toScene(userFrameHeight))
         const margin = marginFactor !== undefined ? marginFactor : 1.15
         const R = 0.5 * Math.sqrt(L*L + T*T + H*H)
         const fov = cameraFov * Math.PI / 180.0
         const dist = (R * margin) / Math.tan(fov * 0.5)
         cameraDistance = Math.max(minDistance, Math.min(maxDistance, dist))
     }
 
     function resetView() {
         pivot = computePivot()
         yawDeg = 30       // Front-right view
         pitchDeg = -10
         panX = 0          // Reset pan
         panY = 0
         autoFitFrame()
     }
 
     View3D {
         id: view3d
         anchors.fill: parent
 
         // === FIXED: Proper ExtendedSceneEnvironment implementation for Qt 6.9.3 ===
         environment: ExtendedSceneEnvironment {
             // Background and IBL
             backgroundMode: root.skyboxEnabled ? SceneEnvironment.SkyBox : SceneEnvironment.Color
             clearColor: root.backgroundColor
@@ -260,189 +378,189 @@ Item {
 
         // === FIXED: Orbital camera rig - rotation strictly around bottom beam center ===
         Node {
             id: cameraRig
             position: root.pivot                      // Rotation axis at bottom beam center
             eulerRotation: Qt.vector3d(root.pitchDeg, root.yawDeg, 0)
 
             Node {                                    // Pan node in rig's local system
                 id: panNode
                 position: Qt.vector3d(root.panX, root.panY, 0)
 
                 PerspectiveCamera {
                     id: camera
                     position: Qt.vector3d(0, 0, root.cameraDistance)   // Zoom only affects Z
                     fieldOfView: root.cameraFov
                     clipNear: root.cameraNear
                     clipFar: root.cameraFar
                 }
             }
         }
 
         // === ReflectionProbe for local reflections ===
         ReflectionProbe {
             id: probeMain
             position: root.pivot
-            boxSize: Qt.vector3d(root.userTrackWidth, root.userFrameHeight, root.userFrameLength)
+            boxSize: Qt.vector3d(toScene(root.userTrackWidth), toScene(root.userFrameHeight), toScene(root.userFrameLength))
             parallaxCorrection: true
             quality: ReflectionProbe.VeryHigh
             refreshMode: ReflectionProbe.EveryFrame
             timeSlicing: ReflectionProbe.IndividualFaces
         }
 
         // === Lighting setup ===
         DirectionalLight {
             id: keyLight
             eulerRotation.x: root.keyLightAngleX
             eulerRotation.y: root.keyLightAngleY
             brightness: root.keyLightBrightness
             color: root.keyLightColor
             castsShadow: root.shadowsEnabled
             shadowMapQuality: [Light.ShadowMapQualityLow, Light.ShadowMapQualityMedium, Light.ShadowMapQualityHigh][root.shadowQuality]
             shadowFactor: 75
             shadowBias: root.shadowSoftness * 0.001
         }
 
         DirectionalLight {
             id: fillLight
             eulerRotation.x: -60
             eulerRotation.y: 135
             brightness: root.fillLightBrightness
             color: root.fillLightColor
             castsShadow: false
         }
 
         PointLight {
             id: pointLight
-            position: Qt.vector3d(0, root.pointLightY, 1500)
+            position: Qt.vector3d(0, toScene(root.pointLightY), toScene(1.5))
             brightness: root.pointLightBrightness
             color: "#ffffff"
             quadraticFade: 0.00008
         }
 
         // === Suspension geometry (basic for testing) ===
 
         // === ИСПРАВЛЕННАЯ ГЕОМЕТРИЯ: Правильные координаты и масштабирование ===
 
         // Main frame (центральная балка на земле)
         Model {
             id: mainFrame
-            position: Qt.vector3d(0, root.userBeamSize/2, root.userFrameLength/2)  // ИСПРАВЛЕНО: По центру
+            position: Qt.vector3d(0, toScene(root.userBeamSize)/2, toScene(root.userFrameLength)/2)  // ИСПРАВЛЕНО: По центру
 
             source: "#Cube"
-            scale: Qt.vector3d(root.userTrackWidth/100, root.userBeamSize/100, root.userFrameLength/100)
+            scale: Qt.vector3d(toScene(root.userTrackWidth), toScene(root.userBeamSize), toScene(root.userFrameLength))
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#4a4a4a"
                     metalness: 0.8
                     roughness: 0.3
                 }
             ]
         }
 
         // ИСПРАВЛЕННАЯ ПОДВЕСКА: Правильные позиции и масштабы
 
         // Front left lever (передний левый рычаг)
         Model {
             id: frontLeftLever
-            position: Qt.vector3d(-root.userTrackWidth/2, root.userBeamSize, root.userFrameToPivot)
+            position: Qt.vector3d(-toScene(root.userTrackWidth)/2, toScene(root.userBeamSize), toScene(root.userFrameToPivot))
 
             source: "#Cube"
-            scale: Qt.vector3d(root.userLeverLength/100, 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
-            eulerRotation: Qt.vector3d(0, 0, root.fl_angle)     // ИСПРАВЛЕНО: Правильная ось вращения
+            scale: Qt.vector3d(toScene(root.userLeverLength), 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
+            eulerRotation: Qt.vector3d(0, 0, Qt.radiansToDegrees(leverAngleRadFor("fl")))     // ИСПРАВЛЕНО: Правильная ось вращения
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#ff6b35"
                     metalness: 0.9
                     roughness: 0.2
                 }
             ]
         }
 
         // Front right lever (передний правый рычаг)
         Model {
             id: frontRightLever
-            position: Qt.vector3d(root.userTrackWidth/2, root.userBeamSize, root.userFrameToPivot)
+            position: Qt.vector3d(toScene(root.userTrackWidth)/2, toScene(root.userBeamSize), toScene(root.userFrameToPivot))
 
             source: "#Cube"
-            scale: Qt.vector3d(root.userLeverLength/100, 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
-            eulerRotation: Qt.vector3d(0, 0, root.fr_angle)     // ИСПРАВЛЕНО: Правильная ось вращения
+            scale: Qt.vector3d(toScene(root.userLeverLength), 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
+            eulerRotation: Qt.vector3d(0, 0, Qt.radiansToDegrees(leverAngleRadFor("fr")))     // ИСПРАВЛЕНО: Правильная ось вращения
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#ff6b35"
                     metalness: 0.9
                     roughness: 0.2
                 }
             ]
         }
 
         // Rear left lever (задний левый рычаг)
         Model {
             id: rearLeftLever
-            position: Qt.vector3d(-root.userTrackWidth/2, root.userBeamSize, root.userFrameLength - root.userFrameToPivot)
+            position: Qt.vector3d(-toScene(root.userTrackWidth)/2, toScene(root.userBeamSize), toScene(root.userFrameLength - root.userFrameToPivot))
 
             source: "#Cube"
-            scale: Qt.vector3d(root.userLeverLength/100, 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
-            eulerRotation: Qt.vector3d(0, 0, root.rl_angle)     // ИСПРАВЛЕНО: Правильная ось вращения
+            scale: Qt.vector3d(toScene(root.userLeverLength), 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
+            eulerRotation: Qt.vector3d(0, 0, Qt.radiansToDegrees(leverAngleRadFor("rl")))     // ИСПРАВЛЕНО: Правильная ось вращения
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#35ff6b"
                     metalness: 0.9
                     roughness: 0.2
                 }
             ]
         }
 
         // Rear right lever (задний правый рычаг)
         Model {
             id: rearRightLever
-            position: Qt.vector3d(root.userTrackWidth/2, root.userBeamSize, root.userFrameLength - root.userFrameToPivot)
+            position: Qt.vector3d(toScene(root.userTrackWidth)/2, toScene(root.userBeamSize), toScene(root.userFrameLength - root.userFrameToPivot))
 
             source: "#Cube"
-            scale: Qt.vector3d(root.userLeverLength/100, 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
-            eulerRotation: Qt.vector3d(0, 0, root.rr_angle)     // ИСПРАВЛЕНО: Правильная ось вращения
+            scale: Qt.vector3d(toScene(root.userLeverLength), 8, 8)  // ИСПРАВЛЕНО: Правильный масштаб
+            eulerRotation: Qt.vector3d(0, 0, Qt.radiansToDegrees(leverAngleRadFor("rr")))     // ИСПРАВЛЕНО: Правильная ось вращения
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#35ff6b"
                     metalness: 0.9
                     roughness: 0.2
                 }
             ]
         }
 
         // Pneumatic cylinder (пневматический цилиндр)
         Model {
             id: cylinderFL
-            position: Qt.vector3d(-root.userTrackWidth/4, root.userBeamSize + root.userFrameHeight/2, root.userFrameToPivot)
+            position: Qt.vector3d(-toScene(root.userTrackWidth)/4, toScene(root.userBeamSize + root.userFrameHeight/2), toScene(root.userFrameToPivot))
 
             source: "#Cylinder"
-            scale: Qt.vector3d(root.userBoreHead/100, root.userCylinderLength/100, root.userBoreHead/100)  // ИСПРАВЛЕНО: Правильные размеры
+            scale: Qt.vector3d(toScene(root.userBoreHead), toScene(root.userCylinderLength), toScene(root.userBoreHead))  // ИСПРАВЛЕНО: Правильные размеры
 
             materials: [
                 PrincipledMaterial {
                     baseColor: "#6b35ff"
                     metalness: 0.95
                     roughness: 0.1
                     clearcoatAmount: 0.8
                 }
             ]
         }
     }
 
     // === FIXED: Mouse controls - proper orbit/pan/zoom around fixed pivot ===
     MouseArea {
         id: mouseArea
         anchors.fill: parent
         hoverEnabled: true
         acceptedButtons: Qt.LeftButton | Qt.RightButton
         property real lastX: 0
         property real lastY: 0
 
         onPressed: (m) => { lastX = m.x; lastY = m.y }
 
         onPositionChanged: (m) => {
             const dx = m.x - lastX
diff --git a/src/common/settings_manager.py b/src/common/settings_manager.py
index 975de349023aee09a2ed54cb93c25a755a24ff24..ce768d00393f19b9db13fb248b0cabb8a06095dd 100644
--- a/src/common/settings_manager.py
+++ b/src/common/settings_manager.py
@@ -17,63 +17,132 @@ from pathlib import Path
 from typing import Any, Dict, Optional
 from datetime import datetime
 import copy
 import re
 
 
 class SettingsManager:
     """
     Централизованный менеджер настроек приложения
 
     Архитектура:
     1. Загрузка из config/app_settings.json (единый источник истины)
     2. Изменения только через UI
     3. Автосохранение при каждом изменении
     4. "Сброс" = загрузка snapshot дефолтов из того же файла
     5. "Сохранить как дефолт" = обновление snapshot в файле
 
     Структура файла:
     {
         "current": { ... текущие настройки ... },
         "defaults_snapshot": { ... сохраненные дефолты ... },
         "metadata": { "version", "last_modified", ... }
     }
     """
 
+    # Canonical geometry keys exposed in meters for UI/visualization modules
+    _GEOMETRY_KEY_ALIASES = {
+        "frame_length_m": (
+            "frame_length_m",
+            "frameLength",
+            "frame_length",
+            "frameLengthMeters",
+        ),
+        "frame_height_m": (
+            "frame_height_m",
+            "frameHeight",
+            "frame_height",
+        ),
+        "frame_beam_size_m": (
+            "frame_beam_size_m",
+            "frameBeamSize",
+            "beam_size",
+        ),
+        "lever_length_m": (
+            "lever_length_m",
+            "lever_length",
+            "leverLength",
+        ),
+        "cylinder_body_length_m": (
+            "cylinder_body_length_m",
+            "cylinder_length",
+            "cylinderBodyLength",
+        ),
+        "tail_rod_length_m": (
+            "tail_rod_length_m",
+            "tailRodLength",
+            "tail_rod_length",
+            "piston_rod_length_m",
+        ),
+    }
+
+    _GEOMETRY_DEFAULTS_METERS = {
+        "frame_length_m": 2.0,
+        "frame_height_m": 0.65,
+        "frame_beam_size_m": 0.12,
+        "lever_length_m": 0.315,
+        "cylinder_body_length_m": 0.25,
+        "tail_rod_length_m": 0.1,
+    }
+
     def __init__(self, settings_file: str | Path = "config/app_settings.json"):
         self.logger = logging.getLogger(__name__)
         # Разрешаем путь к файлу настроек более надёжно (CWD / корень проекта / env var)
         self.settings_file = self._resolve_settings_file(settings_file)
 
         # Внутреннее состояние
         self._current: Dict[str, Any] = {}
         self._defaults_snapshot: Dict[str, Any] = {}
         self._metadata: Dict[str, Any] = {}
 
         # Загрузка настроек
         self.load()
 
+    # ------------------------------------------------------------------
+    # Geometry helpers
+    # ------------------------------------------------------------------
+    def get_geometry_snapshot(self) -> Dict[str, float]:
+        """Return geometry configuration in meters with sensible defaults."""
+
+        geometry_raw = self.get_category("geometry") or {}
+        snapshot: Dict[str, float] = {}
+
+        for canonical_key, aliases in self._GEOMETRY_KEY_ALIASES.items():
+            value = None
+            for alias in aliases:
+                if alias in geometry_raw:
+                    value = self._convert_value(geometry_raw[alias])
+                    break
+
+            if value is None:
+                value = self._GEOMETRY_DEFAULTS_METERS.get(canonical_key)
+
+            if value is not None:
+                snapshot[canonical_key] = float(value)
+
+        return snapshot
+
     def _resolve_settings_file(self, settings_file: str | Path) -> Path:
         """Определить корректный путь к файлу настроек.
 
         Алгоритм:
         1) PSS_SETTINGS_FILE из окружения (если задан и существует)
         2) Относительно текущего каталога (CWD)
         3) Относительно корня проекта (../../config от src/common)
         4) Возврат пути из аргумента (как есть)
         """
         try:
             # 1) ENV override
             import os
 
             env_path = os.environ.get("PSS_SETTINGS_FILE")
             if env_path:
                 p = Path(env_path)
                 if p.exists():
                     self.logger.info(f"Settings: using PSS_SETTINGS_FILE={p}")
                     if os.environ.get("PSS_VERBOSE_CONFIG") == "1":
                         print(f"[Settings] Using PSS_SETTINGS_FILE: {p}")
                     return p
                 else:
                     self.logger.warning(
                         f"Settings: PSS_SETTINGS_FILE points to missing file: {p}"
                     )
diff --git a/src/ui/geometry_bridge.py b/src/ui/geometry_bridge.py
index 2e70fb51efc06fa7552da80f8c9371060f38f678..22851aee66ac3d09c999aef9338866a0d49b05f7 100644
--- a/src/ui/geometry_bridge.py
+++ b/src/ui/geometry_bridge.py
@@ -1,73 +1,87 @@
 # -*- coding: utf-8 -*-
-"""
-Geometry-to-3D bridge module
-Converts 2D kinematics geometry to 3D visualization coordinates
-INTEGRATED WITH USER INTERFACE CONTROLS
-"""
+"""Geometry-to-3D bridge utilities (SI units)."""
+
+from __future__ import annotations
+
+from typing import Any, Dict, Optional
+
 import numpy as np
+from PySide6.QtCore import QObject, Property, Signal
 from PySide6.QtGui import QVector3D
-from PySide6.QtCore import QObject, Signal, Property
-from typing import Dict, Any, Optional
 
-from ..core.settings import SettingsManager
+from ..common.settings_manager import SettingsManager, get_settings_manager
 from ..core.geometry import GeometryParams
 
 
 class GeometryTo3DConverter(QObject):
     """Converts 2D geometry parameters to 3D visualization coordinates
     WITH USER INTERFACE INTEGRATION"""
 
     # Signals for parameter changes
     geometryChanged = Signal()
     frameChanged = Signal()
 
-    def __init__(self, geometry: GeometryParams):
-        """Initialize geometry bridge converter"""
+    def __init__(
+        self,
+        geometry: GeometryParams,
+        settings_manager: Optional[SettingsManager] = None,
+    ):
+        """Initialize geometry bridge converter using SI units."""
         super().__init__()
         self.geometry = geometry
+        self._settings_manager = settings_manager or get_settings_manager()
+
+        defaults = {
+            "frame_beam_size_m": 0.12,
+            "frame_height_m": 0.65,
+            "frame_length_m": 2.0,
+            "lever_length_m": 0.315,
+            "cylinder_body_length_m": 0.25,
+            "tail_rod_length_m": 0.1,
+        }
 
-        # USER-CONTROLLABLE PARAMETERS (will be connected to UI)
-        self._frame_beam_size = 120.0  # mm - beam size
-        self._frame_height = 650.0  # mm - horn height
-        self._frame_length = 2000.0  # mm - frame length (2 meters!)
-        self._lever_length = 315.0  # mm - lever length
-        self._cylinder_body_length = 250.0  # mm - cylinder working length
-        self._tail_rod_length = 100.0  # mm - tail extension length
-
-        # Z-coordinates for front/rear - calculated from frame length
-        self._front_z = -self._frame_length / 2.0  # Front at -1000mm
-        self._rear_z = self._frame_length / 2.0  # Rear at +1000mm
-
-        print("    GeometryBridge initialized:")
-        print(
-            f"      Frame: {self._frame_length:.0f}x{self._frame_height:.0f}x{self._frame_beam_size:.0f}mm"
-        )
-        print(f"      Lever: {self._lever_length:.0f}mm")
-        print(
-            f"      Cylinder: {self._cylinder_body_length:.0f}mm + {self._tail_rod_length:.0f}mm tail"
-        )
+        settings = {}
+        try:
+            if self._settings_manager:
+                settings = self._settings_manager.get_geometry_snapshot()
+        except Exception:
+            settings = {}
+
+        merged = {**defaults, **settings}
+
+        # Store all measurements in meters
+        self._frame_beam_size = merged["frame_beam_size_m"]
+        self._frame_height = merged["frame_height_m"]
+        self._frame_length = merged["frame_length_m"]
+        self._lever_length = merged["lever_length_m"]
+        self._cylinder_body_length = merged["cylinder_body_length_m"]
+        self._tail_rod_length = merged["tail_rod_length_m"]
+
+        # Z-coordinates for front/rear in meters
+        self._front_z = -self._frame_length / 2.0
+        self._rear_z = self._frame_length / 2.0
 
     # USER-CONTROLLABLE PROPERTIES (connected to UI sliders/spinboxes)
 
     @Property(float, notify=frameChanged)
     def frameLength(self):
         return self._frame_length
 
     @frameLength.setter
     def frameLength(self, value):
         if self._frame_length != value:
             self._frame_length = value
             self._front_z = -value / 2.0
             self._rear_z = value / 2.0
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=frameChanged)
     def frameHeight(self):
         return self._frame_height
 
     @frameHeight.setter
     def frameHeight(self, value):
         if self._frame_height != value:
             self._frame_height = value
             self.frameChanged.emit()
@@ -93,199 +107,205 @@ class GeometryTo3DConverter(QObject):
         if self._lever_length != value:
             self._lever_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
     def cylinderBodyLength(self):
         return self._cylinder_body_length
 
     @cylinderBodyLength.setter
     def cylinderBodyLength(self, value):
         if self._cylinder_body_length != value:
             self._cylinder_body_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
     def tailRodLength(self):
         return self._tail_rod_length
 
     @tailRodLength.setter
     def tailRodLength(self, value):
         if self._tail_rod_length != value:
             self._tail_rod_length = value
             self.geometryChanged.emit()
 
     def get_frame_params(self) -> Dict[str, float]:
-        """Get frame parameters for 3D visualization"""
+        """Get frame parameters for 3D visualization in meters."""
+
         return {
             "beamSize": self._frame_beam_size,
             "frameHeight": self._frame_height,
             "frameLength": self._frame_length,
+            "beamSizeM": self._frame_beam_size,
+            "frameHeightM": self._frame_height,
+            "frameLengthM": self._frame_length,
         }
 
     def get_corner_3d_coords(
         self,
         corner: str,
         lever_angle_deg: float = 0.0,
         cylinder_state: Optional[Any] = None,
     ) -> Dict[str, Any]:
         """Convert 2D kinematics to 3D coordinates for one corner
         USING CORRECTED SUSPENSION MECHANICS FROM test_2m_suspension.py
 
         Args:
             corner: 'fl', 'fr', 'rl', 'rr'
             lever_angle_deg: Current lever angle in degrees
             cylinder_state: Optional CylinderState from physics simulation
 
         Returns:
             Dictionary with 3D coordinates for QML (compatible with CorrectedSuspensionCorner)
         """
         # Determine side and position
         is_left = corner.endswith("l")  # fl, rl = left side
         is_front = corner.startswith("f")  # fl, fr = front
 
         # Side multiplier for mirroring
         side_mult = -1.0 if is_left else 1.0
 
         # Z position (longitudinal)
         z_plane = self._front_z if is_front else self._rear_z
 
         # FIXED FRAME ATTACHMENT POINTS (never change)
 
         # Lever pivot (j_arm) - FIXED attachment to frame
-        pivot_offset_x = 150.0  # mm from center
-        pivot_height = self._frame_beam_size / 2.0  # ON BEAM AXIS
+        pivot_offset_x = 0.15  # m from center
+        pivot_height = self._frame_beam_size / 2.0  # beam axis height (m)
 
         j_arm = QVector3D(
             pivot_offset_x * side_mult,  # ±150mm from center
             pivot_height,  # beam axis height
             z_plane,  # EXACTLY in plane
         )
 
         # Cylinder tail (j_tail) - FIXED attachment to frame
-        horn_height = self._frame_beam_size + self._frame_height  # total horn height
-        tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset
-        tail_offset_x = 100.0  # mm from center
+        horn_height = self._frame_beam_size + self._frame_height  # total horn height (m)
+        tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset (m)
+        tail_offset_x = 0.1  # m from center
 
         j_tail = QVector3D(
             tail_offset_x * side_mult,  # ±100mm from center
             tail_height,  # horn height
             z_plane,  # EXACTLY in plane
         )
 
         # MOVING PARTS (depend on lever angle)
 
         # Base angle: LEFT side points LEFT (180°), RIGHT side points RIGHT (0°)
         base_angle_deg = 180.0 if is_left else 0.0
         total_angle_deg = base_angle_deg + lever_angle_deg
         total_angle_rad = np.deg2rad(total_angle_deg)
 
         # Rod attachment point on lever (at lever end)
         rod_attach_x = j_arm.x() + self._lever_length * np.cos(total_angle_rad)
         rod_attach_y = j_arm.y() + self._lever_length * np.sin(total_angle_rad)
 
         j_rod = QVector3D(rod_attach_x, rod_attach_y, z_plane)
 
         # PISTON POSITION CALCULATION
         # Calculate from GEOMETRY (correct kinematics!)
         # Distance from tail to rod attachment point
         tail_to_rod_dist = np.sqrt(
             (j_rod.x() - j_tail.x()) ** 2 + (j_rod.y() - j_tail.y()) ** 2
         )
 
         # Total assembly: tail_rod + cylinder_body + piston_rod
         # tail_rod = FIXED 100mm
         # cylinder_body = FIXED 250mm
         # piston_rod = VARIABLE (depends on lever angle!)
 
         # Calculate baseline distance (lever horizontal)
         base_angle_rad = np.deg2rad(base_angle_deg)
         base_rod_x = j_arm.x() + self._lever_length * np.cos(base_angle_rad)
         base_rod_y = j_arm.y() + self._lever_length * np.sin(base_angle_rad)
         base_dist = np.sqrt(
             (base_rod_x - j_tail.x()) ** 2 + (base_rod_y - j_tail.y()) ** 2
         )
 
         # Change in distance from baseline
         delta_dist = tail_to_rod_dist - base_dist
 
         # Piston position inside cylinder:
         # When lever is horizontal (baseline), piston is centered
         # When lever rotates, distance changes ? piston moves
         # Piston moves IN SAME DIRECTION as rod extension
         # (if rod extends/distance increases, piston moves toward rod end/increases)
         # CORRECTED: Use PLUS (not minus) because piston follows rod extension
-        piston_position_mm = (self._cylinder_body_length / 2.0) + delta_dist
+        piston_position_m = (self._cylinder_body_length / 2.0) + delta_dist
 
         # Clip to safe range (10% to 90% of cylinder length)
-        piston_position_mm = float(
+        piston_position_m = float(
             np.clip(
-                piston_position_mm,
+                piston_position_m,
                 self._cylinder_body_length
                 * 0.1,  # 10% minimum (25mm for 250mm cylinder)
                 self._cylinder_body_length
                 * 0.9,  # 90% maximum (225mm for 250mm cylinder)
             )
         )
 
         # Calculate ratio for QML
-        piston_ratio = float(piston_position_mm / self._cylinder_body_length)
+        piston_ratio = float(piston_position_m / self._cylinder_body_length)
 
         # If cylinder_state provided, OVERRIDE with physics data
         if cylinder_state is not None:
             # Use actual physics data from CylinderKinematics
-            stroke_mm = cylinder_state.stroke * 1000.0  # m to mm
-
             # Calculate piston position from stroke
             # Assuming stroke 0 = center of cylinder
-            max_stroke_mm = self._cylinder_body_length * 0.4  # ±40% stroke range
-            piston_ratio_physics = 0.5 + (stroke_mm / (2 * max_stroke_mm))
+            max_stroke = self._cylinder_body_length * 0.4  # ±40% stroke range (m)
+            piston_ratio_physics = 0.5 + (
+                cylinder_state.stroke / (2 * max_stroke)
+            )
             piston_ratio_physics = float(np.clip(piston_ratio_physics, 0.1, 0.9))
-            piston_position_mm_physics = (
+            piston_position_physics = (
                 piston_ratio_physics * self._cylinder_body_length
             )
 
             # Use physics values
-            piston_position_mm = float(piston_position_mm_physics)
+            piston_position_m = float(piston_position_physics)
             piston_ratio = float(piston_ratio_physics)
 
         # Return data compatible with CorrectedSuspensionCorner.qml
         result = {
             # FIXED joints
             "j_arm": j_arm,  # Lever pivot (orange joint)
             "j_tail": j_tail,  # Cylinder mount (blue joint)
             "j_rod": j_rod,  # Rod attachment (green joint)
             # Animation
             "leverAngle": float(lever_angle_deg),
             # Dimensions (for QML calculations)
             "leverLength": float(self._lever_length),
+            "leverLengthM": float(self._lever_length),
             "cylinderBodyLength": float(self._cylinder_body_length),
+            "cylinderBodyLengthM": float(self._cylinder_body_length),
             "tailRodLength": float(self._tail_rod_length),
+            "tailRodLengthM": float(self._tail_rod_length),
             # PISTON POSITION (ALWAYS float, never None or empty!)
-            "pistonPositionMm": float(
-                piston_position_mm
-            ),  # Absolute position in cylinder (mm)
+            "pistonPositionM": float(piston_position_m),
+            "pistonPositionMm": float(piston_position_m * 1000.0),
             "pistonRatio": float(piston_ratio),  # Ratio 0..1 inside cylinder
             # Additional data for UI
             "corner": corner,
             "totalAngle": float(total_angle_deg),
             "baseAngle": float(base_angle_deg),
             "side": "left" if is_left else "right",
             "position": "front" if is_front else "rear",
         }
 
         # If cylinder_state provided, add full physics data
         if cylinder_state is not None:
             result["cylinderPhysics"] = {
                 "stroke": cylinder_state.stroke,
                 "strokeVelocity": cylinder_state.stroke_velocity,
                 "volumeHead": cylinder_state.volume_head,
                 "volumeRod": cylinder_state.volume_rod,
                 "distance": cylinder_state.distance,
                 "axisAngle": cylinder_state.cylinder_axis_angle,
             }
 
         return result
 
     def get_all_corners_3d(
         self,
         lever_angles: Optional[Dict[str, float]] = None,
@@ -325,153 +345,169 @@ class GeometryTo3DConverter(QObject):
         """
         # Extract lever angles from simulation
         lever_angles = {}
 
         if "lever_angles" in sim_state:
             lever_angles = sim_state["lever_angles"]
         else:
             # Extract from individual angle fields
             lever_angles = {
                 "fl": sim_state.get("fl_angle", 0.0),
                 "fr": sim_state.get("fr_angle", 0.0),
                 "rl": sim_state.get("rl_angle", 0.0),
                 "rr": sim_state.get("rr_angle", 0.0),
             }
 
         # Extract cylinder states (if available)
         cylinder_states = {}
         if "cylinder_states" in sim_state:
             cylinder_states = sim_state["cylinder_states"]
         elif "corners" in sim_state:
             # Try to extract from corners structure
             for corner, data in sim_state.get("corners", {}).items():
                 if "cylinder_state" in data:
                     cylinder_states[corner] = data["cylinder_state"]
 
+        user_params_m = {
+            "frameLength": self._frame_length,
+            "frameHeight": self._frame_height,
+            "frameBeamSize": self._frame_beam_size,
+            "leverLength": self._lever_length,
+            "cylinderBodyLength": self._cylinder_body_length,
+            "tailRodLength": self._tail_rod_length,
+        }
+
         return {
             "frame": self.get_frame_params(),
             "corners": self.get_all_corners_3d(lever_angles, cylinder_states),
-            # Add user-controllable parameters
-            "userParams": {
-                "frameLength": self._frame_length,
-                "frameHeight": self._frame_height,
-                "frameBeamSize": self._frame_beam_size,
-                "leverLength": self._lever_length,
-                "cylinderBodyLength": self._cylinder_body_length,
-                "tailRodLength": self._tail_rod_length,
-            },
+            "userParams": user_params_m,
+            "userParamsMeters": user_params_m,
         }
 
     def update_user_parameters(self, params: Dict[str, float], persist: bool = False):
         """Update multiple user parameters at once
 
         Args:
             params: Dictionary with parameter names and values
             persist: If True, persist changes to settings manager
         """
         changed = False
 
-        if "frameLength" in params and params["frameLength"] != self._frame_length:
-            self.frameLength = params["frameLength"]
+        frame_length = params.get("frameLengthM", params.get("frameLength"))
+        if frame_length is not None and frame_length != self._frame_length:
+            self.frameLength = float(frame_length)
             changed = True
 
-        if "frameHeight" in params and params["frameHeight"] != self._frame_height:
-            self.frameHeight = params["frameHeight"]
+        frame_height = params.get("frameHeightM", params.get("frameHeight"))
+        if frame_height is not None and frame_height != self._frame_height:
+            self.frameHeight = float(frame_height)
             changed = True
 
-        if (
-            "frameBeamSize" in params
-            and params["frameBeamSize"] != self._frame_beam_size
-        ):
-            self.frameBeamSize = params["frameBeamSize"]
+        beam_size = params.get("frameBeamSizeM", params.get("frameBeamSize"))
+        if beam_size is not None and beam_size != self._frame_beam_size:
+            self.frameBeamSize = float(beam_size)
             changed = True
 
-        if "leverLength" in params and params["leverLength"] != self._lever_length:
-            self.leverLength = params["leverLength"]
+        lever_length = params.get("leverLengthM", params.get("leverLength"))
+        if lever_length is not None and lever_length != self._lever_length:
+            self.leverLength = float(lever_length)
             changed = True
 
+        cylinder_length = params.get(
+            "cylinderBodyLengthM", params.get("cylinderBodyLength")
+        )
         if (
-            "cylinderBodyLength" in params
-            and params["cylinderBodyLength"] != self._cylinder_body_length
+            cylinder_length is not None
+            and cylinder_length != self._cylinder_body_length
         ):
-            self.cylinderBodyLength = params["cylinderBodyLength"]
+            self.cylinderBodyLength = float(cylinder_length)
             changed = True
 
-        if (
-            "tailRodLength" in params
-            and params["tailRodLength"] != self._tail_rod_length
-        ):
-            self.tailRodLength = params["tailRodLength"]
+        tail_length = params.get("tailRodLengthM", params.get("tailRodLength"))
+        if tail_length is not None and tail_length != self._tail_rod_length:
+            self.tailRodLength = float(tail_length)
             changed = True
 
-        if changed:
-            print(f"    GeometryBridge updated: {params}")
-
         # Persist changes to settings manager
         if persist:
             self.save_to_settings()
 
     def save_to_settings(self):
         """Save current geometry settings to persistent storage"""
-        # Collect settings data
-        settings_data = {
-            "frameLength": self._frame_length,
-            "frameHeight": self._frame_height,
-            "frameBeamSize": self._frame_beam_size,
-            "leverLength": self._lever_length,
-            "cylinderBodyLength": self._cylinder_body_length,
-            "tailRodLength": self._tail_rod_length,
-        }
-
-        # Update settings manager
-        SettingsManager.set_geometry_settings(settings_data)
+        if not self._settings_manager:
+            return
+
+        geometry_settings = self._settings_manager.get_category("geometry") or {}
+        geometry_settings.update(
+            {
+                "frame_length_m": self._frame_length,
+                "frame_height_m": self._frame_height,
+                "frame_beam_size_m": self._frame_beam_size,
+                "lever_length_m": self._lever_length,
+                "cylinder_body_length_m": self._cylinder_body_length,
+                "tail_rod_length_m": self._tail_rod_length,
+            }
+        )
 
-        print(f"    Geometry settings saved: {settings_data}")
+        self._settings_manager.set_category(
+            "geometry", geometry_settings, auto_save=True
+        )
 
     def export_geometry_params(self) -> Dict[str, Any]:
         """Export current geometry parameters as dictionary
 
         Returns:
             Dictionary with geometry parameters for export
         """
         return {
             "frameLength": self._frame_length,
             "frameHeight": self._frame_height,
             "frameBeamSize": self._frame_beam_size,
             "leverLength": self._lever_length,
             "cylinderBodyLength": self._cylinder_body_length,
             "tailRodLength": self._tail_rod_length,
         }
 
 
 # Convenience function for easy integration
 def create_geometry_converter(
     wheelbase: float = 2.0,
     lever_length: float = 0.315,
     cylinder_diameter: float = 0.08,
     settings_manager: Optional[Any] = None,
 ) -> GeometryTo3DConverter:
     """Create geometry converter with common parameters
 
     Args:
         wheelbase: Vehicle track width in meters
         lever_length: Suspension lever length in meters
         cylinder_diameter: Cylinder bore diameter in meters
         settings_manager: Optional SettingsManager instance for persistent settings
 
     Returns:
         Configured GeometryTo3DConverter
     """
     geometry = GeometryParams()
     geometry.wheelbase = wheelbase
     geometry.lever_length = lever_length
     geometry.cylinder_inner_diameter = cylinder_diameter
     geometry.enforce_track_from_geometry()  # Ensure consistency
 
-    converter = GeometryTo3DConverter(geometry)
+    manager = settings_manager or get_settings_manager()
+    converter = GeometryTo3DConverter(geometry, settings_manager=manager)
 
     # Load settings from manager if available
-    if settings_manager is not None:
-        settings = settings_manager.get_geometry_settings()
-        converter.update_user_parameters(settings, persist=False)
+    if manager is not None:
+        settings = manager.get_geometry_snapshot()
+        converter.update_user_parameters(
+            {
+                "frameLengthM": settings.get("frame_length_m"),
+                "frameHeightM": settings.get("frame_height_m"),
+                "frameBeamSizeM": settings.get("frame_beam_size_m"),
+                "leverLengthM": settings.get("lever_length_m"),
+                "cylinderBodyLengthM": settings.get("cylinder_body_length_m"),
+                "tailRodLengthM": settings.get("tail_rod_length_m"),
+            },
+            persist=False,
+        )
 
     return converter
diff --git a/src/ui/main_window/menu_actions.py b/src/ui/main_window/menu_actions.py
index 849f12158f4d90e2710af9aeb173f1129cf0145a..cb8690256778975f19adce320b1c4a3121a9281e 100644
--- a/src/ui/main_window/menu_actions.py
+++ b/src/ui/main_window/menu_actions.py
@@ -1,43 +1,45 @@
 """Menu Actions Module - Menu and toolbar action handlers
 
 Модуль обработчиков действий меню и панели инструментов.
 Содержит callback-функции для всех пунктов меню.
 
 Russian comments / English code.
 """
 from __future__ import annotations
 
 import logging
 import time
 from typing import TYPE_CHECKING
 
 from PySide6.QtCore import Slot
 
 if TYPE_CHECKING:
     from .main_window import MainWindow
 
+from .signals_router import SignalsRouter
+
 
 class MenuActions:
     """Обработчики действий меню и toolbar
 
     Содержит callback-функции для:
     - Управления файлами
     - Управления видом
     - Управления симуляцией
     - Обновления рендера
 
     Static methods для делегирования из MainWindow.
     """
 
     logger = logging.getLogger(__name__)
 
     # ------------------------------------------------------------------
     # File Menu Actions
     # ------------------------------------------------------------------
     @staticmethod
     def file_exit(window: MainWindow) -> None:
         """Exit application
 
         Args:
             window: MainWindow instance
         """
@@ -122,25 +124,46 @@ class MenuActions:
         except Exception:
             pass
 
         # Update queue statistics
         try:
             if hasattr(window.simulation_manager, "get_queue_stats"):
                 stats = window.simulation_manager.get_queue_stats()
                 get_c = stats.get("get_count", 0)
                 put_c = stats.get("put_count", 0)
 
                 if hasattr(window, "queue_label") and window.queue_label:
                     window.queue_label.setText(f"Queue: {get_c}/{put_c}")
         except Exception:
             if hasattr(window, "queue_label") and window.queue_label:
                 window.queue_label.setText("Queue: -/-")
 
         # Update snapshots
         try:
             if hasattr(window.simulation_manager, "get_snapshot_info"):
                 info = window.simulation_manager.get_snapshot_info()
                 if info and hasattr(window, "snapshot_label") and window.snapshot_label:
                     window.snapshot_label.setText(info)
         except Exception:
             if hasattr(window, "snapshot_label") and window.snapshot_label:
                 window.snapshot_label.setText("Snapshot: None")
+
+        # Fetch and push the latest snapshot to QML (SI units)
+        latest_snapshot = None
+        try:
+            if (
+                hasattr(window, "simulation_manager")
+                and window.simulation_manager is not None
+                and hasattr(window.simulation_manager, "get_latest_state")
+            ):
+                latest_snapshot = window.simulation_manager.get_latest_state()
+        except Exception as exc:
+            MenuActions.logger.debug(
+                "Latest snapshot retrieval failed: %s", exc, exc_info=exc
+            )
+
+        if latest_snapshot is not None:
+            window.current_snapshot = latest_snapshot
+
+        SignalsRouter._queue_simulation_update(
+            window, getattr(window, "current_snapshot", None)
+        )
diff --git a/src/ui/main_window/qml_bridge.py b/src/ui/main_window/qml_bridge.py
index 7b9c1950b973e03192991cd65f4768bbc57fc23c..015cf5e3646267699cfebb520b2ecd831778d695 100644
--- a/src/ui/main_window/qml_bridge.py
+++ b/src/ui/main_window/qml_bridge.py
@@ -24,50 +24,51 @@ class QMLBridge:
     - Вызовами QML функций
     - Батч-обновлениями
     - Очередью изменений
     - ACK сигналами
 
     Static methods для делегирования из MainWindow.
     """
 
     logger = logging.getLogger(__name__)
 
     # QML update method mapping
     QML_UPDATE_METHODS: Dict[str, tuple[str, ...]] = {
         "geometry": ("applyGeometryUpdates", "updateGeometry"),
         "animation": (
             "applyAnimationUpdates",
             "updateAnimation",
             "applyAnimParamsUpdates",
             "updateAnimParams",
         ),
         "lighting": ("applyLightingUpdates", "updateLighting"),
         "materials": ("applyMaterialUpdates", "updateMaterials"),
         "environment": ("applyEnvironmentUpdates", "updateEnvironment"),
         "quality": ("applyQualityUpdates", "updateQuality"),
         "camera": ("applyCameraUpdates", "updateCamera"),
         "effects": ("applyEffectsUpdates", "updateEffects"),
+        "simulation": ("applySimulationUpdates",),
     }
 
     # ------------------------------------------------------------------
     # Queue Management
     # ------------------------------------------------------------------
     @staticmethod
     def queue_update(window: MainWindow, key: str, params: Dict[str, Any]) -> None:
         """Поставить изменения в очередь для батч-отправки в QML
 
         Args:
             window: MainWindow instance
             key: Update category (geometry, lighting, etc.)
             params: Update parameters
         """
         if not params:
             return
 
         if key not in window._qml_update_queue:
             window._qml_update_queue[key] = {}
 
         QMLBridge._deep_merge_dicts(window._qml_update_queue[key], params)
 
         if not window._qml_flush_timer.isActive():
             window._qml_flush_timer.start(0)
 
diff --git a/src/ui/main_window/signals_router.py b/src/ui/main_window/signals_router.py
index 7bb530f9b5f83d6dba284f4695f9016d7efc8108..8749dc83f98c56dfd0b362617b388f8810a332f0 100644
--- a/src/ui/main_window/signals_router.py
+++ b/src/ui/main_window/signals_router.py
@@ -1,56 +1,144 @@
 """Signals Router Module - Signal connection and routing
 
 Модуль подключения и роутинга сигналов между компонентами.
 Управляет всеми сигнально-слотовыми соединениями главного окна.
 
 Russian comments / English code.
 """
 from __future__ import annotations
 
 import logging
-from typing import TYPE_CHECKING, Any, Dict
+from typing import TYPE_CHECKING, Any, Dict, Optional
 
 from PySide6.QtCore import Qt
 
+from ...pneumo.enums import Line, Wheel
+from .qml_bridge import QMLBridge
+
 if TYPE_CHECKING:
     from .main_window import MainWindow
     from ...runtime import StateSnapshot
 
 
 class SignalsRouter:
     """Роутер сигналов главного окна
 
     Управляет:
     - Подключением сигналов панелей
     - Роутингом сигналов симуляции
     - Обработчиками событий UI
 
     Static methods для делегирования из MainWindow.
     """
 
     logger = logging.getLogger(__name__)
+    _WHEEL_KEY_MAP = {
+        Wheel.LP: "fl",
+        Wheel.PP: "fr",
+        Wheel.LZ: "rl",
+        Wheel.PZ: "rr",
+    }
+
+    @staticmethod
+    def _build_simulation_payload(snapshot: "StateSnapshot") -> Dict[str, Any]:
+        if snapshot is None:
+            return {}
+
+        levers: Dict[str, float] = {}
+        pistons: Dict[str, float] = {}
+        for wheel_enum, state in snapshot.wheels.items():
+            corner = SignalsRouter._WHEEL_KEY_MAP.get(wheel_enum)
+            if not corner:
+                continue
+            levers[corner] = float(state.lever_angle)
+            pistons[corner] = float(state.piston_position)
+
+        lines: Dict[str, Dict[str, Any]] = {}
+        for line_enum, line_state in snapshot.lines.items():
+            lines[line_enum.value] = {
+                "pressure": float(line_state.pressure),
+                "temperature": float(line_state.temperature),
+                "flowAtmo": float(line_state.flow_atmo),
+                "flowTank": float(line_state.flow_tank),
+                "cvAtmoOpen": bool(line_state.cv_atmo_open),
+                "cvTankOpen": bool(line_state.cv_tank_open),
+            }
+
+        aggregates = snapshot.aggregates
+        aggregates_payload = {
+            "kineticEnergy": float(aggregates.kinetic_energy),
+            "potentialEnergy": float(aggregates.potential_energy),
+            "pneumaticEnergy": float(aggregates.pneumatic_energy),
+            "totalFlowIn": float(aggregates.total_flow_in),
+            "totalFlowOut": float(aggregates.total_flow_out),
+            "netFlow": float(aggregates.net_flow),
+            "physicsStepTime": float(aggregates.physics_step_time),
+            "integrationSteps": int(aggregates.integration_steps),
+            "integrationFailures": int(aggregates.integration_failures),
+            "stepNumber": int(snapshot.step_number),
+            "simulationTime": float(snapshot.simulation_time),
+        }
+
+        frame_state = snapshot.frame
+        frame_payload = {
+            "heave": float(frame_state.heave),
+            "roll": float(frame_state.roll),
+            "pitch": float(frame_state.pitch),
+            "heaveRate": float(frame_state.heave_rate),
+            "rollRate": float(frame_state.roll_rate),
+            "pitchRate": float(frame_state.pitch_rate),
+        }
+
+        tank_state = snapshot.tank
+        tank_payload = {
+            "pressure": float(tank_state.pressure),
+            "temperature": float(tank_state.temperature),
+            "volume": float(tank_state.volume),
+        }
+
+        return {
+            "levers": levers,
+            "pistons": pistons,
+            "lines": lines,
+            "aggregates": aggregates_payload,
+            "frame": frame_payload,
+            "tank": tank_payload,
+            "masterIsolationOpen": bool(snapshot.master_isolation_open),
+            "thermoMode": snapshot.thermo_mode,
+        }
+
+    @staticmethod
+    def _queue_simulation_update(
+        window: "MainWindow", snapshot: Optional["StateSnapshot"]
+    ) -> None:
+        if snapshot is None:
+            return
+
+        payload = SignalsRouter._build_simulation_payload(snapshot)
+        if payload:
+            QMLBridge.queue_update(window, "simulation", payload)
 
     # ------------------------------------------------------------------
     # Setup Connections
     # ------------------------------------------------------------------
     @staticmethod
     def connect_all_signals(window: MainWindow) -> None:
         """Подключить все сигналы окна
 
         Args:
             window: MainWindow instance
         """
         SignalsRouter._connect_panel_signals(window)
         SignalsRouter._connect_simulation_signals(window)
         SignalsRouter._connect_qml_signals(window)
 
         SignalsRouter.logger.info("✅ Все сигналы подключены")
 
     @staticmethod
     def _connect_panel_signals(window: MainWindow) -> None:
         """Подключить сигналы панелей к обработчикам
 
         Args:
             window: MainWindow instance
         """
         # Geometry panel
@@ -255,72 +343,88 @@ class SignalsRouter:
     @staticmethod
     def handle_animation_changed(window: MainWindow, params: Dict[str, Any]) -> None:
         """Handle animation changes from ModesPanel"""
         if not isinstance(params, dict):
             return
 
         from .qml_bridge import QMLBridge
 
         if not QMLBridge.invoke_qml_function(window, "applyAnimationUpdates", params):
             QMLBridge.queue_update(window, "animation", params)
             QMLBridge._log_graphics_change(window, "animation", params, applied=False)
         else:
             QMLBridge._log_graphics_change(window, "animation", params, applied=True)
 
     # ------------------------------------------------------------------
     # Signal Handlers - Simulation
     # ------------------------------------------------------------------
     @staticmethod
     def handle_state_update(window: MainWindow, snapshot: StateSnapshot) -> None:
         """Handle simulation state update
 
         Args:
             window: MainWindow instance
             snapshot: Current simulation state
         """
-        window.current_snapshot = snapshot
+        latest_snapshot: Optional[StateSnapshot] = snapshot
 
         try:
-            if snapshot:
+            if (
+                hasattr(window, "simulation_manager")
+                and window.simulation_manager is not None
+                and hasattr(window.simulation_manager, "get_latest_state")
+            ):
+                fresh_snapshot = window.simulation_manager.get_latest_state()
+                if fresh_snapshot is not None:
+                    latest_snapshot = fresh_snapshot
+        except Exception as exc:
+            SignalsRouter.logger.debug(
+                "Failed to fetch latest snapshot: %s", exc, exc_info=exc
+            )
+
+        window.current_snapshot = latest_snapshot
+
+        try:
+            if latest_snapshot:
                 # Update status bar metrics
                 window.sim_time_label.setText(
-                    f"Sim Time: {snapshot.simulation_time:.3f}s"
+                    f"Sim Time: {latest_snapshot.simulation_time:.3f}s"
+                )
+                window.step_count_label.setText(
+                    f"Steps: {latest_snapshot.step_number}"
                 )
-                window.step_count_label.setText(f"Steps: {snapshot.step_number}")
 
-                if snapshot.aggregates.physics_step_time > 0:
-                    fps = 1.0 / snapshot.aggregates.physics_step_time
+                if latest_snapshot.aggregates.physics_step_time > 0:
+                    fps = 1.0 / latest_snapshot.aggregates.physics_step_time
                     window.fps_label.setText(f"Physics FPS: {fps:.1f}")
 
             # Update charts
             if window.chart_widget:
-                window.chart_widget.update_from_snapshot(snapshot)
-
-            # Push state to QML
-            from .qml_bridge import QMLBridge
+                window.chart_widget.update_from_snapshot(latest_snapshot)
 
-            QMLBridge.set_simulation_state(window, snapshot)
+            # Push state to QML (meters/pascals/radians)
+            SignalsRouter._queue_simulation_update(window, latest_snapshot)
         except Exception as e:
             SignalsRouter.logger.error(f"State update error: {e}")
 
     @staticmethod
     def handle_physics_error(window: MainWindow, message: str) -> None:
         """Handle physics engine error
 
         Args:
             window: MainWindow instance
             message: Error message
         """
         SignalsRouter.logger.error(f"Physics engine error: {message}")
 
         if hasattr(window, "status_bar") and window.status_bar:
             window.status_bar.showMessage(f"Physics error: {message}", 5000)
 
     # ------------------------------------------------------------------
     # Signal Handlers - Simulation Control
     # ------------------------------------------------------------------
     @staticmethod
     def handle_sim_control(window: MainWindow, command: str) -> None:
         """Handle simulation control command
 
         Args:
             window: MainWindow instance
diff --git a/tests/ui/test_simulation_state_updates.py b/tests/ui/test_simulation_state_updates.py
new file mode 100644
index 0000000000000000000000000000000000000000..ff32fb4a716c1a1675e4e00aa166ed030ff3d73e
--- /dev/null
+++ b/tests/ui/test_simulation_state_updates.py
@@ -0,0 +1,139 @@
+import importlib.util
+import pathlib
+import sys
+import types
+from types import SimpleNamespace
+
+import pytest
+
+from src.pneumo.enums import Line, Wheel
+from src.runtime.state import LineState, StateSnapshot
+
+_signals_module_name = "src.ui.main_window.signals_router"
+if _signals_module_name in sys.modules:
+    signals_router = sys.modules[_signals_module_name]
+else:
+    module_path = (
+        pathlib.Path(__file__).resolve().parents[2]
+        / "src"
+        / "ui"
+        / "main_window"
+        / "signals_router.py"
+    )
+
+    spec = importlib.util.spec_from_file_location(
+        _signals_module_name, module_path
+    )
+    signals_router = importlib.util.module_from_spec(spec)
+
+    if "src.ui" not in sys.modules:
+        sys.modules["src.ui"] = types.ModuleType("src.ui")
+        sys.modules["src.ui"].__path__ = [str(module_path.parent.parent)]
+
+    if "src.ui.main_window" not in sys.modules:
+        sys.modules["src.ui.main_window"] = types.ModuleType("src.ui.main_window")
+        sys.modules["src.ui.main_window"].__path__ = [str(module_path.parent)]
+
+    sys.modules[_signals_module_name] = signals_router
+    assert spec.loader is not None
+    spec.loader.exec_module(signals_router)
+
+
+class DummyLabel:
+    def __init__(self):
+        self.text = ""
+
+    def setText(self, value: str) -> None:
+        self.text = value
+
+
+class DummyChart:
+    def __init__(self):
+        self.last_snapshot = None
+
+    def update_from_snapshot(self, snapshot):
+        self.last_snapshot = snapshot
+
+
+class DummyQmlRoot:
+    def __init__(self):
+        self._props = {"isRunning": False, "animationTime": 0.0}
+
+    def property(self, name):
+        return self._props.get(name)
+
+    def setProperty(self, name, value):
+        self._props[name] = value
+
+
+class DummySimulationManager:
+    def __init__(self, snapshots):
+        self._snapshots = list(snapshots)
+
+    def get_latest_state(self):
+        if self._snapshots:
+            return self._snapshots.pop(0)
+        return None
+
+    def get_queue_stats(self):
+        return {"get_count": 0, "put_count": 0}
+
+    def get_snapshot_info(self):
+        return "Snapshot: 1"
+
+
+def _make_snapshot(lever_value: float, piston_value: float, pressure: float) -> StateSnapshot:
+    snapshot = StateSnapshot()
+    snapshot.simulation_time = 1.23
+    snapshot.step_number = 42
+    snapshot.aggregates.physics_step_time = 0.01
+
+    for wheel in snapshot.wheels.values():
+        wheel.lever_angle = lever_value
+        wheel.piston_position = piston_value
+
+    snapshot.lines[Line.A1] = LineState(
+        line=Line.A1,
+        pressure=pressure,
+        temperature=300.0,
+        flow_atmo=0.1,
+        flow_tank=0.2,
+    )
+
+    return snapshot
+
+
+def test_handle_state_update_queues_si_payload(monkeypatch):
+    initial_snapshot = _make_snapshot(0.05, 0.02, 120000.0)
+    fresh_snapshot = _make_snapshot(0.12, 0.045, 150000.0)
+
+    queued = []
+
+    def fake_queue_update(window, key, payload):
+        queued.append((key, payload))
+
+    monkeypatch.setattr(
+        signals_router.QMLBridge,
+        "queue_update",
+        staticmethod(fake_queue_update),
+    )
+
+    window = SimpleNamespace(
+        sim_time_label=DummyLabel(),
+        step_count_label=DummyLabel(),
+        fps_label=DummyLabel(),
+        chart_widget=DummyChart(),
+        simulation_manager=DummySimulationManager([fresh_snapshot]),
+        _qml_root_object=DummyQmlRoot(),
+    )
+
+    signals_router.SignalsRouter.handle_state_update(window, initial_snapshot)
+
+    assert queued, "Expected simulation payload to be queued"
+    key, payload = queued[-1]
+    assert key == "simulation"
+
+    assert pytest.approx(payload["levers"]["fl"]) == fresh_snapshot.wheels[Wheel.LP].lever_angle
+    assert pytest.approx(payload["pistons"]["fl"]) == fresh_snapshot.wheels[Wheel.LP].piston_position
+    assert pytest.approx(payload["lines"]["A1"]["pressure"]) == fresh_snapshot.lines[Line.A1].pressure
+    assert pytest.approx(payload["aggregates"]["physicsStepTime"]) == fresh_snapshot.aggregates.physics_step_time
diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index c5d0327ee946d0fa606d81f664d81e20f47830b2..52659f4bf556b6a455de4817dbc1f0de9cbad80a 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -1,51 +1,51 @@
 # Pre-commit hooks для PneumoStabSim Professional
 # Установка: pip install pre-commit && pre-commit install
 
 repos:
  # Black - форматирование Python кода
  - repo: https://github.com/psf/black
    rev: 23.12.1
    hooks:
      - id: black
-       language_version: python3.13
+       language_version: python3.12
        args: ['--line-length=88']
 
  # Flake8 - проверка стиля кода (только src/, app.py и tools/)
  - repo: https://github.com/pycqa/flake8
    rev: 7.0.0
    hooks:
      - id: flake8
        args: ['--max-line-length=88', '--extend-ignore=E203,W503']
        files: '^(app\.py|src/|tools/)'
 
  # MyPy - статическая типизация (только src/, app.py и tools/)
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.8.0
    hooks:
      - id: mypy
-       args: ['--ignore-missing-imports', '--python-version=3.13']
+       args: ['--ignore-missing-imports', '--python-version=3.12']
        files: '^(app\.py|src/|tools/)'
 
  # Ruff - быстрая проверка кода (только src/, app.py и tools/)
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.11
    hooks:
      - id: ruff
        args: ['--fix', '--exit-non-zero-on-fix']
        files: '^(app\.py|src/|tools/)'
 
  # Базовые проверки
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-added-large-files
        args: ['--maxkb=5000']
      - id: check-case-conflict
      - id: check-merge-conflict
      - id: detect-private-key
      - id: mixed-line-ending
        args: ['--fix=crlf']
diff --git a/tools/check_ui_utf8.py b/tools/check_ui_utf8.py
index c23fd791bcf0f7bc8d08c052e5e1449644829bd4..07f702070f87b67b4c77e6cd693c4403b0a209eb 100644
--- a/tools/check_ui_utf8.py
+++ b/tools/check_ui_utf8.py
@@ -1,86 +1,52 @@
-# Veja a descrição de que forma o código foi alterado e aplique as mudanças no arquivo referente a `tools\check_ui_utf8.py`.
+"""Pre-commit hook to ensure UI-related files are UTF-8 encoded."""
 
-#!/usr/bin/env python3
-"""Ensure all UI files decode as UTF-8 without errors."""
 from __future__ import annotations
 
-import argparse
-import os
 import sys
 from pathlib import Path
-from typing import Iterable, Sequence
 
-DEFAULT_EXTENSIONS = {".py", ".qml", ".ui"}
-DEFAULT_ROOTS = (Path("src/ui"),)
 
+ROOT_DIR = Path(__file__).resolve().parent.parent
+TARGET_DIRECTORIES = ("src", "assets", "docs")
+TARGET_EXTENSIONS = {".py", ".qml", ".md"}
 
-def iter_ui_files(roots: Sequence[Path], extensions: Iterable[str]) -> Iterable[Path]:
-    normalized_exts = {ext if ext.startswith(".") else f".{ext}" for ext in extensions}
-    for root in roots:
-        if not root.exists():
+
+def _iter_target_files() -> list[Path]:
+    files: list[Path] = []
+    for directory in TARGET_DIRECTORIES:
+        dir_path = ROOT_DIR / directory
+        if not dir_path.exists():
             continue
-        for path in root.rglob("*"):
-            if path.is_file() and path.suffix.lower() in normalized_exts:
-                yield path
-
-
-def check_utf8(paths: Sequence[Path]) -> list[str]:
-    errors: list[str] = []
-    for path in paths:
-        try:
-            with path.open("r", encoding="utf-8") as handle:
-                handle.read()
-        except UnicodeDecodeError as exc:
-            errors.append(f"{path}: {exc}")
-    return errors
-
-
-def parse_args(argv: Sequence[str]) -> argparse.Namespace:
-    parser = argparse.ArgumentParser(description=__doc__)
-    parser.add_argument(
-        "roots",
-        metavar="ROOT",
-        nargs="*",
-        type=Path,
-        default=list(DEFAULT_ROOTS),
-        help="Directories to scan (default: src/ui)",
-    )
-    parser.add_argument(
-        "--ext",
-        dest="extensions",
-        action="append",
-        default=list(DEFAULT_EXTENSIONS),
-        help="File extensions to validate (default: .py, .qml, .ui)",
-    )
-    return parser.parse_args(argv)
-
-
-def main(argv: Sequence[str] | None = None) -> int:
-    args = parse_args(sys.argv[1:] if argv is None else argv)
-    roots = [root if root.is_absolute() else Path.cwd() / root for root in args.roots]
-    extensions = args.extensions or list(DEFAULT_EXTENSIONS)
-
-    ui_files = list(iter_ui_files(roots, extensions))
-    errors = check_utf8(ui_files)
-
-    # Исправление вывода символов в Windows-консоли
+
+        for path in dir_path.rglob("*"):
+            if path.is_file() and path.suffix.lower() in TARGET_EXTENSIONS:
+                files.append(path)
+
+    return files
+
+
+def _check_file(path: Path) -> bool:
     try:
-        # Устанавливаем кодировку консоли на UTF-8
-        if os.name == "nt":
-            sys.stdout.reconfigure(encoding="utf-8")
-
-        if errors:
-            print("❌ UTF-8 validation failed for the following files:")
-            for error in errors:
-                print(f"  - {error}")
-            return 1
-
-        print(f"✅ UTF-8 validation passed for {len(ui_files)} UI files.")
-        return 0
-    except Exception as e:
-        print(f"Ошибка: {e}")
+        path.read_text(encoding="utf-8")
+    except UnicodeDecodeError:
+        return False
+    except OSError:
+        # Treat IO errors as failures so they are surfaced to the user.
+        return False
+    return True
+
+
+def main() -> int:
+    invalid_files = [path for path in _iter_target_files() if not _check_file(path)]
+
+    if invalid_files:
+        print("Found files with invalid UTF-8 encoding:")
+        for path in invalid_files:
+            print(f" - {path.relative_to(ROOT_DIR)}")
         return 1
 
+    return 0
+
 
 if __name__ == "__main__":
     sys.exit(main())
     diff --git a/assets/qml/main.qml.backup_20251018_124153 b/archive/old_qml/main_variants/main.qml.backup_20251018_124153
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124153
rename to archive/old_qml/main_variants/main.qml.backup_20251018_124153
diff --git a/assets/qml/main.qml.backup_20251018_124320 b/archive/old_qml/main_variants/main.qml.backup_20251018_124320
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124320
rename to archive/old_qml/main_variants/main.qml.backup_20251018_124320
diff --git a/assets/qml/main.qml.backup_before_cleanup b/archive/old_qml/main_variants/main.qml.backup_before_cleanup
similarity index 100%
rename from assets/qml/main.qml.backup_before_cleanup
rename to archive/old_qml/main_variants/main.qml.backup_before_cleanup
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_124412 b/archive/old_qml/main_variants/main.qml.backup_cleanup_20251018_124412
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_124412
rename to archive/old_qml/main_variants/main.qml.backup_cleanup_20251018_124412
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_164914 b/archive/old_qml/main_variants/main.qml.backup_cleanup_20251018_164914
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_164914
rename to archive/old_qml/main_variants/main.qml.backup_cleanup_20251018_164914
diff --git a/assets/qml/main.qml.backup_geometry b/archive/old_qml/main_variants/main.qml.backup_geometry
similarity index 100%
rename from assets/qml/main.qml.backup_geometry
rename to archive/old_qml/main_variants/main.qml.backup_geometry
diff --git a/assets/qml/main.qml.backup_uframe_20251018_164939 b/archive/old_qml/main_variants/main.qml.backup_uframe_20251018_164939
similarity index 100%
rename from assets/qml/main.qml.backup_uframe_20251018_164939
rename to archive/old_qml/main_variants/main.qml.backup_uframe_20251018_164939
diff --git a/assets/qml/main.qml.rej b/archive/old_qml/main_variants/main.qml.rej
similarity index 100%
rename from assets/qml/main.qml.rej
rename to archive/old_qml/main_variants/main.qml.rej
diff --git a/assets/qml/main_backup.qml b/archive/old_qml/main_variants/main_backup.qml
similarity index 100%
rename from assets/qml/main_backup.qml
rename to archive/old_qml/main_variants/main_backup.qml
diff --git a/assets/qml/main_backup_canvas.qml b/archive/old_qml/main_variants/main_backup_canvas.qml
similarity index 100%
rename from assets/qml/main_backup_canvas.qml
rename to archive/old_qml/main_variants/main_backup_canvas.qml
diff --git a/assets/qml/main_optimized_stub.qml b/archive/old_qml/main_variants/main_optimized_stub.qml
similarity index 100%
rename from assets/qml/main_optimized_stub.qml
rename to archive/old_qml/main_variants/main_optimized_stub.qml
diff --git a/assets/qml/main_stub.qml b/archive/old_qml/main_variants/main_stub.qml
similarity index 100%
rename from assets/qml/main_stub.qml
rename to archive/old_qml/main_variants/main_stub.qml
diff --git a/src/ui/main_window/ui_setup.py b/src/ui/main_window/ui_setup.py
index eee5908c0723993ff66a8c0055acbbd9b9bcce15..255a44f6473d86157172d548e976463b6ebdae81 100644
--- a/src/ui/main_window/ui_setup.py
+++ b/src/ui/main_window/ui_setup.py
@@ -1,64 +1,72 @@
 """UI Setup Module - MainWindow UI construction
 
 Модуль построения UI элементов главного окна.
 Отвечает за создание всех виджетов, сплиттеров, панелей и их расположение.
 
 Russian UI / English code.
 """
 from __future__ import annotations
 
 import logging
+import os
 from pathlib import Path
 from typing import TYPE_CHECKING
 
 from PySide6.QtCore import Qt, QSettings, QUrl
 from PySide6.QtWidgets import (
     QLabel,
     QScrollArea,
     QSplitter,
     QStatusBar,
     QTabWidget,
     QVBoxLayout,
     QWidget,
 )
 from PySide6.QtQuickWidgets import QQuickWidget
 from PySide6.QtGui import QAction, QKeySequence
 
 if TYPE_CHECKING:
     from .main_window import MainWindow
 
 
 class UISetup:
     """Построение UI элементов главного окна
 
     Static methods для делегирования из MainWindow.
     Каждый метод принимает `window: MainWindow` как первый аргумент.
     """
 
     logger = logging.getLogger(__name__)
 
+    _SUPPORTED_SCENES: dict[str, Path] = {
+        "main": Path("assets/qml/main.qml"),
+        "fallback": Path("assets/qml/main_fallback.qml"),
+    }
+    _SCENE_LOAD_ORDER: tuple[str, ...] = ("main", "fallback")
+    _SCENE_ENV_VAR = "PSS_QML_SCENE"
+
     # ------------------------------------------------------------------
     # Central Widget Setup
     # ------------------------------------------------------------------
     @staticmethod
     def setup_central(window: MainWindow) -> None:
         """Создать центральный вид с горизонтальным и вертикальным сплиттерами
 
         Layout: [3D Scene (top) + Charts (bottom)] | [Control Panels (right)]
 
         Args:
             window: MainWindow instance
         """
         UISetup.logger.debug("setup_central: Создание системы сплиттеров...")
 
         # Create main horizontal splitter (left: scene+charts, right: panels)
         window.main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal)
         window.main_horizontal_splitter.setObjectName("MainHorizontalSplitter")
 
         # Create vertical splitter for left side (scene + charts)
         window.main_splitter = QSplitter(Qt.Orientation.Vertical)
         window.main_splitter.setObjectName("SceneChartsSplitter")
 
         # Top section: 3D scene
         if window.use_qml_3d:
             UISetup._setup_qml_3d_view(window)
@@ -103,96 +111,159 @@ class UISetup:
             window._qquick_widget.setResizeMode(
                 QQuickWidget.ResizeMode.SizeRootObjectToView
             )
 
             # Get QML engine
             engine = window._qquick_widget.engine()
 
             # ✅ КРИТИЧЕСКОЕ: Устанавливаем контекст ДО загрузки QML
             context = engine.rootContext()
             context.setContextProperty("window", window)
             UISetup.logger.info("    ✅ Window context registered")
 
             # Import paths
             from PySide6.QtCore import QLibraryInfo
 
             qml_import_path = QLibraryInfo.path(
                 QLibraryInfo.LibraryPath.Qml2ImportsPath
             )
             engine.addImportPath(str(qml_import_path))
 
             local_qml_path = Path("assets/qml")
             if local_qml_path.exists():
                 engine.addImportPath(str(local_qml_path.absolute()))
 
             # Load QML file
-            qml_file = Path("assets/qml/main.qml")
+            qml_file = UISetup._resolve_supported_qml_scene()
             if not qml_file.exists():
                 raise FileNotFoundError(f"QML file not found: {qml_file}")
 
             qml_url = QUrl.fromLocalFile(str(qml_file.absolute()))
             window._qquick_widget.setSource(qml_url)
 
             # Check status
             status = window._qquick_widget.status()
             if status == QQuickWidget.Status.Error:
                 errors = window._qquick_widget.errors()
                 error_msg = "\n".join(str(e) for e in errors)
                 raise RuntimeError(f"QML load errors:\n{error_msg}")
 
             # Get root object
             window._qml_root_object = window._qquick_widget.rootObject()
             if not window._qml_root_object:
                 raise RuntimeError("Failed to get QML root object")
 
             # Store base directory
             window._qml_base_dir = qml_file.parent.resolve()
 
-            UISetup.logger.info("    ✅ main.qml loaded successfully")
+            UISetup.logger.info(
+                "    ✅ %s loaded successfully", qml_file.name
+            )
 
         except Exception as e:
             UISetup.logger.exception(f"    ❌ QML load failed: {e}")
 
             # Fallback: error label
             fallback = QLabel(
                 f"КРИТИЧЕСКАЯ ОШИБКА ЗАГРУЗКИ 3D СЦЕНЫ\n\n"
                 f"Ошибка: {e}\n\n"
                 f"Проверьте файл assets/qml/main.qml"
             )
             fallback.setAlignment(Qt.AlignmentFlag.AlignCenter)
             fallback.setStyleSheet(
                 "background: #1a1a2e; color: #ff6b6b; "
                 "font-size: 12px; padding: 20px;"
             )
             window._qquick_widget = fallback
 
     @staticmethod
     def _setup_legacy_opengl_view(window: MainWindow) -> None:
         """Setup legacy OpenGL widget (stub)"""
         UISetup.logger.debug("_setup_legacy_opengl_view: Fallback to QML")
         UISetup._setup_qml_3d_view(window)
 
+    @staticmethod
+    def _normalize_scene_key(value: str) -> str:
+        key = value.strip().lower().replace("-", "_")
+        if key.endswith(".qml"):
+            key = key[:-4]
+        if key.startswith("main.") and key != "main":
+            key = key.split(".", 1)[0]
+        if key.startswith("main_") and key != "main":
+            key = key[len("main_") :]
+        return key
+
+    @staticmethod
+    def _resolve_supported_qml_scene() -> Path:
+        """Resolve which QML scene should be loaded."""
+
+        requested = os.environ.get(UISetup._SCENE_ENV_VAR)
+        load_order = list(UISetup._SCENE_LOAD_ORDER)
+
+        if requested:
+            normalized = UISetup._normalize_scene_key(requested)
+            if normalized in UISetup._SUPPORTED_SCENES:
+                load_order = [normalized] + [
+                    name for name in load_order if name != normalized
+                ]
+                UISetup.logger.info(
+                    "    [QML] Requested scene via %s: %s",
+                    UISetup._SCENE_ENV_VAR,
+                    UISetup._SUPPORTED_SCENES[normalized].name,
+                )
+            else:
+                UISetup.logger.warning(
+                    "    [QML] Unsupported scene '%s' requested via %s. "
+                    "Allowed: %s",
+                    requested,
+                    UISetup._SCENE_ENV_VAR,
+                    ", ".join(
+                        UISetup._SUPPORTED_SCENES[name].name
+                        for name in UISetup._SCENE_LOAD_ORDER
+                    ),
+                )
+
+        for scene_key in load_order:
+            scene_path = UISetup._SUPPORTED_SCENES[scene_key]
+            if scene_path.exists():
+                UISetup.logger.info(
+                    "    [QML] Загрузка сцены: %s", scene_path.name
+                )
+                return scene_path
+            UISetup.logger.debug(
+                "    [QML] Scene %s not found at %s",
+                scene_key,
+                scene_path,
+            )
+
+        searched = ", ".join(
+            str(UISetup._SUPPORTED_SCENES[key]) for key in UISetup._SCENE_LOAD_ORDER
+        )
+        raise FileNotFoundError(
+            "No supported QML scenes found. Checked: " + searched
+        )
+
     # ------------------------------------------------------------------
     # Tabs Setup
     # ------------------------------------------------------------------
     @staticmethod
     def setup_tabs(window: MainWindow) -> None:
         """Создать вкладки с панелями параметров
 
         Tabs:
           - Геометрия (Geometry)
           - Пневмосистема (Pneumatics)
           - Режимы стабилизатора (Modes)
           - Графика (Graphics)
           - Динамика движения (Road - stub)
 
         Args:
             window: MainWindow instance
         """
         UISetup.logger.debug("setup_tabs: Создание вкладок...")
 
         # Create tab widget
         window.tab_widget = QTabWidget(window)
         window.tab_widget.setObjectName("ParameterTabs")
         window.tab_widget.setMinimumWidth(300)
         window.tab_widget.setMaximumWidth(800)
 
diff --git a/tools/check_repo_health.py b/tools/check_repo_health.py
new file mode 100644
index 0000000000000000000000000000000000000000..6fa098cdbe6998a943be5b28379098e4d66d6f16
--- /dev/null
+++ b/tools/check_repo_health.py
@@ -0,0 +1,66 @@
+"""Repository health checks for stray files."""
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+
+
+REPO_ROOT = Path(__file__).resolve().parents[1]
+SKIP_DIRS = {
+    "archive",
+    ".git",
+    "__pycache__",
+    ".pytest_cache",
+    ".mypy_cache",
+    "venv",
+    ".venv",
+    "dist",
+    "build",
+}
+
+
+def _is_skipped(path: Path) -> bool:
+    try:
+        relative_parts = path.relative_to(REPO_ROOT).parts
+    except ValueError:
+        return False
+    return any(part in SKIP_DIRS for part in relative_parts)
+
+
+def _collect_problem_files() -> list[Path]:
+    problems: list[Path] = []
+    for entry in REPO_ROOT.rglob("*"):
+        if not entry.is_file():
+            continue
+        if _is_skipped(entry):
+            continue
+
+        name = entry.name
+        if name.endswith(".rej"):
+            problems.append(entry)
+            continue
+
+        if name.endswith(".qml") and "_backup" in entry.stem:
+            problems.append(entry)
+            continue
+
+        if ".qml.backup" in name:
+            problems.append(entry)
+
+    return problems
+
+
+def main() -> int:
+    problems = _collect_problem_files()
+    if problems:
+        print("❌ Repository health check failed. Remove or archive the following files:")
+        for path in problems:
+            print(f"  - {path.relative_to(REPO_ROOT)}")
+        return 1
+
+    print("✅ Repository health check passed: no stray .rej or backup QML files detected.")
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/assets/qml/main.qml.backup_20251018_124153 b/archive/old_qml/backups/main.qml.backup_20251018_124153
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124153
rename to archive/old_qml/backups/main.qml.backup_20251018_124153
diff --git a/assets/qml/main.qml.backup_20251018_124320 b/archive/old_qml/backups/main.qml.backup_20251018_124320
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124320
rename to archive/old_qml/backups/main.qml.backup_20251018_124320
diff --git a/assets/qml/main.qml.backup_before_cleanup b/archive/old_qml/backups/main.qml.backup_before_cleanup
similarity index 100%
rename from assets/qml/main.qml.backup_before_cleanup
rename to archive/old_qml/backups/main.qml.backup_before_cleanup
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_124412 b/archive/old_qml/backups/main.qml.backup_cleanup_20251018_124412
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_124412
rename to archive/old_qml/backups/main.qml.backup_cleanup_20251018_124412
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_164914 b/archive/old_qml/backups/main.qml.backup_cleanup_20251018_164914
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_164914
rename to archive/old_qml/backups/main.qml.backup_cleanup_20251018_164914
diff --git a/assets/qml/main.qml.backup_geometry b/archive/old_qml/backups/main.qml.backup_geometry
similarity index 100%
rename from assets/qml/main.qml.backup_geometry
rename to archive/old_qml/backups/main.qml.backup_geometry
diff --git a/assets/qml/main.qml.backup_uframe_20251018_164939 b/archive/old_qml/backups/main.qml.backup_uframe_20251018_164939
similarity index 100%
rename from assets/qml/main.qml.backup_uframe_20251018_164939
rename to archive/old_qml/backups/main.qml.backup_uframe_20251018_164939
diff --git a/assets/qml/main.qml.rej b/archive/old_qml/backups/main.qml.rej
similarity index 100%
rename from assets/qml/main.qml.rej
rename to archive/old_qml/backups/main.qml.rej
diff --git a/assets/qml/main_backup.qml b/archive/old_qml/backups/main_backup.qml
similarity index 100%
rename from assets/qml/main_backup.qml
rename to archive/old_qml/backups/main_backup.qml
diff --git a/assets/qml/main_backup_canvas.qml b/archive/old_qml/backups/main_backup_canvas.qml
similarity index 100%
rename from assets/qml/main_backup_canvas.qml
rename to archive/old_qml/backups/main_backup_canvas.qml
diff --git a/assets/qml/main_optimized_stub.qml b/archive/old_qml/backups/main_optimized_stub.qml
similarity index 100%
rename from assets/qml/main_optimized_stub.qml
rename to archive/old_qml/backups/main_optimized_stub.qml
diff --git a/assets/qml/main_stub.qml b/archive/old_qml/backups/main_stub.qml
similarity index 100%
rename from assets/qml/main_stub.qml
rename to archive/old_qml/backups/main_stub.qml
diff --git a/src/ui/main_window/ui_setup.py b/src/ui/main_window/ui_setup.py
index eee5908c0723993ff66a8c0055acbbd9b9bcce15..2ed69584bbf4ddee8b264fe5c62e7cf4ede25c1c 100644
--- a/src/ui/main_window/ui_setup.py
+++ b/src/ui/main_window/ui_setup.py
@@ -1,35 +1,36 @@
 """UI Setup Module - MainWindow UI construction
 
 Модуль построения UI элементов главного окна.
 Отвечает за создание всех виджетов, сплиттеров, панелей и их расположение.
 
 Russian UI / English code.
 """
 from __future__ import annotations
 
 import logging
+import os
 from pathlib import Path
 from typing import TYPE_CHECKING
 
 from PySide6.QtCore import Qt, QSettings, QUrl
 from PySide6.QtWidgets import (
     QLabel,
     QScrollArea,
     QSplitter,
     QStatusBar,
     QTabWidget,
     QVBoxLayout,
     QWidget,
 )
 from PySide6.QtQuickWidgets import QQuickWidget
 from PySide6.QtGui import QAction, QKeySequence
 
 if TYPE_CHECKING:
     from .main_window import MainWindow
 
 
 class UISetup:
     """Построение UI элементов главного окна
 
     Static methods для делегирования из MainWindow.
     Каждый метод принимает `window: MainWindow` как первый аргумент.
@@ -65,91 +66,184 @@ class UISetup:
         else:
             UISetup._setup_legacy_opengl_view(window)
 
         if window._qquick_widget:
             window.main_splitter.addWidget(window._qquick_widget)
 
         # Bottom section: Charts
         from src.ui.charts import ChartWidget
 
         window.chart_widget = ChartWidget(window)
         window.chart_widget.setMinimumHeight(200)
         window.main_splitter.addWidget(window.chart_widget)
 
         # Set stretch factors (3D gets more space)
         window.main_splitter.setStretchFactor(0, 3)  # 60% for 3D
         window.main_splitter.setStretchFactor(1, 2)  # 40% for charts
 
         # Add to horizontal splitter
         window.main_horizontal_splitter.addWidget(window.main_splitter)
 
         # Set as central widget
         window.setCentralWidget(window.main_horizontal_splitter)
 
         UISetup.logger.debug("✅ Система сплиттеров создана")
 
+    _SUPPORTED_SCENE_FILES = (
+        "main.qml",
+        "main_working_builtin.qml",
+        "main_canvas_2d.qml",
+        "main_fallback.qml",
+    )
+
+    _SCENE_ALIASES = {
+        "main": "main.qml",
+        "main.qml": "main.qml",
+        "default": "main.qml",
+        "3d": "main.qml",
+        "qtquick3d": "main.qml",
+        "builtin": "main_working_builtin.qml",
+        "built_in": "main_working_builtin.qml",
+        "main_working_builtin": "main_working_builtin.qml",
+        "canvas": "main_canvas_2d.qml",
+        "canvas2d": "main_canvas_2d.qml",
+        "2d": "main_canvas_2d.qml",
+        "fallback": "main_fallback.qml",
+    }
+
+    @staticmethod
+    def _resolve_supported_scene(preferred: str | None = None) -> Path:
+        """Return path to a supported QML scene.
+
+        The selection is limited to vetted scene files known to work in the
+        current application build.  Optional overrides are honoured only when
+        they reference one of the supported entries.
+
+        Args:
+            preferred: Optional scene identifier (environment variable,
+                manual override, etc.).  Can be provided as an alias
+                (``"main"``, ``"canvas"``) or as a direct filename
+                (``"main.qml"``).
+
+        Returns:
+            Path to the scene file relative to the repository root.
+
+        Raises:
+            FileNotFoundError: If the preferred scene is supported but missing
+                on disk, or if none of the supported scenes are available.
+        """
+
+        base_dir = Path("assets/qml")
+
+        def _normalise(name: str) -> str:
+            """Normalise scene identifiers for lookup."""
+
+            candidate = Path(name).name.lower().replace("-", "_")
+            if candidate in UISetup._SCENE_ALIASES:
+                return UISetup._SCENE_ALIASES[candidate]
+            if candidate in UISetup._SUPPORTED_SCENE_FILES:
+                return candidate
+            # Allow "main.qml" style identifiers even if Path stripped them.
+            if (
+                candidate.endswith(".qml")
+                and candidate in UISetup._SCENE_ALIASES
+            ):
+                return UISetup._SCENE_ALIASES[candidate]
+            return candidate
+
+        if preferred:
+            preferred_key = _normalise(preferred)
+            if preferred_key not in UISetup._SUPPORTED_SCENE_FILES:
+                UISetup.logger.warning(
+                    "    ⚠️ Unsupported QML scene override '%s' ignored",
+                    preferred,
+                )
+            else:
+                candidate = base_dir / preferred_key
+                if candidate.exists():
+                    return candidate
+                raise FileNotFoundError(
+                    f"Preferred QML scene not found: {candidate}"
+                )
+
+        for filename in UISetup._SUPPORTED_SCENE_FILES:
+            candidate = base_dir / filename
+            if candidate.exists():
+                return candidate
+
+        raise FileNotFoundError(
+            "No supported QML scenes found. Expected one of: "
+            + ", ".join(UISetup._SUPPORTED_SCENE_FILES)
+        )
+
     @staticmethod
     def _setup_qml_3d_view(window: MainWindow) -> None:
         """Setup Qt Quick 3D scene with QQuickWidget
 
         Loads unified main.qml file with full suspension visualization.
 
         Args:
             window: MainWindow instance
         """
         UISetup.logger.info("    [QML] Загрузка main.qml...")
 
         try:
             window._qquick_widget = QQuickWidget(window)
             window._qquick_widget.setResizeMode(
                 QQuickWidget.ResizeMode.SizeRootObjectToView
             )
 
             # Get QML engine
             engine = window._qquick_widget.engine()
 
             # ✅ КРИТИЧЕСКОЕ: Устанавливаем контекст ДО загрузки QML
             context = engine.rootContext()
             context.setContextProperty("window", window)
             UISetup.logger.info("    ✅ Window context registered")
 
             # Import paths
             from PySide6.QtCore import QLibraryInfo
 
             qml_import_path = QLibraryInfo.path(
                 QLibraryInfo.LibraryPath.Qml2ImportsPath
             )
             engine.addImportPath(str(qml_import_path))
 
             local_qml_path = Path("assets/qml")
             if local_qml_path.exists():
                 engine.addImportPath(str(local_qml_path.absolute()))
 
-            # Load QML file
-            qml_file = Path("assets/qml/main.qml")
-            if not qml_file.exists():
-                raise FileNotFoundError(f"QML file not found: {qml_file}")
+            preferred_scene = getattr(window, "preferred_qml_scene", None)
+            env_override = os.getenv("PSS_QML_SCENE")
+            qml_file = UISetup._resolve_supported_scene(
+                preferred_scene or env_override
+            )
+            try:
+                pretty_name = qml_file.relative_to(Path.cwd())
+            except ValueError:
+                pretty_name = qml_file
+            UISetup.logger.info("    ✅ Selected QML scene: %s", pretty_name)
 
             qml_url = QUrl.fromLocalFile(str(qml_file.absolute()))
             window._qquick_widget.setSource(qml_url)
 
             # Check status
             status = window._qquick_widget.status()
             if status == QQuickWidget.Status.Error:
                 errors = window._qquick_widget.errors()
                 error_msg = "\n".join(str(e) for e in errors)
                 raise RuntimeError(f"QML load errors:\n{error_msg}")
 
             # Get root object
             window._qml_root_object = window._qquick_widget.rootObject()
             if not window._qml_root_object:
                 raise RuntimeError("Failed to get QML root object")
 
             # Store base directory
             window._qml_base_dir = qml_file.parent.resolve()
 
             UISetup.logger.info("    ✅ main.qml loaded successfully")
 
         except Exception as e:
             UISetup.logger.exception(f"    ❌ QML load failed: {e}")
 
             # Fallback: error label
diff --git a/tools/check_repo_health.py b/tools/check_repo_health.py
new file mode 100644
index 0000000000000000000000000000000000000000..203acd094e18edd15601f0d454c41a3064bc5ff3
--- /dev/null
+++ b/tools/check_repo_health.py
@@ -0,0 +1,93 @@
+"""Repository health checks.
+
+This lightweight script prevents temporary QML artefacts from reaching the
+active source tree.  We specifically block:
+
+* ``*.rej`` files from failed patch applications;
+* ``*_backup*.qml`` snapshots of ``main.qml``;
+* ``*.qml.backup*`` snapshots of ``main.qml``;
+* ``*stub.qml`` helpers replaced by the refactored scene hierarchy.
+
+Copies kept for historical reasons should live inside ``archive/`` which the
+scanner ignores automatically.
+"""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+from typing import Iterable
+
+
+REPO_ROOT = Path(__file__).resolve().parents[1]
+IGNORE_PARTS = {".git", "archive", "__pycache__"}
+
+
+def _is_ignored(path: Path) -> bool:
+    """Return True if the path resides in an ignored directory."""
+
+    try:
+        parts = path.relative_to(REPO_ROOT).parts
+    except ValueError:  # pragma: no cover - outside repo root
+        return True
+    return any(part in IGNORE_PARTS for part in parts)
+
+
+def _iter_repo_files() -> Iterable[Path]:
+    for path in REPO_ROOT.rglob("*"):
+        if path.is_file() and not _is_ignored(path):
+            yield path
+
+
+def _is_backup_qml(name: str) -> bool:
+    lower_name = name.lower()
+    if "backup" not in lower_name:
+        return False
+    return lower_name.endswith(".qml") or ".qml." in lower_name
+
+
+def _is_stub_qml(name: str) -> bool:
+    lower_name = name.lower()
+    return lower_name.endswith("stub.qml") or "_stub.qml" in lower_name
+
+
+def collect_violations() -> list[Path]:
+    """Scan the repository and collect offending artefacts."""
+
+    offenders: list[Path] = []
+    for path in _iter_repo_files():
+        name = path.name
+        lower_name = name.lower()
+
+        if lower_name.endswith(".rej"):
+            offenders.append(path.relative_to(REPO_ROOT))
+            continue
+
+        if _is_backup_qml(name):
+            offenders.append(path.relative_to(REPO_ROOT))
+            continue
+
+        if _is_stub_qml(name):
+            offenders.append(path.relative_to(REPO_ROOT))
+
+    return sorted(offenders)
+
+
+def main() -> int:
+    offenders = collect_violations()
+    if offenders:
+        print("❌ Repository health check failed.")
+        print("Remove or archive the following files:")
+        for offender in offenders:
+            print(f"  - {offender}")
+        return 1
+
+    print(
+        "✅ Repository health check passed: no temporary QML artefacts "
+        "found."
+    )
+    return 0
+
+
+if __name__ == "__main__":  # pragma: no cover - script entry point
+    sys.exit(main())
diff --git a/.gitignore b/.gitignore
index 9207d6b247f19857d41c64b199ee4c1956036d89..c3c0680b420c863d1bece1b815f505790d9e73f9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -459,50 +459,51 @@ Thumbs.db
 *.log
 logs/
 
 # Temporary files
 *.tmp
 *.temp
 *.bak
 *.backup
 *~
 
 # Test output
 test_output.txt
 test_output.log
 test_report_*.txt
 
 # Archives and zips
 *.zip
 *.tar.gz
 *.rar
 
 # Temporary Python files
 *_temp.py
 test_*.py
 check_*.py
 !tools/check_ui_utf8.py
+!tools/check_forbidden_artifacts.py
 
 # Temporary batch files
 *.bat
 !run_app.bat
 !start_venv.bat
 
 # Temporary markdown files
 *_ГОТОВО.md
 *_SUCCESS.md
 *_COMPLETE.md
 ИСПРАВЛЕНИЕ_*.md
 СИНХРОНИЗАЦИЯ_*.md
 ИТОГ_*.md
 ВИРТУАЛЬНОЕ_*.md
 
 # QML test files
 test_*.qml
 
 # Empty test files
 test_qml_test_*
 
 # ================================================================================================
 # PneumoStabSim Professional - Enhanced .gitignore
 # Prevents project pollution with temporary, build, and debug files
 # ================================================================================================
diff --git a/assets/qml/main.qml.backup_20251018_124153 b/archive/assets/qml/legacy_backups/main.qml.backup_20251018_124153
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124153
rename to archive/assets/qml/legacy_backups/main.qml.backup_20251018_124153
diff --git a/assets/qml/main.qml.backup_20251018_124320 b/archive/assets/qml/legacy_backups/main.qml.backup_20251018_124320
similarity index 100%
rename from assets/qml/main.qml.backup_20251018_124320
rename to archive/assets/qml/legacy_backups/main.qml.backup_20251018_124320
diff --git a/assets/qml/main.qml.backup_before_cleanup b/archive/assets/qml/legacy_backups/main.qml.backup_before_cleanup
similarity index 100%
rename from assets/qml/main.qml.backup_before_cleanup
rename to archive/assets/qml/legacy_backups/main.qml.backup_before_cleanup
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_124412 b/archive/assets/qml/legacy_backups/main.qml.backup_cleanup_20251018_124412
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_124412
rename to archive/assets/qml/legacy_backups/main.qml.backup_cleanup_20251018_124412
diff --git a/assets/qml/main.qml.backup_cleanup_20251018_164914 b/archive/assets/qml/legacy_backups/main.qml.backup_cleanup_20251018_164914
similarity index 100%
rename from assets/qml/main.qml.backup_cleanup_20251018_164914
rename to archive/assets/qml/legacy_backups/main.qml.backup_cleanup_20251018_164914
diff --git a/assets/qml/main.qml.backup_geometry b/archive/assets/qml/legacy_backups/main.qml.backup_geometry
similarity index 100%
rename from assets/qml/main.qml.backup_geometry
rename to archive/assets/qml/legacy_backups/main.qml.backup_geometry
diff --git a/assets/qml/main.qml.backup_uframe_20251018_164939 b/archive/assets/qml/legacy_backups/main.qml.backup_uframe_20251018_164939
similarity index 100%
rename from assets/qml/main.qml.backup_uframe_20251018_164939
rename to archive/assets/qml/legacy_backups/main.qml.backup_uframe_20251018_164939
diff --git a/assets/qml/main.qml.rej b/archive/assets/qml/legacy_backups/main.qml.rej
similarity index 100%
rename from assets/qml/main.qml.rej
rename to archive/assets/qml/legacy_backups/main.qml.rej
diff --git a/assets/qml/main_backup.qml b/archive/assets/qml/legacy_backups/main_backup.qml
similarity index 100%
rename from assets/qml/main_backup.qml
rename to archive/assets/qml/legacy_backups/main_backup.qml
diff --git a/assets/qml/main_backup_canvas.qml b/archive/assets/qml/legacy_backups/main_backup_canvas.qml
similarity index 100%
rename from assets/qml/main_backup_canvas.qml
rename to archive/assets/qml/legacy_backups/main_backup_canvas.qml
diff --git a/assets/qml/main_optimized_stub.qml b/archive/assets/qml/legacy_backups/main_optimized_stub.qml
similarity index 100%
rename from assets/qml/main_optimized_stub.qml
rename to archive/assets/qml/legacy_backups/main_optimized_stub.qml
diff --git a/assets/qml/main_stub.qml b/archive/assets/qml/legacy_backups/main_stub.qml
similarity index 100%
rename from assets/qml/main_stub.qml
rename to archive/assets/qml/legacy_backups/main_stub.qml
diff --git a/src/runtime/__init_simple.py b/src/runtime/__init_simple.py
deleted file mode 100644
index 196fb8a968cac3fd1c640ddedc6c2c9e504a05df..0000000000000000000000000000000000000000
--- a/src/runtime/__init_simple.py
+++ /dev/null
@@ -1,45 +0,0 @@
-"""
-Simplified runtime init without physics imports
-"""
-
-from .state import (
-    StateSnapshot,
-    FrameState,
-    WheelState,
-    LineState,
-    TankState,
-    SystemAggregates,
-    StateBus,
-)
-
-from .sync import (
-    LatestOnlyQueue,
-    PerformanceMetrics,
-    TimingAccumulator,
-    ThreadSafeCounter,
-    create_state_queue,
-)
-
-# Skip sim_loop import for now due to physics dependencies
-# from .sim_loop import (
-#     PhysicsWorker, SimulationManager
-# )
-
-__all__ = [
-    # State management
-    "StateSnapshot",
-    "FrameState",
-    "WheelState",
-    "LineState",
-    "TankState",
-    "SystemAggregates",
-    "StateBus",
-    # Synchronization
-    "LatestOnlyQueue",
-    "PerformanceMetrics",
-    "TimingAccumulator",
-    "ThreadSafeCounter",
-    "create_state_queue",
-    # Simulation loop - disabled for now
-    # 'PhysicsWorker', 'SimulationManager'
-]
diff --git a/src/ui/main_window/ui_setup.py b/src/ui/main_window/ui_setup.py
index eee5908c0723993ff66a8c0055acbbd9b9bcce15..687e09d37a634f42071a28b58ccbb4103c59efc5 100644
--- a/src/ui/main_window/ui_setup.py
+++ b/src/ui/main_window/ui_setup.py
@@ -74,111 +74,120 @@ class UISetup:
         window.chart_widget = ChartWidget(window)
         window.chart_widget.setMinimumHeight(200)
         window.main_splitter.addWidget(window.chart_widget)
 
         # Set stretch factors (3D gets more space)
         window.main_splitter.setStretchFactor(0, 3)  # 60% for 3D
         window.main_splitter.setStretchFactor(1, 2)  # 40% for charts
 
         # Add to horizontal splitter
         window.main_horizontal_splitter.addWidget(window.main_splitter)
 
         # Set as central widget
         window.setCentralWidget(window.main_horizontal_splitter)
 
         UISetup.logger.debug("✅ Система сплиттеров создана")
 
     @staticmethod
     def _setup_qml_3d_view(window: MainWindow) -> None:
         """Setup Qt Quick 3D scene with QQuickWidget
 
         Loads unified main.qml file with full suspension visualization.
 
         Args:
             window: MainWindow instance
         """
-        UISetup.logger.info("    [QML] Загрузка main.qml...")
+        supported_files = [
+            Path("assets/qml/main_v2_realism.qml"),
+            Path("assets/qml/main.qml"),
+        ]
+
+        qml_file = next((candidate for candidate in supported_files if candidate.exists()), None)
+
+        if qml_file is None:
+            supported_names = ", ".join(candidate.name for candidate in supported_files)
+            raise FileNotFoundError(
+                "Не найден ни один поддерживаемый QML-файл: "
+                f"ожидались [{supported_names}]"
+            )
+
+        UISetup.logger.info("    [QML] Загрузка %s...", qml_file.name)
 
         try:
             window._qquick_widget = QQuickWidget(window)
             window._qquick_widget.setResizeMode(
                 QQuickWidget.ResizeMode.SizeRootObjectToView
             )
 
             # Get QML engine
             engine = window._qquick_widget.engine()
 
             # ✅ КРИТИЧЕСКОЕ: Устанавливаем контекст ДО загрузки QML
             context = engine.rootContext()
             context.setContextProperty("window", window)
             UISetup.logger.info("    ✅ Window context registered")
 
             # Import paths
             from PySide6.QtCore import QLibraryInfo
 
             qml_import_path = QLibraryInfo.path(
                 QLibraryInfo.LibraryPath.Qml2ImportsPath
             )
             engine.addImportPath(str(qml_import_path))
 
             local_qml_path = Path("assets/qml")
             if local_qml_path.exists():
                 engine.addImportPath(str(local_qml_path.absolute()))
 
-            # Load QML file
-            qml_file = Path("assets/qml/main.qml")
-            if not qml_file.exists():
-                raise FileNotFoundError(f"QML file not found: {qml_file}")
-
             qml_url = QUrl.fromLocalFile(str(qml_file.absolute()))
             window._qquick_widget.setSource(qml_url)
 
             # Check status
             status = window._qquick_widget.status()
             if status == QQuickWidget.Status.Error:
                 errors = window._qquick_widget.errors()
                 error_msg = "\n".join(str(e) for e in errors)
                 raise RuntimeError(f"QML load errors:\n{error_msg}")
 
             # Get root object
             window._qml_root_object = window._qquick_widget.rootObject()
             if not window._qml_root_object:
                 raise RuntimeError("Failed to get QML root object")
 
             # Store base directory
             window._qml_base_dir = qml_file.parent.resolve()
 
-            UISetup.logger.info("    ✅ main.qml loaded successfully")
+            UISetup.logger.info("    ✅ %s loaded successfully", qml_file.name)
 
         except Exception as e:
             UISetup.logger.exception(f"    ❌ QML load failed: {e}")
 
             # Fallback: error label
             fallback = QLabel(
                 f"КРИТИЧЕСКАЯ ОШИБКА ЗАГРУЗКИ 3D СЦЕНЫ\n\n"
                 f"Ошибка: {e}\n\n"
-                f"Проверьте файл assets/qml/main.qml"
+                "Проверьте наличие файлов assets/qml/main_v2_realism.qml или assets/qml/main.qml"
             )
             fallback.setAlignment(Qt.AlignmentFlag.AlignCenter)
             fallback.setStyleSheet(
                 "background: #1a1a2e; color: #ff6b6b; "
                 "font-size: 12px; padding: 20px;"
             )
             window._qquick_widget = fallback
 
     @staticmethod
     def _setup_legacy_opengl_view(window: MainWindow) -> None:
         """Setup legacy OpenGL widget (stub)"""
         UISetup.logger.debug("_setup_legacy_opengl_view: Fallback to QML")
         UISetup._setup_qml_3d_view(window)
 
     # ------------------------------------------------------------------
     # Tabs Setup
     # ------------------------------------------------------------------
     @staticmethod
     def setup_tabs(window: MainWindow) -> None:
         """Создать вкладки с панелями параметров
 
         Tabs:
           - Геометрия (Geometry)
           - Пневмосистема (Pneumatics)
           - Режимы стабилизатора (Modes)
diff --git a/tools/check_forbidden_artifacts.py b/tools/check_forbidden_artifacts.py
new file mode 100644
index 0000000000000000000000000000000000000000..5cd5d5c623b39608253cad466d7f67c8aee1a1ad
--- /dev/null
+++ b/tools/check_forbidden_artifacts.py
@@ -0,0 +1,69 @@
+"""CI check for forbidden temporary artifacts.
+
+Ensures that stray QML backup files and patch rejects are not committed.
+"""
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+from typing import Iterable
+
+# Directories to skip entirely when scanning for artifacts
+SKIP_DIR_NAMES = {
+    ".git",
+    "archive",  # archived data may legitimately contain old backups
+    "venv",
+    ".venv",
+    "env",
+    "node_modules",
+    "__pycache__",
+}
+
+FORBIDDEN_PATTERNS: tuple[tuple[str, str], ...] = (
+    ("*.rej", "Patch reject file"),
+    ("*_backup*.qml", "Backup QML file"),
+    ("*.qml.backup*", "Backup QML file"),
+)
+
+
+def should_skip(path: Path) -> bool:
+    """Return True if the path should be skipped."""
+    return any(part in SKIP_DIR_NAMES for part in path.parts)
+
+
+def find_forbidden(root: Path) -> dict[Path, str]:
+    """Locate forbidden artifacts below *root*."""
+    discovered: dict[Path, str] = {}
+    for pattern, description in FORBIDDEN_PATTERNS:
+        for match in root.rglob(pattern):
+            if not match.is_file():
+                continue
+            if should_skip(match):
+                continue
+            discovered.setdefault(match, description)
+    return discovered
+
+
+def format_report(paths: Iterable[tuple[Path, str]], root: Path) -> str:
+    lines = ["Forbidden artifacts detected:"]
+    for path, description in sorted(paths, key=lambda item: str(item[0])):
+        relative_path = path.relative_to(root)
+        lines.append(f"- {relative_path} ({description})")
+    return "\n".join(lines)
+
+
+def main() -> int:
+    repo_root = Path(__file__).resolve().parents[1]
+    forbidden = find_forbidden(repo_root)
+
+    if forbidden:
+        report = format_report(forbidden.items(), repo_root)
+        print(report)
+        return 1
+
+    print("No forbidden artifacts detected.")
+    return 0
+
+
+if __name__ == "__main__":  # pragma: no cover - CLI entry point
+    sys.exit(main())
diff --git a/assets/qml/main.qml b/assets/qml/main.qml
index ca189328b5fbf213bcd7704fa4031db5e94687e5..d251f1ece03f66bfccbde21cb795878d85c5d118 100644
--- a/assets/qml/main.qml
+++ b/assets/qml/main.qml
@@ -1,358 +1,1707 @@
 import QtQuick
 import QtQuick3D
-import QtQuick.Controls
 import QtQuick3D.Helpers
+import QtQuick.Controls
+import Qt.labs.folderlistmodel
 import "components"
-import "effects"
+import "core"  // ✅ PHASE 1: Core Utilities (MathUtils, GeometryCalculations, StateCache)
+import "camera"  // ✅ PHASE 2: Camera System Modules
+import "lighting"  // ✅ STEP 1: Lighting System Modules
+import "scene"  // ✅ НОВОЕ: Materials Module
+import "geometry"  // ✅ CRITICAL FIX: Geometry modules (Frame, SuspensionCorner, CylinderGeometry)
 
 /*
- * PneumoStabSim - MAIN QML (v4.9.x)
- *
- * View3D + ExtendedSceneEnvironment (HDR/IBL), IBL Probe Loader.
- * Реальная упрощённая схема (рама, рычаги, цилиндр). Без кнопок на канве.
- * Обновления приходят из панелей через apply*Updates и batched updates.
+ * PneumoStabSim - COMPLETE Graphics Parameters Main 3D View (v4.9.4 SKYBOX FIX)
+ * 🚀 ENHANCED: Separate IBL lighting/background controls + procedural geometry quality
+ * ✅ All properties match official Qt Quick 3D documentation
+ * 🐛 FIXED: Removed skyBoxBlurAmount (not exposed by Qt Quick 3D API)
+ * 🐛 CRITICAL FIX v4.9.4: Skybox rotation with continuous angle accumulation
+ *    - Added envYaw for continuous angle tracking (NO flips at 0°/180°)
+ *    - probeOrientation uses accumulated envYaw instead of direct cameraYaw
+ *    - Background is stable regardless of camera rotation
+ * 🐛 FIXED: emissiveVector typo → emissiveVector
  */
 Item {
- id: root
- anchors.fill: parent
-
- // ---------------------------------------------
- // Свойства и сигнал для батч-обновлений из Python
- // ---------------------------------------------
- property var pendingPythonUpdates: null
- signal batchUpdatesApplied(var summary)
-
- // Состояние симуляции, управляется из Python (MainWindow)
- property bool isRunning: false
- property real animationTime:0.0 // сек, накапливается Python-таймером
-
- // -------- Геометрия подвески (СИ) --------
- property real userFrameLength:3.2
- property real userFrameHeight:0.65
- property real userBeamSize:0.12
- property real userLeverLength:0.8
- property real userCylinderLength:0.5
- property real userTrackWidth:1.6
- property real userFrameToPivot:0.6
- property real userRodPosition:0.6
- property real userBoreHead:0.08
- property real userRodDiameter:0.035
- property real userPistonThickness:0.025
- property real userPistonRodLength:0.2
-
- // Анимация рычагов (град)
- property real userAmplitude:8.0
- property real userFrequency:1.0
- property real userPhaseGlobal:0.0
- property real userPhaseFL:0.0
- property real userPhaseFR:0.0
- property real userPhaseRL:0.0
- property real userPhaseRR:0.0
-
- // Вычисляемые углы (SLERP handled by Qt)
- property real fl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseFL) * Math.PI /180) :0.0
- property real fr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseFR) * Math.PI /180) :0.0
- property real rl_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseRL) * Math.PI /180) :0.0
- property real rr_angle: isRunning ? userAmplitude * Math.sin(animationTime * userFrequency *2 * Math.PI + (userPhaseGlobal + userPhaseRR) * Math.PI /180) :0.0
-
- // -------- Материалы/вид --------
- property color defaultClearColor: "#1a1a2e"
- property color modelBaseColor: "#9ea4ab"
- property real modelRoughness:0.35
- property real modelMetalness:0.9
-
- // ---------------------------------------------
- // Утилиты
- // ---------------------------------------------
- function setIfExists(obj, prop, value) {
- try {
- if (obj && (prop in obj || typeof obj[prop] !== 'undefined')) {
- obj[prop] = value;
- }
- } catch (e) { /* ignore */ }
- }
-
- function clamp(value, minValue, maxValue) {
- if (typeof value !== 'number' || !isFinite(value))
- return minValue;
- return Math.max(minValue, Math.min(maxValue, value));
- }
-
- // ---------------------------------------------
- // Применение батч-обновлений из Python
- // ---------------------------------------------
- onPendingPythonUpdatesChanged: {
- if (!pendingPythonUpdates)
- return;
- try {
- applyBatchedUpdates(pendingPythonUpdates);
- } finally {
- pendingPythonUpdates = null; // очистка после применения
- }
- }
-
- function applyBatchedUpdates(updates) {
- if (!updates)
- return;
- var applied = {};
- if (updates.geometry) { applyGeometryUpdates(updates.geometry); applied.geometry = true; }
- if (updates.camera) { applyCameraUpdates(updates.camera); applied.camera = true; }
- if (updates.lighting) { applyLightingUpdates(updates.lighting); applied.lighting = true; }
- if (updates.environment){ applyEnvironmentUpdates(updates.environment); applied.environment = true; }
- if (updates.quality) { applyQualityUpdates(updates.quality); applied.quality = true; }
- if (updates.materials) { applyMaterialUpdates(updates.materials); applied.materials = true; }
- if (updates.effects) { applyEffectsUpdates(updates.effects); applied.effects = true; }
- if (updates.animation) { applyAnimationUpdates(updates.animation); applied.animation = true; }
- if (updates.threeD) { apply3DUpdates(updates.threeD); applied.threeD = true; }
- if (updates.render) { applyRenderSettings(updates.render); applied.render = true; }
-
- batchUpdatesApplied(applied);
- }
-
- // ---------------------------------------------
- // Реализации apply*Updates
- // ---------------------------------------------
- function applyGeometryUpdates(params) {
- if (!params) return;
- // Поддерживаем несколько алиасов из Python панелей
- function pick(obj, keys, def) {
- for (var i=0;i<keys.length;i++) if (obj[keys[i]] !== undefined) return obj[keys[i]];
- return def;
- }
- var v;
- v = pick(params, ['frameLength','frame_length','userFrameLength'], undefined); if (v!==undefined) userFrameLength = Number(v);
- v = pick(params, ['frameHeight','frame_height','userFrameHeight'], undefined); if (v!==undefined) userFrameHeight = Number(v);
- v = pick(params, ['frameBeamSize','beamSize','userBeamSize'], undefined); if (v!==undefined) userBeamSize = Number(v);
- v = pick(params, ['leverLength','userLeverLength'], undefined); if (v!==undefined) userLeverLength = Number(v);
- v = pick(params, ['cylinderBodyLength','cylinderLength','userCylinderLength'], undefined); if (v!==undefined) userCylinderLength = Number(v);
- v = pick(params, ['trackWidth','track','userTrackWidth'], undefined); if (v!==undefined) userTrackWidth = Number(v);
- v = pick(params, ['frameToPivot','frame_to_pivot','userFrameToPivot'], undefined); if (v!==undefined) userFrameToPivot = Number(v);
- v = pick(params, ['rodPosition','attachFrac','userRodPosition'], undefined); if (v!==undefined) userRodPosition = Number(v);
- v = pick(params, ['boreHead','bore','bore_d','userBoreHead'], undefined); if (v!==undefined) userBoreHead = Number(v);
- v = pick(params, ['rod_d','rodDiameter','userRodDiameter'], undefined); if (v!==undefined) userRodDiameter = Number(v);
- v = pick(params, ['pistonThickness','userPistonThickness'], undefined); if (v!==undefined) userPistonThickness = Number(v);
- v = pick(params, ['pistonRodLength','userPistonRodLength'], undefined); if (v!==undefined) userPistonRodLength = Number(v);
- }
-
- function applyCameraUpdates(params) {
- if (!params) return;
- if (params.fov !== undefined) setIfExists(camera, 'fieldOfView', Number(params.fov));
- if (params.clipNear !== undefined) setIfExists(camera, 'clipNear', Number(params.clipNear));
- if (params.clipFar !== undefined) setIfExists(camera, 'clipFar', Number(params.clipFar));
- if (params.position) {
- var p = params.position;
- try { camera.position = Qt.vector3d(Number(p.x||p[0]), Number(p.y||p[1]), Number(p.z||p[2])); } catch(e) {}
- }
- if (params.eulerRotation) {
- var r = params.eulerRotation;
- try { camera.eulerRotation = Qt.vector3d(Number(r.x||r[0]), Number(r.y||r[1]), Number(r.z||r[2])); } catch(e) {}
- }
- // Обработка ошибок установки камеры
- try {
- if (params.fov !== undefined) camera.fieldOfView = Number(params.fov);
- if (params.clipNear !== undefined) camera.clipNear = Number(params.clipNear);
- if (params.clipFar !== undefined) camera.clipFar = Number(params.clipFar);
- if (params.position) {
- var p = params.position;
- camera.position = Qt.vector3d(Number(p.x||p[0]), Number(p.y||p[1]), Number(p.z||p[2]));
- }
- if (params.eulerRotation) {
- var r = params.eulerRotation;
- camera.eulerRotation = Qt.vector3d(Number(r.x||r[0]), Number(r.y||r[1]), Number(r.z||r[2]));
- }
- } catch(e) {
- console.warn("Camera update error:", e);
- }
- }
-
- function applyLightingUpdates(params) {
- if (!params) return;
- if (params.color) setIfExists(keyLight, 'color', params.color);
- if (params.brightness !== undefined) setIfExists(keyLight, 'brightness', Number(params.brightness));
- if (params.eulerRotation) {
- var r = params.eulerRotation;
- try { keyLight.eulerRotation = Qt.vector3d(Number(r.x||r[0]), Number(r.y||r[1]), Number(r.z||r[2])); } catch(e) {}
- }
- // Обработка ошибок установки освещения
- try {
- if (params.color) keyLight.color = params.color;
- if (params.brightness !== undefined) keyLight.brightness = Number(params.brightness);
- if (params.eulerRotation) {
- var r = params.eulerRotation;
- keyLight.eulerRotation = Qt.vector3d(Number(r.x||r[0]), Number(r.y||r[1]), Number(r.z||r[2]));
- }
- } catch(e) {
- console.warn("Lighting update error:", e);
- }
- }
-
- function applyEnvironmentUpdates(params) {
- if (!params) return;
- // Бэкграунд/цвет
- if (params.clearColor) setIfExists(sceneEnvCtl, 'backgroundColor', params.clearColor);
- if (params.backgroundColor) setIfExists(sceneEnvCtl, 'backgroundColor', params.backgroundColor);
- // IBL флаги и параметры
- if (params.iblBackgroundEnabled !== undefined) setIfExists(sceneEnvCtl, 'iblBackgroundEnabled', !!params.iblBackgroundEnabled);
- if (params.iblLightingEnabled !== undefined) setIfExists(sceneEnvCtl, 'iblLightingEnabled', !!params.iblLightingEnabled);
- if (params.iblIntensity !== undefined) setIfExists(sceneEnvCtl, 'iblIntensity', Number(params.iblIntensity));
- if (params.iblRotationDeg !== undefined) setIfExists(sceneEnvCtl, 'iblRotationDeg', Number(params.iblRotationDeg));
- // Источники HDR
- if (params.iblPrimary || params.hdrSource || params.iblSource) {
- var src = params.iblPrimary || params.hdrSource || params.iblSource;
- if (typeof window !== 'undefined' && window && typeof window.normalizeHdrPath === 'function') {
- try { src = window.normalizeHdrPath(String(src)); } catch(e) {}
- }
- setIfExists(iblLoader, 'primarySource', src);
- }
- if (params.iblFallback) setIfExists(iblLoader, 'fallbackSource', params.iblFallback);
- // Тонемап
- if (params.tonemapEnabled !== undefined) setIfExists(sceneEnvCtl, 'tonemapEnabled', !!params.tonemapEnabled);
- if (params.tonemapModeName) setIfExists(sceneEnvCtl, 'tonemapModeName', String(params.tonemapModeName));
- if (params.tonemapExposure !== undefined) setIfExists(sceneEnvCtl, 'tonemapExposure', Number(params.tonemapExposure));
- if (params.tonemapWhitePoint !== undefined) setIfExists(sceneEnvCtl, 'tonemapWhitePoint', Number(params.tonemapWhitePoint));
- // Туман
- if (params.fogEnabled !== undefined) setIfExists(sceneEnvCtl, 'fogEnabled', !!params.fogEnabled);
- if (params.fogColor) setIfExists(sceneEnvCtl, 'fogColor', params.fogColor);
- if (params.fogNear !== undefined) setIfExists(sceneEnvCtl, 'fogNear', Number(params.fogNear));
- if (params.fogFar !== undefined) setIfExists(sceneEnvCtl, 'fogFar', Number(params.fogFar));
- // SSAO
- if (params.ssaoEnabled !== undefined) setIfExists(sceneEnvCtl, 'ssaoEnabled', !!params.ssaoEnabled);
- if (params.ssaoRadius !== undefined) setIfExists(sceneEnvCtl, 'ssaoRadius', Number(params.ssaoRadius));
- if (params.ssaoIntensity !== undefined) setIfExists(sceneEnvCtl, 'ssaoIntensity', Number(params.ssaoIntensity));
- // DoF
- if (params.depthOfFieldEnabled !== undefined) setIfExists(sceneEnvCtl, 'internalDepthOfFieldEnabled', !!params.depthOfFieldEnabled);
- if (params.dofFocusDistance !== undefined) setIfExists(sceneEnvCtl, 'dofFocusDistance', Number(params.dofFocusDistance));
- if (params.dofBlurAmount !== undefined) setIfExists(sceneEnvCtl, 'dofBlurAmount', Number(params.dofBlurAmount));
- // Vignette
- if (params.vignetteEnabled !== undefined) setIfExists(sceneEnvCtl, 'internalVignetteEnabled', !!params.vignetteEnabled);
- if (params.vignetteStrength !== undefined) setIfExists(sceneEnvCtl, 'internalVignetteStrength', Number(params.vignetteStrength));
- // AA/качество
- if (params.aaPrimaryMode) setIfExists(sceneEnvCtl, 'aaPrimaryMode', String(params.aaPrimaryMode));
- if (params.aaQualityLevel) setIfExists(sceneEnvCtl, 'aaQualityLevel', String(params.aaQualityLevel));
- if (params.aaPostMode) setIfExists(sceneEnvCtl, 'aaPostMode', String(params.aaPostMode));
- if (params.taaEnabled !== undefined) setIfExists(sceneEnvCtl, 'taaEnabled', !!params.taaEnabled);
- if (params.taaStrength !== undefined) setIfExists(sceneEnvCtl, 'taaStrength', Number(params.taaStrength));
- if (params.taaMotionAdaptive !== undefined) setIfExists(sceneEnvCtl, 'taaMotionAdaptive', !!params.taaMotionAdaptive);
- if (params.fxaaEnabled !== undefined) setIfExists(sceneEnvCtl, 'fxaaEnabled', !!params.fxaaEnabled);
- if (params.specularAAEnabled !== undefined) setIfExists(sceneEnvCtl, 'specularAAEnabled', !!params.specularAAEnabled);
- // OIT
- if (params.oitMode) setIfExists(sceneEnvCtl, 'oitMode', String(params.oitMode));
- // Dithering
- if (params.ditheringEnabled !== undefined) setIfExists(sceneEnvCtl, 'ditheringEnabled', !!params.ditheringEnabled);
- }
-
- function applyQualityUpdates(params) {
- if (!params) return;
- if (params.aaPrimaryMode) setIfExists(sceneEnvCtl, 'aaPrimaryMode', String(params.aaPrimaryMode));
- if (params.aaQualityLevel) setIfExists(sceneEnvCtl, 'aaQualityLevel', String(params.aaQualityLevel));
- if (params.ditheringEnabled !== undefined) setIfExists(sceneEnvCtl, 'ditheringEnabled', !!params.ditheringEnabled);
- }
-
- function applyMaterialUpdates(params) {
- if (!params) return;
- // Упрощённо: применять к металлу рычагов
- if (params.baseColor) modelBaseColor = params.baseColor;
- if (params.roughness !== undefined) modelRoughness = clamp(Number(params.roughness),0.0,1.0);
- if (params.metalness !== undefined) modelMetalness = clamp(Number(params.metalness),0.0,1.0);
- }
-
- function applyEffectsUpdates(params) {
- if (!params) return;
- // Эффекты уже настраиваются через applyEnvironmentUpdates
- }
-
- function applyAnimationUpdates(params) {
- if (!params) return;
- if (params.isRunning !== undefined) isRunning = !!params.isRunning;
- if (params.amplitude !== undefined) userAmplitude = Number(params.amplitude);
- if (params.frequency !== undefined) userFrequency = Number(params.frequency);
- if (params.phase_global !== undefined) userPhaseGlobal = Number(params.phase_global);
- if (params.phase_fl !== undefined) userPhaseFL = Number(params.phase_fl);
- if (params.phase_fr !== undefined) userPhaseFR = Number(params.phase_fr);
- if (params.phase_rl !== undefined) userPhaseRL = Number(params.phase_rl);
- if (params.phase_rr !== undefined) userPhaseRR = Number(params.phase_rr);
- }
-
- function apply3DUpdates(params) {
- }
-
- function applyRenderSettings(params) {
- }
-
- // ---------------------------------------------
- // IBL Loader (загрузка HDR probe)
- // ---------------------------------------------
- IblProbeLoader {
- id: iblLoader
- }
-
- // ---------------------------------------------
- //3D сцена + ExtendedSceneEnvironment с IBL
- // ---------------------------------------------
- View3D {
- id: view3d
- anchors.fill: parent
-
- environment: SceneEnvironmentController {
- id: sceneEnvCtl
- iblProbe: iblLoader.probe
- backgroundColor: root.defaultClearColor
- }
-
- PerspectiveCamera {
- id: camera
- position: Qt.vector3d(0,0,600)
- fieldOfView:60
- clipNear:1
- clipFar:50000
- }
-
- DirectionalLight {
- id: keyLight
- eulerRotation.x: -30
- eulerRotation.y: -30
- brightness:1.6
- color: "#ffffff"
- }
-
- // === Рама (центральная балка) ===
- Model {
- id: mainFrame
- position: Qt.vector3d(0, root.userBeamSize/2, root.userFrameLength/2)
- source: "#Cube"
- scale: Qt.vector3d(root.userTrackWidth/100, root.userBeamSize/100, root.userFrameLength/100)
- materials: PrincipledMaterial { baseColor: "#4a4a4a"; metalness:0.85; roughness:0.3 }
- }
-
- // === Рычаги ===
- Model { id: frontLeftLever; position: Qt.vector3d(-root.userTrackWidth/2, root.userBeamSize, root.userFrameToPivot); source: "#Cube"; scale: Qt.vector3d(root.userLeverLength/100,8,8); eulerRotation: Qt.vector3d(0,0, root.fl_angle); materials: PrincipledMaterial { baseColor: root.modelBaseColor; metalness: root.modelMetalness; roughness: root.modelRoughness } }
- Model { id: frontRightLever; position: Qt.vector3d( root.userTrackWidth/2, root.userBeamSize, root.userFrameToPivot); source: "#Cube"; scale: Qt.vector3d(root.userLeverLength/100,8,8); eulerRotation: Qt.vector3d(0,0, root.fr_angle); materials: PrincipledMaterial { baseColor: root.modelBaseColor; metalness: root.modelMetalness; roughness: root.modelRoughness } }
- Model { id: rearLeftLever; position: Qt.vector3d(-root.userTrackWidth/2, root.userBeamSize, root.userFrameLength - root.userFrameToPivot); source: "#Cube"; scale: Qt.vector3d(root.userLeverLength/100,8,8); eulerRotation: Qt.vector3d(0,0, root.rl_angle); materials: PrincipledMaterial { baseColor: root.modelBaseColor; metalness: root.modelMetalness; roughness: root.modelRoughness } }
- Model { id: rearRightLever; position: Qt.vector3d( root.userTrackWidth/2, root.userBeamSize, root.userFrameLength - root.userFrameToPivot); source: "#Cube"; scale: Qt.vector3d(root.userLeverLength/100,8,8); eulerRotation: Qt.vector3d(0,0, root.rr_angle); materials: PrincipledMaterial { baseColor: root.modelBaseColor; metalness: root.modelMetalness; roughness: root.modelRoughness } }
-
- // === Простой цилиндр (визуальная верификация) ===
- Model {
- id: cylinderFL
- position: Qt.vector3d(-root.userTrackWidth/4, root.userBeamSize + root.userFrameHeight/2, root.userFrameToPivot)
- source: "#Cylinder"
- scale: Qt.vector3d(root.userBoreHead/100, root.userCylinderLength/100, root.userBoreHead/100)
- materials: PrincipledMaterial { baseColor: "#bcd7ff"; metalness:0.0; roughness:0.08; transmissionFactor:0.6; opacity:0.8; indexOfRefraction:1.52; alphaMode: PrincipledMaterial.Blend }
- }
- }
-
- // Принудительное первичное применение категорий (без данных)
- Component.onCompleted: {
- applyBatchedUpdates({
- geometry: true,
- camera: true,
- lighting: true,
- environment: { backgroundColor: defaultClearColor },
- quality: true,
- materials: { baseColor: modelBaseColor, roughness: modelRoughness, metalness: modelMetalness },
- effects: true,
- animation: { isRunning: isRunning, amplitude: userAmplitude, frequency: userFrequency },
- threeD: true,
- render: true,
- });
- }
+    id: root
+    anchors.fill: parent
+    // Toggle to show/hide in-canvas UI controls (to avoid duplication with external GraphicsPanel)
+    property bool showOverlayControls: false
+
+    // ===============================================================
+    // 🚀 SIGNALS - ACK для Python после применения обновлений
+    // ===============================================================
+
+    signal batchUpdatesApplied(var summary)
+
+    // ===============================================================
+    // 🚀 QT VERSION DETECTION (для условной активации возможностей)
+    // ===============================================================
+
+    readonly property string qtVersionString: typeof Qt.version !== "undefined" ? Qt.version : "6.0.0"
+    readonly property var qtVersionParts: qtVersionString.split('.')
+    readonly property int qtMajor: qtVersionParts.length > 0 ? parseInt(qtVersionParts[0]) : 6
+    readonly property int qtMinor: qtVersionParts.length > 1 ? parseInt(qtVersionParts[1]) : 0
+    readonly property bool supportsQtQuick3D610Features: qtMajor === 6 && qtMinor >= 10
+
+    // ✅ Условная поддержка dithering (доступно с Qt 6.10)
+    property bool ditheringEnabled: true  // Управляется из GraphicsPanel
+    readonly property bool canUseDithering: supportsQtQuick3D610Features
+    // ✅ Гейт для Specular AA (временно отключаем по умолчанию из-за ошибки шейдера)
+    readonly property bool canUseSpecularAA: false
+
+    // ===============================================================
+    // 🚀 CRITICAL FIX v4.9.4: SKYBOX ROTATION - INDEPENDENT FROM CAMERA
+    // ===============================================================
+
+    // ✅ ПРАВИЛЬНО: Skybox вращается ТОЛЬКО от пользовательского iblRotationDeg
+    // Камера НЕ влияет на skybox вообще!
+
+    // ❌ УДАЛЕНО: envYaw, _prevCameraYaw, updateCameraYaw() - это было НЕПРАВИЛЬНО
+    // Эти переменные СВЯЗЫВАЛИ фон с камерой, что вызывало проблему
+
+    // ===============================================================
+    // 🚀 PERFORMANCE OPTIMIZATION LAYER (✅ PHASE 1: Using StateCache)
+    // ===============================================================
+
+    // ✅ PHASE 1: Connect StateCache to root properties
+    Connections {
+        target: root
+
+        function onAnimationTimeChanged() { StateCache.animationTime = root.animationTime }
+        function onUserFrequencyChanged() { StateCache.userFrequency = root.userFrequency }
+        function onUserPhaseGlobalChanged() { StateCache.userPhaseGlobal = root.userPhaseGlobal }
+        function onUserPhaseFLChanged() { StateCache.userPhaseFL = root.userPhaseFL }
+        function onUserPhaseFRChanged() { StateCache.userPhaseFR = root.userPhaseFR }
+        function onUserPhaseRLChanged() { StateCache.userPhaseRL = root.userPhaseRL }
+        function onUserPhaseRRChanged() { StateCache.userPhaseRR = root.userPhaseRR }
+        function onUserAmplitudeChanged() { StateCache.userAmplitude = root.userAmplitude }
+        function onUserLeverLengthChanged() { StateCache.userLeverLength = root.userLeverLength }
+        function onUserRodPositionChanged() { StateCache.userRodPosition = root.userRodPosition }
+        function onUserCylinderLengthChanged() { StateCache.userCylinderLength = root.userCylinderLength }
+        function onUserTrackWidthChanged() { StateCache.userTrackWidth = root.userTrackWidth }
+        function onUserFrameLengthChanged() { StateCache.userFrameLength = root.userFrameLength }
+        function onCameraFovChanged() { StateCache.cameraFov = root.cameraFov }
+    }
+
+    // ✅ PHASE 1: Use StateCache (Singleton) instead of local animationCache
+    readonly property var animationCache: StateCache
+
+    // ✅ PHASE 1: Use GeometryCalculations (Singleton) instead of local geometryCache
+    readonly property var geometryCache: QtObject {
+        // ✅ Cached constants from StateCache
+        readonly property real leverLengthRodPos: StateCache.leverLengthRodPos
+        readonly property real piOver180: StateCache.piOver180
+        readonly property real deg180OverPi: StateCache.deg180OverPi
+
+        // ✅ Cached camera calculations from StateCache
+        readonly property real cachedFovRad: StateCache.cachedFovRad
+        readonly property real cachedTanHalfFov: StateCache.cachedTanHalfFov
+
+        // ✅ PHASE 1: Delegate to GeometryCalculations
+        function calculateJRod(j_arm, baseAngle, leverAngle) {
+            return GeometryCalculations.calculateJRodPosition(
+                j_arm, root.userLeverLength, root.userRodPosition, baseAngle, leverAngle
+            )
+        }
+
+        // ✅ PHASE 1: Delegate to GeometryCalculations
+        function normalizeCylDirection(j_rod, j_tail) {
+            return GeometryCalculations.calculateCylinderAxis(j_rod, j_tail)
+        }
+    }
+
+    // ===============================================================
+    // IBL CONTROLLER
+    // ===============================================================
+
+    IblProbeLoader {
+        id: iblLoader
+        primarySource: root.iblPrimarySource
+        fallbackSource: root.iblFallbackSource
+        onActiveSourceChanged: {
+            console.log("🌐 IBL activeSource:", activeSource)
+        }
+    }
+
+    // ===============================================================
+    // ✅ PHASE 2: CAMERA SYSTEM (modular)
+    // ===============================================================
+
+    // ✅ Заменено на CameraController - см. assets/qml/camera/
+    // Все 21 camera properties + 5 behaviors + 4 functions (169 lines) → 1 component
+
+    // ===============================================================
+    // ✅ PHASE 2: CAMERA PROPERTIES (for backward compatibility)
+    // ===============================================================
+
+    // ✅ Expose camera properties from CameraController for backward compatibility
+    readonly property alias cameraDistance: cameraController.distance
+    readonly property alias cameraYaw: cameraController.yawDeg
+    readonly property alias cameraPitch: cameraController.pitchDeg
+    readonly property alias pivot: cameraController.pivot
+    readonly property alias cameraIsMoving: cameraController.isMoving
+
+    // ✅ Camera settings (writable properties synced with CameraState)
+    // ВАЖНО: Используем прямые свойства вместо aliases, чтобы избежать проблем с порядком инициализации
+    property real cameraFov: 60.0
+    property real cameraNear: 10.0
+    property real cameraFar: 50000.0
+    property real cameraSpeed: 1.0
+    property bool autoRotate: false
+    property real autoRotateSpeed: 0.5
+
+    // ===============================================================
+    // ✅ COMPLETE GRAPHICS PROPERTIES (All parameters from GraphicsPanel)
+    // ===============================================================
+
+    // HDR resources (без дефолтов — всё задаёт UI/настройки)
+    property url iblPrimarySource: startIblSource && startIblSource !== "" ? resolveUrl(startIblSource) : ""
+    property url iblFallbackSource: startIblFallback && startIblFallback !== "" ? resolveUrl(startIblFallback) : ""
+    readonly property bool iblReady: iblLoader.ready
+
+    // Environment defaults c учетом стартовых флагов
+    // Режим фона (исторический ключ от Python; не влияет на показ skybox)
+    property string backgroundMode: startBackgroundMode
+    property color backgroundColor: "#1f242c"
+    property bool iblEnabled: startIblEnabled
+    // ✅ CRITICAL FIX v4.9.5: НЕЗАВИСИМОЕ начальное значение для iblLightingEnabled!
+    // НЕ копируем startIblEnabled - пусть каждый флаг независим с самого начала!
+    property bool iblLightingEnabled: true   // По умолчанию ВКЛ (независимо от master)
+    property bool iblBackgroundEnabled: startSkyboxEnabled
+    property real iblRotationDeg: startIblRotation
+    property real iblIntensity: startIblIntensity
+
+    // Lighting
+    property real keyLightBrightness: 1.2
+    property color keyLightColor: "#ffffff"
+    property real keyLightAngleX: -35
+    property real keyLightAngleY: -40
+    property bool keyLightCastsShadow: true
+    property bool keyLightBindToCamera: false
+    property real keyLightPosX: 0.0
+    property real keyLightPosY: 0.0
+    property real fillLightBrightness: 0.7
+    property color fillLightColor: "#dfe7ff"
+    property bool fillLightCastsShadow: false
+    property bool fillLightBindToCamera: false
+    property real fillLightPosX: 0.0
+    property real fillLightPosY: 0.0
+    property real rimLightBrightness: 1.0
+    property color rimLightColor: "#ffe2b0"
+    property bool rimLightCastsShadow: false
+    property bool rimLightBindToCamera: false
+    property real rimLightPosX: 0.0
+    property real rimLightPosY: 0.0
+    property real pointLightBrightness: 1000.0
+    property color pointLightColor: "#ffffff"
+    property real pointLightX: 0.0
+    property real pointLightY: 2200.0
+    property real pointLightRange: 3200.0
+    property bool pointLightCastsShadow: false   // ✅ Новый пользовательский флаг теней точечного света
+    property bool pointLightBindToCamera: false
+
+    // Procedural geometry quality
+    property int cylinderSegments: 64
+    property int cylinderRings: 8
+
+    // Quality and rendering
+    property string aaPrimaryMode: "ssaa"
+    property string aaQualityLevel: "high"
+    property string aaPostMode: "taa"
+    property bool taaEnabled: true
+    property real taaStrength: 0.4
+    property bool taaMotionAdaptive: true
+    property bool fxaaEnabled: false
+    // ВРЕМЕННЫЙ ФИКС: отключаем Specular AA по умолчанию (ошибка компиляции шейдера на некоторых драйверах)
+    property bool specularAAEnabled: false
+    property real renderScale: 1.05
+    property string renderPolicy: "always"
+    property real frameRateLimit: 144.0
+    property string qualityPreset: "ultra"
+
+    // === Fog properties (Qt 6.10+ Fog object) ===
+    property bool fogEnabled: false
+    property color fogColor: "#808080"
+    property real fogDensity: 0.1
+    property real fogNear: 1200.0
+    property real fogFar: 12000.0
+
+    // === SSAO properties (Effects/Environment binding) ===
+    property bool ssaoEnabled: false
+    property real ssaoRadius: 8.0
+    property real ssaoIntensity: 1.0
+
+    property var pendingPythonUpdates: null
+
+    onPendingPythonUpdatesChanged: {
+        if (!pendingPythonUpdates || Object.keys(pendingPythonUpdates).length === 0)
+            return
+        applyBatchedUpdates(pendingPythonUpdates)
+        pendingPythonUpdates = null
+    }
+
+    function syncRenderSettings() {
+        if (!view3d || !view3d.renderSettings)
+            return
+        const settings = view3d.renderSettings
+        settings.renderScale = renderScale
+        settings.maximumFrameRate = frameRateLimit
+        settings.renderPolicy = renderPolicy === "ondemand" ? RenderSettings.OnDemand : RenderSettings.Always
+    }
+
+    onRenderScaleChanged: syncRenderSettings()
+    onFrameRateLimitChanged: syncRenderSettings()
+    onRenderPolicyChanged: syncRenderSettings()
+    property bool shadowsEnabled: true
+    property string shadowResolution: "4096"
+    property int shadowFilterSamples: 32
+    property real shadowBias: 8.0
+    property real shadowFactor: 80.0
+    property string oitMode: "weighted"
+
+    // Post-processing effects
+    property bool bloomEnabled: true
+    property real bloomIntensity: 0.5
+    property real bloomThreshold: 1.0
+    property real bloomSpread: 0.65
+    property bool depthOfFieldEnabled: false
+    property real dofFocusDistance: 2200.0
+    property real dofBlurAmount: 4.0
+    property bool motionBlurEnabled: false
+    property real motionBlurAmount: 0.2
+    property bool lensFlareEnabled: false    // ✅ По умолчанию выкл, чтобы не включалось без явного сигнала
+    property bool vignetteEnabled: false      // ✅ По умолчанию выкл, чтобы не включалось без явного сигнала
+    property real vignetteStrength: 0.35
+
+    // Tonemap settings
+    property bool tonemapEnabled: true
+    property string tonemapModeName: "filmic"
+    // ✅ Новые управляемые параметры тонемаппинга
+    property real tonemapExposure: 1.0
+    property real tonemapWhitePoint: 2.0
+
+    // Material control properties
+    property color frameBaseColor: "#c53030"
+    property real frameMetalness: 0.85
+    property real frameRoughness: 0.35
+    property real frameSpecularAmount: 1.0
+    property real frameSpecularTint: 0.0
+    property real frameClearcoat: 0.22
+    property real frameClearcoatRoughness: 0.1
+    property real frameTransmission: 0.0
+    property real frameOpacity: 1.0
+    property real frameIor: 1.5
+    property real frameAttenuationDistance: 10000.0
+    property color frameAttenuationColor: "#ffffff"
+    property color frameEmissiveColor: "#000000"
+    property real frameEmissiveIntensity: 0.0
+
+    property color leverBaseColor: "#9ea4ab"
+    property real leverMetalness: 1.0
+    property real leverRoughness: 0.28
+    property real leverSpecularAmount: 1.0
+    property real leverSpecularTint: 0.0
+    property real leverClearcoat: 0.3
+    property real leverClearcoatRoughness: 0.08
+    property real leverTransmission: 0.0
+    property real leverOpacity: 1.0
+    property real leverIor: 1.5
+    property real leverAttenuationDistance: 10000.0
+    property color leverAttenuationColor: "#ffffff"
+    property color leverEmissiveColor: "#000000"
+    property real leverEmissiveIntensity: 0.0
+
+    property color tailRodBaseColor: "#d5d9df"
+    property real tailRodMetalness: 1.0
+    property real tailRodRoughness: 0.3
+    property real tailRodSpecularAmount: 1.0
+    property real tailRodSpecularTint: 0.0
+    property real tailRodClearcoat: 0.0
+    property real tailRodClearcoatRoughness: 0.0
+    property real tailRodTransmission: 0.0
+    property real tailRodOpacity: 1.0
+    property real tailRodIor: 1.5
+    property real tailRodAttenuationDistance: 10000.0
+    property color tailRodAttenuationColor: "#ffffff"
+    property color tailRodEmissiveColor: "#000000"
+    property real tailRodEmissiveIntensity: 0.0
+
+    property color cylinderBaseColor: "#e1f5ff"
+    property real cylinderMetalness: 0.0
+    property real cylinderRoughness: 0.05
+    property real cylinderSpecularAmount: 1.0
+    property real cylinderSpecularTint: 0.0
+    property real cylinderClearcoat: 0.0
+    property real cylinderClearcoatRoughness: 0.0
+    property real cylinderTransmission: 1.0
+    property real cylinderOpacity: 1.0
+    property real cylinderIor: 1.52
+    property real cylinderAttenuationDistance: 1800.0
+    property color cylinderAttenuationColor: "#b7e7ff"
+    property color cylinderEmissiveColor: "#000000"
+    property real cylinderEmissiveIntensity: 0.0
+
+    property color pistonBodyBaseColor: "#ff3c6e"
+    property color pistonBodyWarningColor: "#ff5454"
+    property real pistonBodyMetalness: 1.0
+    property real pistonBodyRoughness: 0.26
+    property real pistonBodySpecularAmount: 1.0
+    property real pistonBodySpecularTint: 0.0
+    property real pistonBodyClearcoat: 0.18
+    property real pistonBodyClearcoatRoughness: 0.06
+    property real pistonBodyTransmission: 0.0
+    property real pistonBodyOpacity: 1.0
+    property real pistonBodyIor: 1.5
+    property real pistonBodyAttenuationDistance: 10000.0
+    property color pistonBodyAttenuationColor: "#ffffff"
+    property color pistonBodyEmissiveColor: "#000000"
+    property real pistonBodyEmissiveIntensity: 0.0
+
+    property color pistonRodBaseColor: "#ececec"
+    property color pistonRodWarningColor: "#ff2a2a"
+    property real pistonRodMetalness: 1.0
+    property real pistonRodRoughness: 0.18
+    property real pistonRodSpecularAmount: 1.0
+    property real pistonRodSpecularTint: 0.0
+    property real pistonRodClearcoat: 0.12
+    property real pistonRodClearcoatRoughness: 0.05
+    property real pistonRodTransmission: 0.0
+    property real pistonRodOpacity: 1.0
+    property real pistonRodIor: 1.5
+    property real pistonRodAttenuationDistance: 10000.0
+    property color pistonRodAttenuationColor: "#ffffff"
+    property color pistonRodEmissiveColor: "#000000"
+    property real pistonRodEmissiveIntensity: 0.0
+
+    property color jointTailBaseColor: "#2a82ff"
+    property real jointTailMetalness: 0.9
+    property real jointTailRoughness: 0.35
+    property real jointTailSpecularAmount: 1.0
+    property real jointTailSpecularTint: 0.0
+    property real jointTailClearcoat: 0.1
+    property real jointTailClearcoatRoughness: 0.08
+    property real jointTailTransmission: 0.0
+    property real jointTailOpacity: 1.0
+    property real jointTailIor: 1.5
+    property real jointTailAttenuationDistance: 10000.0
+    property color jointTailAttenuationColor: "#ffffff"
+    property color jointTailEmissiveColor: "#000000"
+    property real jointTailEmissiveIntensity: 0.0
+
+    property color jointArmBaseColor: "#ff9c3a"
+    property real jointArmMetalness: 0.9
+    property real jointArmRoughness: 0.32
+    property real jointArmSpecularAmount: 1.0
+    property real jointArmSpecularTint: 0.0
+    property real jointArmClearcoat: 0.12
+    property real jointArmClearcoatRoughness: 0.08
+    property real jointArmTransmission: 0.0
+    property real jointArmOpacity: 1.0
+    property real jointArmIor: 1.5
+    property real jointArmAttenuationDistance: 10000.0
+    property color jointArmAttenuationColor: "#ffffff"
+    property color jointArmEmissiveColor: "#000000"
+    property real jointArmEmissiveIntensity: 0.0
+
+    function emissiveVector(color, intensity) {
+        if (intensity === undefined)
+            intensity = 1.0
+        if (!color)
+            return Qt.vector3d(0, 0, 0)
+        return Qt.vector3d(color.r * intensity, color.g * intensity, color.b * intensity)
+    }
+
+    // ✅ PHASE 1: Using MathUtils.clamp01 instead of local function
+    function clamp01(value) {
+        return MathUtils.clamp01(value)
+    }
+
+    property color jointRodOkColor: "#00ff55"
+    property color jointRodErrorColor: "#ff0000"
+
+    // ===============================================================
+    // ANIMATION AND GEOMETRY PROPERTIES (preserved)
+    // ===============================================================
+
+    property real animationTime: 0.0
+    property bool isRunning: false
+
+    // User-controlled animation parameters
+    property real userAmplitude: 8.0
+    property real userFrequency: 1.0
+    property real userPhaseGlobal: 0.0
+    property real userPhaseFL: 0.0
+    property real userPhaseFR: 0.0
+    property real userPhaseRL: 0.0
+    property real userPhaseRR: 0.0
+
+    // Piston positions from Python
+    property real userPistonPositionFL: 250.0
+    property real userPistonPositionFR: 250.0
+    property real userPistonPositionRL: 250.0
+    property real userPistonPositionRR: 250.0
+
+    // ✅ ОПТИМИЗИРОВАННЫЕ углы (используют кэшированные значения)
+    property real fl_angle: isRunning ? userAmplitude * animationCache.flSin : 0.0
+    property real fr_angle: isRunning ? userAmplitude * animationCache.frSin : 0.0
+    property real rl_angle: isRunning ? userAmplitude * animationCache.rlSin : 0.0
+    property real rr_angle: isRunning ? userAmplitude * animationCache.rrSin : 0.0
+
+    // Geometry parameters
+    property real userBeamSize: 120
+    property real userFrameHeight: 650
+    property real userFrameLength: 3200
+    property real userLeverLength: 800
+    property real userCylinderLength: 500
+    property real userTrackWidth: 1600
+    property real userFrameToPivot: 600
+    property real userRodPosition: 0.6
+    property real userBoreHead: 80
+    property real userBoreRod: 80
+    property real userRodDiameter: 35
+    property real userPistonThickness: 25
+    property real userPistonRodLength: 200
+
+    // ===============================================================
+    // ✅ PHASE 2: Smooth Camera Behaviors - moved to CameraState.qml
+    // ===============================================================
+
+    // ✅ Moved: 5 Behavior animations are now in CameraState.qml
+
+    // ===============================================================
+    // UTILITY FUNCTIONS (✅ PHASE 1: Using MathUtils)
+    // ===============================================================
+
+    // ✅ PHASE 1: Delegate to MathUtils
+    function clamp(v, a, b) { return MathUtils.clamp(v, a, b); }
+
+    // ✅ PHASE 1: Delegate to MathUtils (NO manual normalization!)
+    function normAngleDeg(a) {
+        return MathUtils.normalizeAngleDeg(a);
+    }
+
+    function resolveUrl(path) {
+        if (!path || path === "")
+            return "";
+        if (path.startsWith("file:") || path.startsWith("http:") || path.startsWith("https:") ||
+            path.startsWith("qrc:") || path.startsWith("data:"))
+            return path;
+        if (path.length >= 2 && path.charAt(1) === ":")
+            return "file:///" + path.replace(/\\/g, "/");
+        if (path.startsWith("/"))
+            return "file://" + path;
+        return Qt.resolvedUrl(path);
+    }
+
+    // ===============================================================
+    // ✅ PHASE 2: Camera functions - moved to CameraController
+    // ===============================================================
+
+    // ✅ Moved to CameraController:
+    // - autoFitFrame(marginFactor) → cameraController.autoFitFrame()
+    // - resetView() → cameraController.resetView()
+    // - fullResetView() → cameraController.fullResetView()
+
+    // ✅ Wrapper functions for backward compatibility:
+    function autoFitFrame(marginFactor) {
+        cameraController.autoFitFrame(marginFactor)
+    }
+
+    function resetView() {
+        cameraController.resetView()
+    }
+
+    function fullResetView() {
+        cameraController.fullResetView()
+    }
+
+    function flagCameraMotion() {
+        // Delegate to CameraController
+        cameraController.state.flagMotion()
+    }
+
+    // ===============================================================
+    // ✅ COMPLETE BATCH UPDATE SYSTEM (All functions implemented)
+    // ===============================================================
+
+    function applyBatchedUpdates(updates) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("signal_received", "applyBatchedUpdates"); } catch(e) {}
+        }
+        console.log("🚀 Applying batched updates with conflict resolution:", Object.keys(updates))
+
+        // Disable default behaviors temporarily
+        var wasAutoUpdate = autoRotate
+        autoRotate = false
+
+        try {
+            if (updates.geometry) applyGeometryUpdates(updates.geometry)
+            if (updates.animation) applyAnimationUpdates(updates.animation)
+            if (updates.lighting) applyLightingUpdates(updates.lighting)
+            if (updates.materials) applyMaterialUpdates(updates.materials)
+            if (updates.environment) applyEnvironmentUpdates(updates.environment)
+            if (updates.quality) applyQualityUpdates(updates.quality)
+            if (updates.camera) applyCameraUpdates(updates.camera)
+            if (updates.effects) applyEffectsUpdates(updates.effects)
+
+            console.log("✅ Batch updates completed successfully")
+
+            // ✅ Send ACK to Python with summary of what was applied
+            var summary = {
+                timestamp: Date.now(),
+                categories: Object.keys(updates),
+                success: true
+            }
+            root.batchUpdatesApplied(summary)
+        } finally {
+            // Restore auto behaviors
+            autoRotate = wasAutoUpdate
+        }
+    }
+
+    function applyGeometryUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyGeometryUpdates"); } catch(e) {}
+        }
+        console.log("📐 main.qml: applyGeometryUpdates() with conflict resolution")
+
+        // ✅ ИСПРАВЛЕНО: Проверяем на undefined перед применением
+        if (params.frameLength !== undefined && params.frameLength !== userFrameLength) {
+            console.log("  📏 Updating frameLength:", userFrameLength, "→", params.frameLength)
+            userFrameLength = params.frameLength
+        }
+        if (params.frameHeight !== undefined && params.frameHeight !== userFrameHeight) {
+            console.log("  📏 Updating frameHeight:", userFrameHeight, "→", params.frameHeight)
+            userFrameHeight = params.frameHeight
+        }
+        if (params.frameBeamSize !== undefined && params.frameBeamSize !== userBeamSize) {
+            console.log("  📏 Updating frameBeamSize:", userBeamSize, "→", params.frameBeamSize)
+            userBeamSize = params.frameBeamSize
+        }
+        if (params.leverLength !== undefined && params.leverLength !== userLeverLength) {
+            console.log("  📏 Updating leverLength:", userLeverLength, "→", params.leverLength)
+            userLeverLength = params.leverLength
+        }
+        if (params.cylinderBodyLength !== undefined && params.cylinderBodyLength !== userCylinderLength) {
+            console.log("  📏 Updating cylinderLength:", userCylinderLength, "→", params.cylinderBodyLength)
+            userCylinderLength = params.cylinderBodyLength
+        }
+        if (params.trackWidth !== undefined && params.trackWidth !== userTrackWidth) {
+            console.log("  📏 Updating trackWidth:", userTrackWidth, "→", params.trackWidth)
+            userTrackWidth = params.trackWidth
+        }
+        if (params.frameToPivot !== undefined && params.frameToPivot !== userFrameToPivot) {
+            console.log("  📏 Updating frameToPivot:", userFrameToPivot, "→", params.frameToPivot)
+            userFrameToPivot = params.frameToPivot
+        }
+        if (params.rodPosition !== undefined && params.rodPosition !== userRodPosition) {
+            console.log("  ✨ КРИТИЧЕСКИЙ: Updating rodPosition:", userRodPosition, "→", params.rodPosition)
+            userRodPosition = params.rodPosition
+        }
+
+        // ✅ ДОПОЛНИТЕЛЬНЫЕ ПАРАМЕТРЫ ГЕОМЕТРИИ, ПРИХОДЯЩИЕ ИЗ PYTHON (мм)
+        if (params.boreHead !== undefined) userBoreHead = Number(params.boreHead)
+        if (params.boreRod !== undefined) userBoreRod = Number(params.boreRod)
+        if (params.rodDiameter !== undefined) userRodDiameter = Number(params.rodDiameter)
+        if (params.pistonThickness !== undefined) userPistonThickness = Number(params.pistonThickness)
+        if (params.pistonRodLength !== undefined) userPistonRodLength = Number(params.pistonRodLength)
+
+        // ✅ ПОДДЕРЖКА АЛЬТЕРНАТИВНЫХ КЛЮЧЕЙ (исторически) — уже в мм
+        if (params.cylDiamM !== undefined) userBoreHead = Number(params.cylDiamM)
+        if (params.rodDiameterM !== undefined) userRodDiameter = Number(params.rodDiameterM)
+        if (params.pistonThicknessM !== undefined) userPistonThickness = Number(params.pistonThicknessM)
+        if (params.pistonRodLengthM !== undefined) userPistonRodLength = Number(params.pistonRodLengthM)
+
+        if (params.cylinderSegments !== undefined) {
+            var newSegments = Math.floor(params.cylinderSegments)
+            if (!isNaN(newSegments))
+                cylinderSegments = Math.max(3, newSegments)
+        }
+        if (params.cylinderRings !== undefined) {
+            var newRings = Math.floor(params.cylinderRings)
+            if (!isNaN(newRings))
+                cylinderRings = Math.max(1, newRings)
+        }
+
+        // ✅ ИСПРАВЛЕНО: Сброс вида только при значительных изменениях геометрии
+        var shouldResetView = (params.frameLength !== undefined ||
+                              params.frameHeight !== undefined ||
+                              params.trackWidth !== undefined)
+
+        if (shouldResetView) {
+            console.log("  🔄 Significant geometry change - resetting view")
+            resetView()
+        } else {
+            console.log("  ✅ Minor geometry change - view preserved")
+        }
+
+        console.log("  ✅ Geometry updated successfully")
+    }
+
+    function applyAnimationUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyAnimationUpdates"); } catch(e) {}
+        }
+        console.log("🎬 main.qml: applyAnimationUpdates() called")
+        if (params.amplitude !== undefined) userAmplitude = params.amplitude
+        if (params.frequency !== undefined) userFrequency = params.frequency
+        if (params.phase !== undefined) userPhaseGlobal = params.phase
+        if (params.lf_phase !== undefined) userPhaseFL = params.lf_phase
+        if (params.rf_phase !== undefined) userPhaseFR = params.rf_phase
+        if (params.lr_phase !== undefined) userPhaseRL = params.lr_phase
+        if (params.rr_phase !== undefined) userPhaseRR = params.rr_phase
+        console.log("  ✅ Animation updated successfully")
+    }
+
+    function applyLightingUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyLightingUpdates"); } catch(e) {}
+        }
+        console.log("💡 main.qml: applyLightingUpdates() called")
+        if (params.key_light) {
+            if (params.key_light.brightness !== undefined) keyLightBrightness = params.key_light.brightness
+            if (params.key_light.color !== undefined) keyLightColor = params.key_light.color
+            if (params.key_light.angle_x !== undefined) keyLightAngleX = params.key_light.angle_x
+            if (params.key_light.angle_y !== undefined) keyLightAngleY = params.key_light.angle_y
+            if (params.key_light.casts_shadow !== undefined) keyLightCastsShadow = !!params.key_light.casts_shadow
+            if (params.key_light.bind_to_camera !== undefined) keyLightBindToCamera = !!params.key_light.bind_to_camera
+            if (params.key_light.position_x !== undefined) keyLightPosX = Number(params.key_light.position_x)
+            if (params.key_light.position_y !== undefined) keyLightPosY = Number(params.key_light.position_y)
+        }
+        if (params.fill_light) {
+            if (params.fill_light.brightness !== undefined) fillLightBrightness = params.fill_light.brightness
+            if (params.fill_light.color !== undefined) fillLightColor = params.fill_light.color
+            if (params.fill_light.casts_shadow !== undefined) fillLightCastsShadow = !!params.fill_light.casts_shadow
+            if (params.fill_light.bind_to_camera !== undefined) fillLightBindToCamera = !!params.fill_light.bind_to_camera
+            if (params.fill_light.position_x !== undefined) fillLightPosX = Number(params.fill_light.position_x)
+            if (params.fill_light.position_y !== undefined) fillLightPosY = Number(params.fill_light.position_y)
+        }
+        if (params.rim_light) {
+            if (params.rim_light.brightness !== undefined) rimLightBrightness = params.rim_light.brightness
+            if (params.rim_light.color !== undefined) rimLightColor = params.rim_light.color
+            if (params.rim_light.casts_shadow !== undefined) rimLightCastsShadow = !!params.rim_light.casts_shadow
+            if (params.rim_light.bind_to_camera !== undefined) rimLightBindToCamera = !!params.rim_light.bind_to_camera
+            if (params.rim_light.position_x !== undefined) rimLightPosX = Number(params.rim_light.position_x)
+            if (params.rim_light.position_y !== undefined) rimLightPosY = Number(params.rim_light.position_y)
+        }
+        if (params.point_light) {
+            if (params.point_light.brightness !== undefined) pointLightBrightness = params.point_light.brightness
+            if (params.point_light.color !== undefined) pointLightColor = params.point_light.color
+            if (params.point_light.position_x !== undefined) pointLightX = Number(params.point_light.position_x)
+            if (params.point_light.position_y !== undefined) pointLightY = Number(params.pointLight.position_y)
+            if (params.point_light.range !== undefined) pointLightRange = Math.max(1, params.point_light.range)
+            if (params.point_light.casts_shadow !== undefined) pointLightCastsShadow = !!params.point_light.casts_shadow
+            if (params.point_light.bind_to_camera !== undefined) pointLightBindToCamera = !!params.point_light.bind_to_camera
+        }
+        console.log("  ✅ Lighting updated successfully")
+    }
+
+    function applyMaterialUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyMaterialUpdates"); } catch(e) {}
+        }
+        console.log("🎨 main.qml: applyMaterialUpdates() called")
+        function applyCommon(values, prefix) {
+            if (values.base_color !== undefined) root[prefix + "BaseColor"] = values.base_color
+            if (values.metalness !== undefined) root[prefix + "Metalness"] = values.metalness
+            if (values.roughness !== undefined) root[prefix + "Roughness"] = values.roughness
+            if (values.specular !== undefined) root[prefix + "SpecularAmount"] = values.specular
+            if (values.specular_tint !== undefined) root[prefix + "SpecularTint"] = values.specular_tint
+            if (values.clearcoat !== undefined) root[prefix + "Clearcoat"] = values.clearcoat
+            if (values.clearcoat_roughness !== undefined) root[prefix + "ClearcoatRoughness"] = values.clearcoat_roughness
+            if (values.transmission !== undefined) root[prefix + "Transmission"] = values.transmission
+            if (values.opacity !== undefined) root[prefix + "Opacity"] = values.opacity
+            if (values.ior !== undefined) root[prefix + "Ior"] = values.ior
+            if (values.attenuation_distance !== undefined) root[prefix + "AttenuationDistance"] = values.attenuation_distance
+            if (values.attenuation_color !== undefined) root[prefix + "AttenuationColor"] = values.attenuation_color
+            if (values.emissive_color !== undefined) root[prefix + "EmissiveColor"] = values.emissive_color
+            if (values.emissive_intensity !== undefined) root[prefix + "EmissiveIntensity"] = values.emissive_intensity
+        }
+
+        if (params.frame !== undefined) applyCommon(params.frame, "frame")
+        if (params.lever !== undefined) applyCommon(params.lever, "lever")
+        if (params.tail !== undefined) applyCommon(params.tail, "tailRod")
+        if (params.cylinder !== undefined) applyCommon(params.cylinder, "cylinder")
+        if (params.piston_body !== undefined) {
+            applyCommon(params.piston_body, "pistonBody")
+            if (params.piston_body.warning_color !== undefined) pistonBodyWarningColor = params.piston_body.warning_color
+        }
+        if (params.piston_rod !== undefined) {
+            applyCommon(params.piston_rod, "pistonRod")
+            if (params.piston_rod.warning_color !== undefined) pistonRodWarningColor = params.piston_rod.warning_color
+        }
+        if (params.joint_tail !== undefined) {
+            applyCommon(params.joint_tail, "jointTail")
+            if (params.joint_tail.ok_color !== undefined) jointRodOkColor = params.joint_tail.ok_color
+            if (params.joint_tail.error_color !== undefined) jointRodErrorColor = params.joint_tail.error_color
+        }
+        if (params.joint_arm !== undefined) {
+            applyCommon(params.joint_arm, "jointArm")
+        }
+
+        console.log("  ✅ Materials updated successfully")
+    }
+
+    // ✅ НОВОЕ: Функция для обновления качества рендеринга
+    function applyQualityUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyQualityUpdates"); } catch(e) {}
+        }
+        console.log("⚙️ main.qml: applyQualityUpdates() called")
+
+        // Shadows
+        if (params.shadows) {
+            if (params.shadows.enabled !== undefined) shadowsEnabled = !!params.shadows.enabled
+            if (params.shadows.resolution !== undefined) shadowResolution = String(params.shadows.resolution)
+            if (params.shadows.filter !== undefined) shadowFilterSamples = Number(params.shadows.filter)
+            if (params.shadows.bias !== undefined) shadowBias = Number(params.shadows.bias)
+            if (params.shadows.darkness !== undefined) shadowFactor = Number(params.shadows.darkness)
+        }
+
+        // Antialiasing
+        if (params.antialiasing) {
+            var aa = params.antialiasing
+            if (aa.primary !== undefined) {
+                aaPrimaryMode = String(aa.primary)
+                console.log("  🔧 AA primary mode:", aaPrimaryMode)
+            }
+            if (aa.quality !== undefined) {
+                aaQualityLevel = String(aa.quality)
+                console.log("  🔧 AA quality level:", aaQualityLevel)
+            }
+            if (aa.post !== undefined) {
+                aaPostMode = String(aa.post)
+                console.log("  🔧 AA post mode:", aaPostMode)
+            }
+        }
+
+        // TAA settings
+        if (params.taa_enabled !== undefined) taaEnabled = !!params.taa_enabled
+        if (params.taa_strength !== undefined) taaStrength = Number(params.taa_strength)
+        if (params.taa_motion_adaptive !== undefined) taaMotionAdaptive = !!params.taa_motion_adaptive
+
+        // FXAA
+        if (params.fxaa_enabled !== undefined) fxaaEnabled = !!params.fxaa_enabled
+
+        // Specular AA
+        if (params.specular_aa !== undefined) specularAAEnabled = !!params.specular_aa
+
+        // Dithering (Qt 6.10+)
+        if (params.dithering !== undefined && canUseDithering) {
+            ditheringEnabled = !!params.dithering
+        }
+
+        // Rendering settings
+        if (params.render_scale !== undefined) renderScale = Number(params.render_scale)
+        if (params.render_policy !== undefined) renderPolicy = String(params.render_policy)
+        if (params.frame_rate_limit !== undefined) frameRateLimit = Number(params.frame_rate_limit)
+
+        // OIT
+        if (params.oit !== undefined) oitMode = String(params.oit)
+
+        console.log("  ✅ Quality updated successfully")
+    }
+
+    // ✅ НОВОЕ: Функция для обновления эффектов
+    function applyEffectsUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyEffectsUpdates"); } catch(e) {}
+        }
+        console.log("✨ main.qml: applyEffectsUpdates() called")
+
+        // Bloom
+        if (params.bloom_enabled !== undefined) bloomEnabled = !!params.bloom_enabled
+        if (params.bloom_intensity !== undefined) bloomIntensity = Number(params.bloom_intensity)
+        if (params.bloom_threshold !== undefined) bloomThreshold = Number(params.bloom_threshold)
+        if (params.bloom_spread !== undefined) bloomSpread = Number(params.bloom_spread)
+
+        // SSAO
+        if (params.ssao_enabled !== undefined) ssaoEnabled = !!params.ssao_enabled
+        if (params.ssao_strength !== undefined) ssaoIntensity = Number(params.ssao_strength)
+        if (params.ssao_radius !== undefined) ssaoRadius = Number(params.ssao_radius)
+
+        // Depth of Field
+        if (params.depth_of_field !== undefined) depthOfFieldEnabled = !!params.depth_of_field
+        if (params.dof_focus_distance !== undefined) dofFocusDistance = Number(params.dof_focus_distance)
+        if (params.dof_blur !== undefined) dofBlurAmount = Number(params.dof_blur)
+
+        // Motion Blur
+        if (params.motion_blur !== undefined) motionBlurEnabled = !!params.motion_blur
+        if (params.motion_blur_amount !== undefined) motionBlurAmount = Number(params.motion_blur_amount)
+
+        // Lens Flare
+        if (params.lens_flare !== undefined) lensFlareEnabled = !!params.lens_flare
+
+        // Vignette
+        if (params.vignette !== undefined) vignetteEnabled = !!params.vignette
+        if (params.vignette_strength !== undefined) vignetteStrength = Number(params.vignette_strength)
+
+        // Tonemap
+        if (params.tonemap_enabled !== undefined) tonemapEnabled = !!params.tonemap_enabled
+        if (params.tonemap_mode !== undefined) tonemapModeName = String(params.tonemap_mode)
+        if (params.tonemap_exposure !== undefined) tonemapExposure = Number(params.tonemap_exposure)
+        if (params.tonemap_white_point !== undefined) tonemapWhitePoint = Number(params.tonemap_white_point)
+
+        console.log("  ✅ Effects updated successfully")
+    }
+
+    // ✅ НОВОЕ: Функция для обновления камеры
+    function applyCameraUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyCameraUpdates"); } catch(e) {}
+        }
+        console.log("📷 main.qml: applyCameraUpdates() called")
+
+        if (params.fov !== undefined) cameraFov = Number(params.fov)
+        if (params.near !== undefined) cameraNear = Number(params.near)
+        if (params.far !== undefined) cameraFar = Number(params.far)
+        if (params.speed !== undefined) cameraSpeed = Number(params.speed)
+        if (params.auto_rotate !== undefined) autoRotate = !!params.auto_rotate
+        if (params.auto_rotate_speed !== undefined) autoRotateSpeed = Number(params.auto_rotate_speed)
+
+        console.log("  ✅ Camera updated successfully")
+    }
+
+    // ✅ ПОЛНАЯ реализация updateEnvironment()
+    function applyEnvironmentUpdates(params) {
+        if (typeof window !== 'undefined' && window && window.logQmlEvent) {
+            try { window.logQmlEvent("function_called", "applyEnvironmentUpdates"); } catch(e) {}
+        }
+
+        // ✅ ДЕТАЛЬНЫЙ ЛОГ НАЧАЛЬНОГО СОСТОЯНИЯ
+        console.log("🌍 ═══ applyEnvironmentUpdates START ═══")
+        console.log("  📥 Входные параметры:", JSON.stringify(params))
+        console.log("  📊 ТЕКУЩЕЕ состояние ДО обновления:")
+        console.log("     iblEnabled:", iblEnabled)
+        console.log("     iblLightingEnabled:", iblLightingEnabled)
+        console.log("     iblBackgroundEnabled:", iblBackgroundEnabled)
+        console.log("     iblRotationDeg:", iblRotationDeg)
+        console.log("     iblIntensity:", iblIntensity)
+
+        // --- Backward-compatible flat keys ---
+        if (params.background_mode !== undefined) backgroundMode = params.background_mode
+        if (params.background_color !== undefined) backgroundColor = params.background_color
+
+        // ✅ CRITICAL FIX v4.9.5: НЕЗАВИСИМЫЕ ФЛАГИ - каждый управляется отдельно!
+        // Master флаг ibl_enabled больше НЕ влияет на lighting/background флаги
+        if (params.ibl_enabled !== undefined) {
+            iblEnabled = !!params.ibl_enabled
+            console.log("  🔧 IBL master enabled обновлен:", iblEnabled)
+            // ❌ ВАЖНО: НЕ копируем в iblLightingEnabled!
+            // Каждый флаг теперь полностью независим
+        }
+
+        // ✅ РАЗДЕЛЬНОЕ УПРАВЛЕНИЕ через плоские ключи
+        if (params.ibl_lighting_enabled !== undefined) {
+            iblLightingEnabled = !!params.ibl_lighting_enabled
+            console.log("  💡 IBL lighting обновлен:", iblLightingEnabled)
+        }
+
+        if (params.ibl_background_enabled !== undefined) {
+            iblBackgroundEnabled = !!params.ibl_background_enabled
+            console.log("  🎨 IBL background обновлен:", iblBackgroundEnabled)
+        }
+
+        if (params.skybox_enabled !== undefined) {
+            iblBackgroundEnabled = !!params.skybox_enabled
+            console.log("  🌌 Skybox обновлен:", iblBackgroundEnabled)
+        }
+
+        if (params.ibl_intensity !== undefined) {
+            iblIntensity = Number(params.ibl_intensity)
+            console.log("  ✨ IBL intensity обновлен:", iblIntensity)
+        }
+
+        if (params.ibl_rotation !== undefined) {
+            iblRotationDeg = Number(params.ibl_rotation)
+            console.log("  🔄 IBL rotation обновлен:", iblRotationDeg)
+        }
+
+        if (params.ibl_source !== undefined && params.ibl_source) {
+            iblPrimarySource = resolveUrl(params.ibl_source)
+            console.log("  📁 IBL source обновлен:", iblPrimarySource)
+        }
+
+        if (params.ibl_fallback !== undefined && params.ibl_fallback) {
+            iblFallbackSource = resolveUrl(params.ibl_fallback)
+            console.log("  📁 IBL fallback обновлен:", iblFallbackSource)
+        }
+
+        if (params.fog_enabled !== undefined) fogEnabled = !!params.fog_enabled
+        if (params.fog_color !== undefined) fogColor = params.fog_color
+        if (params.fog_density !== undefined) fogDensity = Number(params.fog_density)
+        if (params.fog_near !== undefined) fogNear = Number(params.fog_near)
+        if (params.fog_far !== undefined) fogFar = Number(params.fog_far)
+        if (params.ao_enabled !== undefined) ssaoEnabled = !!params.ao_enabled
+        if (params.ao_radius !== undefined) ssaoRadius = Number(params.ao_radius)
+        if (params.ao_strength !== undefined) ssaoIntensity = Number(params.ao_strength)
+
+        // --- New nested structure from Python panel ---
+        if (params.background) {
+            const bg = params.background
+            if (bg.mode !== undefined) backgroundMode = bg.mode
+            if (bg.color !== undefined) backgroundColor = bg.color
+            if (bg.skybox_enabled !== undefined) {
+                iblBackgroundEnabled = !!bg.skybox_enabled
+                console.log("  🌌 Skybox (from bg) обновлен:", iblBackgroundEnabled)
+            }
+        }
+
+        if (params.ibl) {
+            const ibl = params.ibl
+
+            // ✅ CRITICAL FIX v4.9.5: Master флаг больше НЕ влияет на подфлаги!
+            if (ibl.enabled !== undefined) {
+                iblEnabled = !!ibl.enabled
+                console.log("  🔧 IBL master (nested) обновлен:", iblEnabled)
+                // ❌ КРИТИЧНО: НЕ переопределяем lighting/background!
+                // Они управляются НЕЗАВИСИМО через свои собственные ключи
+            }
+
+            // ✅ НЕЗАВИСИМОЕ УПРАВЛЕНИЕ через вложенные ключи
+            if (ibl.lighting_enabled !== undefined) {
+                iblLightingEnabled = !!ibl.lighting_enabled
+                console.log("  💡 IBL lighting (nested) обновлен:", iblLightingEnabled)
+            }
+
+            if (ibl.background_enabled !== undefined) {
+                iblBackgroundEnabled = !!ibl.background_enabled
+                console.log("  🎨 IBL background (nested) обновлен:", iblBackgroundEnabled)
+            }
+
+            if (ibl.intensity !== undefined) {
+                iblIntensity = Number(ibl.intensity)
+                console.log("  ✨ IBL intensity (nested) обновлен:", iblIntensity)
+            }
+
+            if (ibl.rotation !== undefined) {
+                iblRotationDeg = Number(ibl.rotation)
+                console.log("  🔄 IBL rotation (nested) обновлен:", iblRotationDeg)
+            }
+
+            if (ibl.source !== undefined && ibl.source) {
+                iblPrimarySource = resolveUrl(ibl.source)
+                console.log("  📁 IBL source (nested) обновлен:", iblPrimarySource)
+            }
+
+            if (ibl.fallback !== undefined && ibl.fallback) {
+                iblFallbackSource = resolveUrl(ibl.fallback)
+                console.log("  📁 IBL fallback (nested) обновлен:", iblFallbackSource)
+            }
+            // offset_x/offset_y/bind_to_camera пока не используются, оставляем для совместимости
+        }
+
+        if (params.fog) {
+            const fog = params.fog
+            if (fog.enabled !== undefined) fogEnabled = !!fog.enabled
+            if (fog.color !== undefined) fogColor = fog.color
+            if (fog.density !== undefined) fogDensity = Number(fog.density)
+            if (fog.near !== undefined) fogNear = Number(fog.near)
+            if (fog.far !== undefined) fogFar = Number(fog.far)
+        }
+
+        if (params.ambient_occlusion) {
+            const ao = params.ambient_occlusion
+            if (ao.enabled !== undefined) ssaoEnabled = !!ao.enabled
+            if (ao.radius !== undefined) ssaoRadius = Number(ao.radius)
+            if (ao.strength !== undefined) ssaoIntensity = Number(ao.strength)
+        }
+
+        // ✅ ФИНАЛЬНЫЙ ЛОГ СОСТОЯНИЯ
+        console.log("  📊 ФИНАЛЬНОЕ состояние ПОСЛЕ обновления:")
+        console.log("     iblEnabled:", iblEnabled)
+        console.log("     iblLightingEnabled:", iblLightingEnabled)
+        console.log("     iblBackgroundEnabled:", iblBackgroundEnabled)
+        console.log("     iblRotationDeg:", iblRotationDeg)
+        console.log("     iblIntensity:", iblIntensity)
+        console.log("🌍 ═══ applyEnvironmentUpdates END ═══")
+    }
+
+    View3D {
+        id: view3d
+        anchors.fill: parent
+
+        environment: ExtendedSceneEnvironment {
+            id: mainEnvironment
+            // Показ фона зависит ТОЛЬКО от чекбокса skybox_enabled и готовности IBL
+            backgroundMode: (iblBackgroundEnabled && iblReady) ? SceneEnvironment.SkyBox : SceneEnvironment.Color
+            clearColor: root.backgroundColor
+            // ✅ Фон (skybox) теперь НЕ зависит от lightProbe и остаётся при выключенном IBL освещении
+            // Используем HDR-пробу напрямую для кубкарты фона
+            skyBoxCubeMap: (iblBackgroundEnabled && iblReady) ? iblLoader.probe : null
+            // ✅ ИСПРАВЛЕНО: чекбокс IBL управляет ТОЛЬКО освещением
+            // Освещение от IBL зависит от iblLightingEnabled, а фон — от iblBackgroundEnabled
+            lightProbe: (iblLightingEnabled && iblReady) ? iblLoader.probe : null
+            probeExposure: root.iblIntensity
+            probeOrientation: Qt.vector3d(0, root.iblRotationDeg, 0)
+
+            // ✅ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Добавлены настройки антиалиасинга!
+            antialiasingMode: {
+                if (root.aaPrimaryMode === "ssaa") return SceneEnvironment.SSAA
+                if (root.aaPrimaryMode === "msaa") return SceneEnvironment.MSAA
+                if (root.aaPrimaryMode === "progressive") return SceneEnvironment.ProgressiveAA
+                return SceneEnvironment.NoAA
+            }
+            antialiasingQuality: {
+                if (root.aaQualityLevel === "high") return SceneEnvironment.High
+                if (root.aaQualityLevel === "medium") return SceneEnvironment.Medium
+                if (root.aaQualityLevel === "low") return SceneEnvironment.Low
+                return SceneEnvironment.Medium
+            }
+
+            // ✅ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Post-processing AA
+            temporalAAEnabled: (root.aaPostMode === "taa" && root.taaEnabled && (!root.taaMotionAdaptive || root.cameraIsMoving))
+            temporalAAStrength: root.taaStrength
+            fxaaEnabled: (root.aaPostMode === "fxaa" || root.fxaaEnabled)
+            specularAAEnabled: root.canUseSpecularAA && root.specularAAEnabled
+
+            // ✅ Dithering (Qt 6.10+)
+            Component.onCompleted: {
+                if (root.canUseDithering) {
+                    console.log("✅ Qt 6.10+ - enabling dithering")
+                    mainEnvironment.ditheringEnabled = Qt.binding(function() {
+                        return root.ditheringEnabled
+                    })
+                } else {
+                    console.log("⚠️ Qt < 6.10 - dithering not available")
+                }
+            }
+
+            // Fog (Qt 6.10+)
+            fog: Fog {
+                enabled: root.fogEnabled
+                color: root.fogColor
+                depthEnabled: true
+                depthNear: root.fogNear
+                depthFar: root.fogFar
+                depthCurve: 1.0
+            }
+
+            // Tonemap
+            tonemapMode: tonemapEnabled ? (
+                tonemapModeName === "filmic" ? SceneEnvironment.TonemapModeFilmic :
+                tonemapModeName === "aces" ? SceneEnvironment.TonemapModeFilmic : // безопасный фоллбэк
+                tonemapModeName === "reinhard" ? SceneEnvironment.TonemapModeReinhard :
+                tonemapModeName === "gamma" ? SceneEnvironment.TonemapModeLinear : // безопасный фоллбэк
+                tonemapModeName === "linear" ? SceneEnvironment.TonemapModeLinear : SceneEnvironment.TonemapModeNone
+            ) : SceneEnvironment.TonemapModeNone
+            exposure: root.tonemapExposure
+            whitePoint: root.tonemapWhitePoint
+
+            // Bloom / SSAO
+            glowEnabled: root.bloomEnabled
+            glowIntensity: root.bloomIntensity
+            glowHDRMinimumValue: root.bloomThreshold
+            glowBloom: root.bloomSpread
+            glowQualityHigh: true
+            glowUseBicubicUpscale: true
+            glowHDRMaximumValue: 8.0
+            glowHDRScale: 2.0
+
+            aoEnabled: root.ssaoEnabled
+            aoDistance: root.ssaoRadius
+            aoStrength: root.ssaoIntensity * 100
+            aoSoftness: 20
+            aoDither: true
+            aoSampleRate: 3
+
+            // Depth of Field
+            depthOfFieldEnabled: root.depthOfFieldEnabled
+            depthOfFieldFocusDistance: root.dofFocusDistance
+            depthOfFieldBlurAmount: root.dofBlurAmount
+
+            // Vignette
+            vignetteEnabled: root.vignetteEnabled
+            vignetteStrength: root.vignetteStrength
+            vignetteRadius: 0.4
+
+            // Lens Flare
+            lensFlareEnabled: root.lensFlareEnabled
+            lensFlareGhostCount: 3
+            lensFlareGhostDispersal: 0.6
+            lensFlareHaloWidth: 0.25
+            lensFlareBloomBias: 0.35
+            lensFlareStretchToAspect: 1.0
+
+            // OIT (Order Independent Transparency)
+            oitMethod: root.oitMode === "weighted" ? SceneEnvironment.OITWeightedBlended : SceneEnvironment.OITNone
+
+            // Color adjustments
+            colorAdjustmentsEnabled: true
+            adjustmentBrightness: 1.0
+            adjustmentContrast: 1.05
+            adjustmentSaturation: 1.05
+        }
+
+        Node {
+            id: worldRoot
+        }
+
+        // ===============================================================
+        // ✅ MATERIAL LIBRARY - ЦЕНТРАЛИЗОВАННОЕ УПРАВЛЕНИЕ
+        // ===============================================================
+
+        SharedMaterials {
+            id: materials
+
+            // ✅ Bind все root properties материалов
+            frameBaseColor: root.frameBaseColor
+            frameMetalness: root.frameMetalness
+            frameRoughness: root.frameRoughness
+            frameSpecularAmount: root.frameSpecularAmount
+            frameSpecularTint: root.frameSpecularTint
+            frameClearcoat: root.frameClearcoat
+            frameClearcoatRoughness: root.frameClearcoatRoughness
+            frameTransmission: root.frameTransmission
+            frameOpacity: root.frameOpacity
+            frameIor: root.frameIor
+            frameAttenuationDistance: root.frameAttenuationDistance
+            frameAttenuationColor: root.frameAttenuationColor
+            frameEmissiveColor: root.frameEmissiveColor
+            frameEmissiveIntensity: root.frameEmissiveIntensity
+
+            leverBaseColor: root.leverBaseColor
+            leverMetalness: root.leverMetalness
+            leverRoughness: root.leverRoughness
+            leverSpecularAmount: root.leverSpecularAmount
+            leverSpecularTint: root.leverSpecularTint
+            leverClearcoat: root.leverClearcoat
+            leverClearcoatRoughness: root.leverClearcoatRoughness
+            leverTransmission: root.leverTransmission
+            leverOpacity: root.leverOpacity
+            leverIor: root.leverIor
+            leverAttenuationDistance: root.leverAttenuationDistance
+            leverAttenuationColor: root.leverAttenuationColor
+            leverEmissiveColor: root.leverEmissiveColor
+            leverEmissiveIntensity: root.leverEmissiveIntensity
+
+            tailRodBaseColor: root.tailRodBaseColor
+            tailRodMetalness: root.tailRodMetalness
+            tailRodRoughness: root.tailRodRoughness
+            tailRodSpecularAmount: root.tailRodSpecularAmount
+            tailRodSpecularTint: root.tailRodSpecularTint
+            tailRodClearcoat: root.tailRodClearcoat
+            tailRodClearcoatRoughness: root.tailRodClearcoatRoughness
+            tailRodTransmission: root.tailRodTransmission
+            tailRodOpacity: root.tailRodOpacity
+            tailRodIor: root.tailRodIor
+            tailRodAttenuationDistance: root.tailRodAttenuationDistance
+            tailRodAttenuationColor: root.tailRodAttenuationColor
+            tailRodEmissiveColor: root.tailRodEmissiveColor
+            tailRodEmissiveIntensity: root.tailRodEmissiveIntensity
+
+            cylinderBaseColor: root.cylinderBaseColor
+            cylinderMetalness: root.cylinderMetalness
+            cylinderRoughness: root.cylinderRoughness
+            cylinderSpecularAmount: root.cylinderSpecularAmount
+            cylinderSpecularTint: root.cylinderSpecularTint
+            cylinderClearcoat: root.cylinderClearcoat
+            cylinderClearcoatRoughness: root.cylinderClearcoatRoughness
+            cylinderTransmission: root.cylinderTransmission
+            cylinderOpacity: root.cylinderOpacity
+            cylinderIor: root.cylinderIor
+            cylinderAttenuationDistance: root.cylinderAttenuationDistance
+            cylinderAttenuationColor: root.cylinderAttenuationColor
+            cylinderEmissiveColor: root.cylinderEmissiveColor
+            cylinderEmissiveIntensity: root.cylinderEmissiveIntensity
+
+            pistonBodyBaseColor: root.pistonBodyBaseColor
+            pistonBodyWarningColor: root.pistonBodyWarningColor
+            pistonBodyMetalness: root.pistonBodyMetalness
+            pistonBodyRoughness: root.pistonBodyRoughness
+            pistonBodySpecularAmount: root.pistonBodySpecularAmount
+            pistonBodySpecularTint: root.pistonBodySpecularTint
+            pistonBodyClearcoat: root.pistonBodyClearcoat
+            pistonBodyClearcoatRoughness: root.pistonBodyClearcoatRoughness
+            pistonBodyTransmission: root.pistonBodyTransmission
+            pistonBodyOpacity: root.pistonBodyOpacity
+            pistonBodyIor: root.pistonBodyIor
+            pistonBodyAttenuationDistance: root.pistonBodyAttenuationDistance
+            pistonBodyAttenuationColor: root.pistonBodyAttenuationColor
+            pistonBodyEmissiveColor: root.pistonBodyEmissiveColor
+            pistonBodyEmissiveIntensity: root.pistonBodyEmissiveIntensity
+
+            pistonRodBaseColor: root.pistonRodBaseColor
+            pistonRodWarningColor: root.pistonRodWarningColor
+            pistonRodMetalness: root.pistonRodMetalness
+            pistonRodRoughness: root.pistonRodRoughness
+            pistonRodSpecularAmount: root.pistonRodSpecularAmount
+            pistonRodSpecularTint: root.pistonRodSpecularTint
+            pistonRodClearcoat: root.pistonRodClearcoat
+            pistonRodClearcoatRoughness: root.pistonRodClearcoatRoughness
+            pistonRodTransmission: root.pistonRodTransmission
+            pistonRodOpacity: root.pistonRodOpacity
+            pistonRodIor: root.pistonRodIor
+            pistonRodAttenuationDistance: root.pistonRodAttenuationDistance
+            pistonRodAttenuationColor: root.pistonRodAttenuationColor
+            pistonRodEmissiveColor: root.pistonRodEmissiveColor
+            pistonRodEmissiveIntensity: root.pistonRodEmissiveIntensity
+
+            jointTailBaseColor: root.jointTailBaseColor
+            jointTailMetalness: root.jointTailMetalness
+            jointTailRoughness: root.jointTailRoughness
+            jointTailSpecularAmount: root.jointTailSpecularAmount
+            jointTailSpecularTint: root.jointTailSpecularTint
+            jointTailClearcoat: root.jointTailClearcoat
+            jointTailClearcoatRoughness: root.jointTailClearcoatRoughness
+            jointTailTransmission: root.jointTailTransmission
+            jointTailOpacity: root.jointTailOpacity
+            jointTailIor: root.jointTailIor
+            jointTailAttenuationDistance: root.jointTailAttenuationDistance
+            jointTailAttenuationColor: root.jointTailAttenuationColor
+            jointTailEmissiveColor: root.jointTailEmissiveColor
+            jointTailEmissiveIntensity: root.jointTailEmissiveIntensity
+
+            jointArmBaseColor: root.jointArmBaseColor
+            jointArmMetalness: root.jointArmMetalness
+            jointArmRoughness: root.jointArmRoughness
+            jointArmSpecularAmount: root.jointArmSpecularAmount
+            jointArmSpecularTint: root.jointArmSpecularTint
+            jointArmClearcoat: root.jointArmClearcoat
+            jointArmClearcoatRoughness: root.jointArmClearcoatRoughness
+            jointArmTransmission: root.jointArmTransmission
+            jointArmOpacity: root.jointArmOpacity
+            jointArmIor: root.jointArmIor
+            jointArmAttenuationDistance: root.jointArmAttenuationDistance
+            jointArmAttenuationColor: root.jointArmAttenuationColor
+            jointArmEmissiveColor: root.jointArmEmissiveColor
+            jointArmEmissiveIntensity: root.jointArmEmissiveIntensity
+
+            jointRodOkColor: root.jointRodOkColor
+            property color jointRodErrorColor: "#ff0000"
+        }
+
+    // ===============================================================
+    // ✅ PHASE 2: CAMERA SYSTEM (CameraController module)
+    // ===============================================================
+
+        CameraController {
+            id: cameraController
+            worldRoot: worldRoot
+            view3d: view3d
+
+            // ✅ Bind to geometry for pivot/fit calculations
+            frameLength: root.userFrameLength
+            frameHeight: root.userFrameHeight
+            beamSize: root.userBeamSize
+            trackWidth: root.userTrackWidth
+
+            // ✅ Bind to TAA for motion detection
+            taaMotionAdaptive: root.taaMotionAdaptive
+
+            // ✅ Callback for animation toggle
+            onToggleAnimation: {
+                root.isRunning = !root.isRunning
+            }
+
+            // ✅ Initial camera state
+            Component.onCompleted: {
+                // Sync camera settings from root to CameraState
+                state.fov = root.cameraFov
+                state.nearPlane = root.cameraNear
+                state.farPlane = root.cameraFar
+                state.speed = root.cameraSpeed
+                state.autoRotate = root.autoRotate
+                state.autoRotateSpeed = root.autoRotateSpeed
+
+                console.log("📷 Camera initialized: distance =", state.distance, "yaw =", state.yawDeg, "pitch =", state.pitchDeg)
+            }
+        }
+
+        // ✅ PHASE 2: Sync camera settings bidirectionally
+        Connections {
+            target: root
+            function onCameraFovChanged() { if (cameraController.state.fov !== root.cameraFov) cameraController.state.fov = root.cameraFov }
+            function onCameraNearChanged() { if (cameraController.state.nearPlane !== root.cameraNear) cameraController.state.nearPlane = root.cameraNear }
+            function onCameraFarChanged() { if (cameraController.state.farPlane !== root.cameraFar) cameraController.state.farPlane = root.cameraFar }
+            function onCameraSpeedChanged() { if (cameraController.state.speed !== root.cameraSpeed) cameraController.state.speed = root.cameraSpeed }
+            function onAutoRotateChanged() { if (cameraController.state.autoRotate !== root.autoRotate) cameraController.state.autoRotate = root.autoRotate }
+            function onAutoRotateSpeedChanged() { if (cameraController.state.autoRotateSpeed !== root.autoRotateSpeed) cameraController.state.autoRotateSpeed = root.autoRotateSpeed }
+        }
+
+        Connections {
+            target: cameraController.state
+            function onFovChanged() { if (root.cameraFov !== cameraController.state.fov) root.cameraFov = cameraController.state.fov }
+            function onNearPlaneChanged() { if (root.cameraNear !== cameraController.state.nearPlane) root.cameraNear = cameraController.state.nearPlane }
+            function onFarPlaneChanged() { if (root.cameraFar !== cameraController.state.farPlane) root.cameraFar = cameraController.state.farPlane }
+            function onSpeedChanged() { if (root.cameraSpeed !== cameraController.state.speed) root.cameraSpeed = cameraController.state.speed }
+            function onAutoRotateChanged() { if (root.autoRotate !== cameraController.state.autoRotate) root.autoRotate = cameraController.state.autoRotate }
+            function onAutoRotateSpeedChanged() { if (root.autoRotateSpeed !== cameraController.state.autoRotateSpeed) root.autoRotateSpeed = cameraController.state.autoRotateSpeed }
+        }
+
+            // ===============================================================
+    // ✅ STEP 1: MODULAR LIGHTING SYSTEM
+    // ===============================================================
+
+    // ✅ DirectionalLights module (Key, Fill, Rim lights)
+    DirectionalLights {
+        id: directionalLights
+        worldRoot: worldRoot
+        cameraRig: cameraController.rig
+
+        shadowsEnabled: root.shadowsEnabled
+        shadowResolution: root.shadowResolution
+        shadowFilterSamples: root.shadowFilterSamples
+        shadowBias: root.shadowBias
+        shadowFactor: root.shadowFactor
+
+        keyLightBrightness: root.keyLightBrightness
+        keyLightColor: root.keyLightColor
+        keyLightAngleX: root.keyLightAngleX
+        keyLightAngleY: root.keyLightAngleY
+        keyLightCastsShadow: root.keyLightCastsShadow
+        keyLightBindToCamera: root.keyLightBindToCamera
+        keyLightPosX: root.keyLightPosX
+        keyLightPosY: root.keyLightPosY
+
+        fillLightBrightness: root.fillLightBrightness
+        fillLightColor: root.fillLightColor
+        fillLightCastsShadow: root.fillLightCastsShadow
+        fillLightBindToCamera: root.fillLightBindToCamera
+        fillLightPosX: root.fillLightPosX
+        fillLightPosY: root.fillLightPosY
+
+        rimLightBrightness: root.rimLightBrightness
+        rimLightColor: root.rimLightColor
+        rimLightCastsShadow: root.rimLightCastsShadow
+        rimLightBindToCamera: root.rimLightBindToCamera
+        rimLightPosX: root.rimLightPosX
+        rimLightPosY: root.rimLightPosY
+    }
+
+    // ✅ PointLights module (Accent light)
+    PointLights {
+        id: pointLights
+        worldRoot: worldRoot
+        cameraRig: cameraController.rig
+
+        pointLightBrightness: root.pointLightBrightness
+        pointLightColor: root.pointLightColor
+        pointLightX: root.pointLightX
+        pointLightY: root.pointLightY
+        pointLightRange: root.pointLightRange
+        pointLightCastsShadow: root.pointLightCastsShadow
+        pointLightBindToCamera: root.pointLightBindToCamera
+    }
+
+        // ===============================================================
+        // SUSPENSION SYSTEM GEOMETRY (with IOR support)
+        // ===============================================================
+
+        // U-FRAME (3 beams) with controlled materials
+        Model {
+            parent: worldRoot
+            source: "#Cube"
+            position: Qt.vector3d(0, userBeamSize/2, userFrameLength/2)
+            scale: Qt.vector3d(userBeamSize/100, userBeamSize/100, userFrameLength/100)
+            materials: [materials.frameMaterial]
+        }
+        Model {
+            parent: worldRoot
+            source: "#Cube"
+            position: Qt.vector3d(0, userBeamSize + userFrameHeight/2, userBeamSize/2)
+            scale: Qt.vector3d(userBeamSize/100, userFrameHeight/100, userBeamSize/100)
+            materials: [materials.frameMaterial]
+        }
+        Model {
+            parent: worldRoot
+            source: "#Cube"
+            position: Qt.vector3d(0, userBeamSize + userFrameHeight/2, userFrameLength - userBeamSize/2)
+            scale: Qt.vector3d(userBeamSize/100, userFrameHeight/100, userBeamSize/100)
+            materials: [materials.frameMaterial]
+        }
+
+        // ===============================================================
+        // ✅ SUSPENSION SYSTEM - МОДУЛЬНЫЕ КОМПОНЕНТЫ
+        // ===============================================================
+
+        // ✅ Frame component - централизованный U-образный корпус
+        Frame {
+            id: mainFrame
+            worldRoot: worldRoot
+            beamSize: root.userBeamSize
+            frameHeight: root.userFrameHeight
+            frameLength: root.userFrameLength
+            frameMaterial: materials.frameMaterial
+        }
+
+        // ✅ Four suspension corners with modular components
+        SuspensionCorner {
+            id: flCorner
+            parent: worldRoot
+            j_arm: Qt.vector3d(-userFrameToPivot, userBeamSize, userBeamSize/2)
+            j_tail: Qt.vector3d(-userTrackWidth/2, userBeamSize + userFrameHeight, userBeamSize/2)
+            leverAngle: fl_angle
+            pistonPositionFromPython: root.userPistonPositionFL
+
+            // Materials
+            leverMaterial: materials.leverMaterial
+            tailRodMaterial: materials.tailRodMaterial
+            cylinderMaterial: materials.cylinderMaterial
+            pistonBodyMaterial: materials.createPistonBodyMaterial(false)  // рассчитает динамически
+            pistonRodMaterial: materials.createPistonRodMaterial(false)
+            jointTailMaterial: materials.jointTailMaterial
+            jointArmMaterial: materials.jointArmMaterial
+            jointRodMaterial: materials.createJointRodMaterial(false)  // рассчитает ошибку
+
+            // Geometry params
+            leverLength: root.userLeverLength
+            rodPosition: root.userRodPosition
+            cylinderLength: root.userCylinderLength
+            boreHead: root.userBoreHead
+            rodDiameter: root.userRodDiameter
+            pistonThickness: root.userPistonThickness
+            pistonRodLength: root.userPistonRodLength
+            cylinderSegments: root.cylinderSegments
+            cylinderRings: root.cylinderRings
+        }
+
+        SuspensionCorner {
+            id: frCorner
+            parent: worldRoot
+            j_arm: Qt.vector3d(userFrameToPivot, userBeamSize, userBeamSize/2)
+            j_tail: Qt.vector3d(userTrackWidth/2, userBeamSize + userFrameHeight, userBeamSize/2)
+            leverAngle: fr_angle
+            pistonPositionFromPython: root.userPistonPositionFR
+
+            leverMaterial: materials.leverMaterial
+            tailRodMaterial: materials.tailRodMaterial
+            cylinderMaterial: materials.cylinderMaterial
+            pistonBodyMaterial: materials.createPistonBodyMaterial(false)
+            pistonRodMaterial: materials.createPistonRodMaterial(false)
+            jointTailMaterial: materials.jointTailMaterial
+            jointArmMaterial: materials.jointArmMaterial
+            jointRodMaterial: materials.createJointRodMaterial(false)
+
+            leverLength: root.userLeverLength
+            rodPosition: root.userRodPosition
+            cylinderLength: root.userCylinderLength
+            boreHead: root.userBoreHead
+            rodDiameter: root.userRodDiameter
+            pistonThickness: root.userPistonThickness
+            pistonRodLength: root.userPistonRodLength
+            cylinderSegments: root.cylinderSegments
+            cylinderRings: root.cylinderRings
+        }
+
+        SuspensionCorner {
+            id: rlCorner
+            parent: worldRoot
+            j_arm: Qt.vector3d(-userFrameToPivot, userBeamSize, userFrameLength - userBeamSize/2)
+            j_tail: Qt.vector3d(-userTrackWidth/2, userBeamSize + userFrameHeight, userFrameLength - userBeamSize/2)
+            leverAngle: rl_angle
+            pistonPositionFromPython: root.userPistonPositionRL
+
+            leverMaterial: materials.leverMaterial
+            tailRodMaterial: materials.tailRodMaterial
+            cylinderMaterial: materials.cylinderMaterial
+            pistonBodyMaterial: materials.createPistonBodyMaterial(false)
+            pistonRodMaterial: materials.createPistonRodMaterial(false)
+            jointTailMaterial: materials.jointTailMaterial
+            jointArmMaterial: materials.jointArmMaterial
+            jointRodMaterial: materials.createJointRodMaterial(false)
+
+            leverLength: root.userLeverLength
+            rodPosition: root.userRodPosition
+            cylinderLength: root.userCylinderLength
+            boreHead: root.userBoreHead
+            rodDiameter: root.userRodDiameter
+            pistonThickness: root.userPistonThickness
+            pistonRodLength: root.userPistonRodLength
+            cylinderSegments: root.cylinderSegments
+            cylinderRings: root.cylinderRings
+        }
+
+        SuspensionCorner {
+            id: rrCorner
+            parent: worldRoot
+            j_arm: Qt.vector3d(userFrameToPivot, userBeamSize, userFrameLength - userBeamSize/2)
+            j_tail: Qt.vector3d(userTrackWidth/2, userBeamSize + userFrameHeight, userFrameLength - userBeamSize/2)
+            leverAngle: rr_angle
+            pistonPositionFromPython: root.userPistonPositionRR
+
+            leverMaterial: materials.leverMaterial
+            tailRodMaterial: materials.tailRodMaterial
+            cylinderMaterial: materials.cylinderMaterial
+            pistonBodyMaterial: materials.createPistonBodyMaterial(false)
+            pistonRodMaterial: materials.createPistonRodMaterial(false)
+            jointTailMaterial: materials.jointTailMaterial
+            jointArmMaterial: materials.jointArmMaterial
+            jointRodMaterial: materials.createJointRodMaterial(false)
+
+            leverLength: root.userLeverLength
+            rodPosition: root.userRodPosition
+            cylinderLength: root.userCylinderLength
+            boreHead: root.userBoreHead
+            rodDiameter: root.userRodDiameter
+            pistonThickness: root.userPistonThickness
+            pistonRodLength: root.userPistonRodLength
+            cylinderSegments: root.cylinderSegments
+            cylinderRings: root.cylinderRings
+        }
+    }
+
+    // ===============================================================
+    // ✅ PHASE 2: MOUSE CONTROLS (integrated in CameraController)
+    // ===============================================================
+
+    // ✅ MouseControls are now part of CameraController - no separate component needed
+
+    // ===============================================================
+    // ANIMATION TIMERS
+    // ===============================================================
+
+    Timer {
+        running: isRunning
+        interval: 16  // 60 FPS
+        repeat: true
+        onTriggered: {
+            animationTime += 0.016
+        }
+    }
+
+    // ✅ PHASE 2: Auto-rotate timer - integrated in CameraController
+    // Auto-rotation is now handled internally by CameraController
+
+    // ===============================================================
+    // KEYBOARD SHORTCUTS (preserved)
+    // ===============================================================
+
+    Keys.onPressed: (e) => {
+        if (e.key === Qt.Key_R) {
+            resetView()
+        } else if (e.key === Qt.Key_Space) {
+            isRunning = !isRunning
+        } else if (e.key === Qt.Key_F) {
+            autoFitFrame()
+        }
+    }
+
+    focus: true
+
+    // ===============================================================
+    // ✅ UPDATED INFO PANEL (with rod length information)
+    // ===============================================================
+
+    Rectangle {
+        anchors.top: parent.top
+        anchors.left: parent.left
+        anchors.margins: 15
+        width: 550
+        height: 240
+        color: "#aa000000"
+        border.color: "#60ffffff"
+        radius: 8
+
+        Column {
+            anchors.centerIn: parent
+            spacing: 6
+
+            Text {
+                text: "PneumoStabSim Professional | ИСПРАВЛЕННАЯ КИНЕМАТИКА v4.1"
+                color: "#ffffff"
+                font.pixelSize: 14
+                font.bold: true
+            }
+
+            Text {
+                text: "🔧 Qt " + Qt.version + " | Dithering: " + (canUseDithering ? "✅ Supported" : "❌ Not available")
+                color: canUseDithering ? "#00ff88" : "#ffaa00"
+                font.pixelSize: 10
+            }
+
+            Text {
+                text: "🔧 ИСПРАВЛЕНО: Правильный расчет длины штоков"
+                color: "#00ff88"
+                font.pixelSize: 11
+            }
+
+            Text {
+                text: "✅ Длина штока: " + userPistonRodLength + "мм (КОНСТАНТА)"
+                color: "#ffaa00"
+                font.pixelSize: 10
+            }
+
+            Text {
+                text: "🔍 Ошибки длины: FL=" + (flCorner.rodLengthError ? flCorner.rodLengthError.toFixed(2) : "0.00") +
+                      "мм | FR=" + (frCorner.rodLengthError ? frCorner.rodLengthError.toFixed(2) : "0.00") +
+                      "мм | RL=" + (rlCorner.rodLengthError ? rlCorner.rodLengthError.toFixed(2) : "0.00") +
+                      "мм | RR=" + (rrCorner.rodLengthError ? rrCorner.rodLengthError.toFixed(2) : "0.00") + "мм"
+                color: "#aaddff"
+                font.pixelSize: 9
+            }
+
+            Text {
+                text: "📷 Камера: " + cameraController.distance.toFixed(0) + "мм | Pivot: (" +
+                      cameraController.pivot.x.toFixed(0) + ", " + cameraController.pivot.y.toFixed(0) + ", " + cameraController.pivot.z.toFixed(0) + ")"
+                color: "#cccccc"
+                font.pixelSize: 10
+            }
+
+            Text {
+                text: "🎮 ЛКМ-вращение | ПКМ-панорама | Колесо-зум | R-сброс | F-автофит | Space-анимация"
+                color: "#aaddff"
+                font.pixelSize: 9
+            }
+        }
+    }
+
+    // ===============================================================
+    // INITIALIZATION (with rod length validation)
+    // ===============================================================
+
+    Component.onCompleted: {
+        // Лог старта для диагностики рассинхрона
+        console.log("[START] IBL primary:", iblPrimarySource,
+                    "fallback:", iblFallbackSource,
+                    "mode:", backgroundMode,
+                    "iblEnabled:", iblEnabled,
+                    "skybox:", iblBackgroundEnabled)
+
+        console.log("═══════════════════════════════════════════")
+        console.log("🚀 PneumoStabSim PHASE 2 CAMERA SYSTEM v1.0")
+        console.log("═══════════════════════════════════════════")
+        console.log("🔧 Qt Version:", Qt.version)
+        console.log("   Qt Major:", qtMajor, "| Qt Minor:", qtMinor)
+        console.log("   Dithering support:", canUseDithering ? "✅ YES (Qt 6.10+)" : "❌ NO (Qt < 6.10)")
+        console.log("   Specular AA:", canUseSpecularAA ? "ENABLED" : "DISABLED (temporary workaround)")
+        console.log("✅ PHASE 2: CAMERA SYSTEM MODULAR")
+        console.log("   🎥 CameraController: Integrated")
+        console.log("   🎯 CameraState: 21 properties → 1 module")
+        console.log("   🖱️ MouseControls: Separated")
+        console.log("   🌍 CameraRig: Optimized")
+        console.log("✅ CRITICAL FIX v4.9.4:")
+        console.log("   🔧 Skybox rotation: INDEPENDENT from camera")
+        console.log("   🔧 probeOrientation uses ONLY iblRotationDeg")
+        console.log("   🔧 Camera yaw does NOT affect skybox orientation")
+        console.log("   🔧 Skybox and camera are COMPLEТELY DECOUPLED")
+        console.log("✅ ВСЕ ПАРАМЕТРЫ GRAPHICSPANEL:")
+        console.log("   🔥 Коэффициент преломления (IOR):", cylinderIor)
+        console.log("   🔥 IBL освещение:", iblLightingEnabled, "| IBL фон:", iblBackgroundEnabled, "| Поворот:", iblRotationDeg.toFixed(1) + "°")
+        console.log("   🔥 Туман поддержка:", fogEnabled)
+        console.log("   🔥 Расширенные эффекты: Bloom, SSAO, DoF, Vignette, Lens Flare")
+        console.log("   🔥 Dithering:", canUseDithering ? "Enabled" : "Not available")
+        console.log("   🔥 Procedural geometry: segments=" + cylinderSegments + ", rings=" + cylinderRings)
+        console.log("🎯 СТАТУС: PHASE 2 CAMERA INTEGRATION COMPLETE")
+        console.log("═══════════════════════════════════════════")
+
+        syncRenderSettings()
+        cameraController.resetView()  // ✅ PHASE 2: delegate to CameraController
+        view3d.forceActiveFocus()
+    }
+
+    // IBL readiness console log for Python-side logger
+    onIblReadyChanged: {
+        console.log("[IBL] READY:", JSON.stringify({ ready: iblReady }))
+    }
+
+    // Model of HDR/EXR files from assets/hdr
+    FolderListModel {
+        id: hdriModel
+        folder: Qt.resolvedUrl("../hdr")
+        nameFilters: ["*.hdr", "*.exr"]
+        showDirs: false
+        showDotAndDotDot: false
+    }
+
 }
diff --git a/assets/qml/main.qml.rej b/assets/qml/main.qml.rej
deleted file mode 100644
index 8c056da0f3bffe0adbad5b556eadbecc79bd5af9..0000000000000000000000000000000000000000
--- a/assets/qml/main.qml.rej
+++ /dev/null
@@ -1,1388 +0,0 @@
-diff a/assets/qml/main.qml b/assets/qml/main.qml	(rejected hunks)
-@@ -1,28 +1,30 @@
- import QtQuick
- import QtQuick3D
- import QtQuick3D.Helpers
-+import QtQuick3D.RenderSettings
-+import "components"
-
- /*
-  * PneumoStabSim - COMPLETE Graphics Parameters Main 3D View (v4.0)
-  * 🚀 ПОЛНАЯ ИНТЕРАЦИЯ: Все параметры GraphicsPanel реализованы
-  * ✅ Коэффициент преломления, IBL, расширенные эффекты, тонемаппинг
-  */
- Item {
-     id: root
-     anchors.fill: parent
-
-     // ===============================================================
-     // 🚀 PERFORMANCE OPTIMIZATION LAYER (preserved)
-     // ===============================================================
-
-     // ✅ ОПТИМИЗАЦИЯ #1: Кэширование анимационных вычислений
-     QtObject {
-         id: animationCache
-
-         // Базовые значения (вычисляются 1 раз за фрейм вместо 4х)
-         property real basePhase: animationTime * userFrequency * 2 * Math.PI
-         property real globalPhaseRad: userPhaseGlobal * Math.PI / 180
-
-         // Предварительно вычисленные фазы для каждого угла
-         property real flPhaseRad: globalPhaseRad + userPhaseFL * Math.PI / 180
-         property real frPhaseRad: globalPhaseRad + userPhaseFR * Math.PI / 180
-@@ -52,145 +54,294 @@ Item {
-         // Обновление кэша камеры при необходимости
-         onCachedFovRadChanged: cachedTanHalfFov = Math.tan(cachedFovRad / 2)
-
-         function calculateJRod(j_arm, baseAngle, leverAngle) {
-             var totalAngleRad = (baseAngle + leverAngle) * piOver180
-             return Qt.vector3d(
-                 j_arm.x + leverLengthRodPos * Math.cos(totalAngleRad),
-                 j_arm.y + leverLengthRodPos * Math.sin(totalAngleRad),
-                 j_arm.z
-             )
-         }
-
-         function normalizeCylDirection(j_rod, j_tail) {
-             var dx = j_rod.x - j_tail.x
-             var dy = j_rod.y - j_tail.y
-             var length = Math.hypot(dx, dy)
-             return {
-                 direction: Qt.vector3d(dx, dy, 0),
-                 length: length,
-                 normalized: Qt.vector3d(dx/length, dy/length, 0),
-                 angle: Math.atan2(dy, dx) * _180OverPi + 90
-             }
-         }
-     }
-
-+    // ===============================================================
-+    // IBL CONTROLLER
-+    // ===============================================================
-+
-+    IblProbeLoader {
-+        id: iblLoader
-+        primarySource: root.iblPrimarySource
-+        fallbackSource: root.iblFallbackSource
-+    }
-+
-     // ===============================================================
-     // CAMERA SYSTEM (preserved)
-     // ===============================================================
-
-     property vector3d pivot: Qt.vector3d(0, userBeamSize/2, userFrameLength/2)
-
-     // Camera orbital parameters
-     property real cameraDistance: 3500
-     property real minDistance: 150
-     property real maxDistance: 30000
-     property real yawDeg: 225
-     property real pitchDeg: -25
-
-     property real panX: 0
-     property real panY: 0
-
-     // Camera properties
--    property real cameraFov: 50.0
--    property real cameraNear: 2.0
-+    property real cameraFov: 60.0
-+    property real cameraNear: 10.0
-     property real cameraFar: 50000.0
-     property real cameraSpeed: 1.0
-
-     // Auto rotation
-     property bool autoRotate: false
-     property real autoRotateSpeed: 0.5
-
-     // Mouse input state
-     property bool mouseDown: false
-     property int mouseButton: 0
-     property real lastX: 0
-     property real lastY: 0
-     property real rotateSpeed: 0.35
-
-     // ===============================================================
-     // ✅ COMPLETE GRAPHICS PROPERTIES (All parameters from GraphicsPanel)
-     // ===============================================================
--
--    // Environment and IBL
--    property string backgroundColor: "#2a2a2a"
--    property bool skyboxEnabled: true
--    property bool iblEnabled: true         // ✅ НОВОЕ: IBL включение
--    property real iblIntensity: 1.0        // ✅ НОВОЕ: IBL интенсивность
--
--    // Fog
--    property bool fogEnabled: false
--    property string fogColor: "#808080"
--    property real fogDensity: 0.1
--
--    // Quality settings
--    property int antialiasingMode: 2
--    property int antialiasingQuality: 2
-+
-+    // HDR resources
-+    property url iblPrimarySource: Qt.resolvedUrl("../hdr/studio.hdr")
-+    property url iblFallbackSource: Qt.resolvedUrl("assets/studio_small_09_2k.hdr")
-+    readonly property bool iblReady: iblLoader.ready
-+
-+    // Lighting
-+    property real keyLightBrightness: 1.2
-+    property color keyLightColor: "#ffffff"
-+    property real keyLightAngleX: -35
-+    property real keyLightAngleY: -40
-+    property real fillLightBrightness: 0.7
-+    property color fillLightColor: "#dfe7ff"
-+    property real rimLightBrightness: 1.0
-+    property color rimLightColor: "#ffe2b0"
-+    property real pointLightBrightness: 1500.0
-+    property color pointLightColor: "#ffffff"
-+    property real pointLightY: 2200.0
-+    property real pointLightRange: 3200.0
-+
-+    // Environment
-+    property string backgroundMode: "skybox"
-+    property color backgroundColor: "#1f242c"
-+    property real skyboxBlur: 0.08
-+    property bool iblEnabled: true
-+    property real iblIntensity: 1.3
-+    property bool fogEnabled: true
-+    property color fogColor: "#b0c4d8"
-+    property real fogDensity: 0.12
-+    property real fogNear: 1200.0
-+    property real fogFar: 12000.0
-+    property bool aoEnabled: true
-+    property real aoStrength: 1.0
-+    property real aoRadius: 8.0
-+
-+    // Quality and rendering
-+    property string aaPrimaryMode: "ssaa"
-+    property string aaQualityLevel: "high"
-+    property string aaPostMode: "taa"
-+    property bool taaEnabled: true
-+    property real taaStrength: 0.4
-+    property bool fxaaEnabled: false
-+    property bool specularAAEnabled: true
-+    property bool ditheringEnabled: true
-+    property real renderScale: 1.05
-+    property string renderPolicy: "always"
-+    property real frameRateLimit: 144.0
-+    property string qualityPreset: "ultra"
-     property bool shadowsEnabled: true
--    property int shadowQuality: 2
--    property real shadowSoftness: 0.5      // ✅ НОВОЕ: Мягкость теней
--
--    // Post-processing effects - EXPANDED
-+    property string shadowResolution: "4096"
-+    property int shadowFilterSamples: 32
-+    property real shadowBias: 8.0
-+    property real shadowFactor: 80.0
-+    property string oitMode: "weighted"
-+
-+    // Post-processing effects
-     property bool bloomEnabled: true
--    property real bloomThreshold: 1.0       // ✅ НОВОЕ: Порог Bloom
--    property real bloomIntensity: 0.8
--    property bool ssaoEnabled: true
--    property real ssaoRadius: 8.0           // ✅ НОВОЕ: Радиус SSAO
--    property real ssaoIntensity: 0.6
--
--    // Tonemap settings
--    property bool tonemapEnabled: true      // ✅ НОВОЕ: Тонемаппинг
--    property int tonemapMode: 3             // ✅ НОВОЕ: Режим тонемаппинга
--
--    // Advanced effects
-+    property real bloomIntensity: 0.5
-+    property real bloomThreshold: 1.0
-+    property real bloomSpread: 0.65
-     property bool depthOfFieldEnabled: false
--    property real dofFocusDistance: 2000    // ✅ НОВОЕ: Дистанция фокуса
--    property real dofFocusRange: 900        // ✅ НОВОЕ: Диапазон фокуса
-+    property real dofFocusDistance: 2200.0
-+    property real dofBlurAmount: 4.0
-+    property bool motionBlurEnabled: false
-+    property real motionBlurAmount: 0.2
-     property bool lensFlareEnabled: true
--    property bool vignetteEnabled: true     // ✅ НОВОЕ: Виньетирование
--    property real vignetteStrength: 0.45    // ✅ НОВОЕ: Сила виньетирования
--    property bool motionBlurEnabled: false  // ✅ ИСПРАВЛЕНО: Переименовано
--
--    // Lighting control properties
--    property real keyLightBrightness: 2.8
--    property string keyLightColor: "#ffffff"
--    property real keyLightAngleX: -30
--    property real keyLightAngleY: -45
--    property real fillLightBrightness: 1.2
--    property string fillLightColor: "#f0f0ff"
--    property real pointLightBrightness: 20000
--    property real pointLightY: 1800
--
--    // Material control properties - EXPANDED
--    property real metalRoughness: 0.28
--    property real metalMetalness: 1.0
--    property real metalClearcoat: 0.25
--    property real glassOpacity: 0.35
--    property real glassRoughness: 0.05
--    property real glassIOR: 1.52            // ✅ НОВОЕ: Коэффициент преломления!
--    property real frameMetalness: 0.8
--    property real frameRoughness: 0.4
-+    property bool vignetteEnabled: true
-+    property real vignetteStrength: 0.35
-+
-+    // Tonemap settings
-+    property bool tonemapEnabled: true
-+    property string tonemapModeName: "filmic"
-+
-+    // Material control properties
-+    property color frameBaseColor: "#c53030"
-+    property real frameMetalness: 0.85
-+    property real frameRoughness: 0.35
-+    property real frameSpecularAmount: 1.0
-+    property real frameSpecularTint: 0.0
-+    property real frameClearcoat: 0.22
-+    property real frameClearcoatRoughness: 0.1
-+    property real frameTransmission: 0.0
-+    property real frameOpacity: 1.0
-+    property real frameIor: 1.5
-+    property real frameAttenuationDistance: 10000.0
-+    property color frameAttenuationColor: "#ffffff"
-+    property color frameEmissiveColor: "#000000"
-+    property real frameEmissiveIntensity: 0.0
-+
-+    property color leverBaseColor: "#9ea4ab"
-+    property real leverMetalness: 1.0
-+    property real leverRoughness: 0.28
-+    property real leverSpecularAmount: 1.0
-+    property real leverSpecularTint: 0.0
-+    property real leverClearcoat: 0.3
-+    property real leverClearcoatRoughness: 0.08
-+    property real leverTransmission: 0.0
-+    property real leverOpacity: 1.0
-+    property real leverIor: 1.5
-+    property real leverAttenuationDistance: 10000.0
-+    property color leverAttenuationColor: "#ffffff"
-+    property color leverEmissiveColor: "#000000"
-+    property real leverEmissiveIntensity: 0.0
-+
-+    property color tailRodBaseColor: "#d5d9df"
-+    property real tailRodMetalness: 1.0
-+    property real tailRodRoughness: 0.3
-+    property real tailRodSpecularAmount: 1.0
-+    property real tailRodSpecularTint: 0.0
-+    property real tailRodClearcoat: 0.0
-+    property real tailRodClearcoatRoughness: 0.0
-+    property real tailRodTransmission: 0.0
-+    property real tailRodOpacity: 1.0
-+    property real tailRodIor: 1.5
-+    property real tailRodAttenuationDistance: 10000.0
-+    property color tailRodAttenuationColor: "#ffffff"
-+    property color tailRodEmissiveColor: "#000000"
-+    property real tailRodEmissiveIntensity: 0.0
-+
-+    property color cylinderBaseColor: "#e1f5ff"
-+    property real cylinderMetalness: 0.0
-+    property real cylinderRoughness: 0.05
-+    property real cylinderSpecularAmount: 1.0
-+    property real cylinderSpecularTint: 0.0
-+    property real cylinderClearcoat: 0.0
-+    property real cylinderClearcoatRoughness: 0.0
-+    property real cylinderTransmission: 1.0
-+    property real cylinderOpacity: 1.0
-+    property real cylinderIor: 1.52
-+    property real cylinderAttenuationDistance: 1800.0
-+    property color cylinderAttenuationColor: "#b7e7ff"
-+    property color cylinderEmissiveColor: "#000000"
-+    property real cylinderEmissiveIntensity: 0.0
-+
-+    property color pistonBodyBaseColor: "#ff3c6e"
-+    property color pistonBodyWarningColor: "#ff5454"
-+    property real pistonBodyMetalness: 1.0
-+    property real pistonBodyRoughness: 0.26
-+    property real pistonBodySpecularAmount: 1.0
-+    property real pistonBodySpecularTint: 0.0
-+    property real pistonBodyClearcoat: 0.18
-+    property real pistonBodyClearcoatRoughness: 0.06
-+    property real pistonBodyTransmission: 0.0
-+    property real pistonBodyOpacity: 1.0
-+    property real pistonBodyIor: 1.5
-+    property real pistonBodyAttenuationDistance: 10000.0
-+    property color pistonBodyAttenuationColor: "#ffffff"
-+    property color pistonBodyEmissiveColor: "#000000"
-+    property real pistonBodyEmissiveIntensity: 0.0
-+
-+    property color pistonRodBaseColor: "#ececec"
-+    property color pistonRodWarningColor: "#ff2a2a"
-+    property real pistonRodMetalness: 1.0
-+    property real pistonRodRoughness: 0.18
-+    property real pistonRodSpecularAmount: 1.0
-+    property real pistonRodSpecularTint: 0.0
-+    property real pistonRodClearcoat: 0.12
-+    property real pistonRodClearcoatRoughness: 0.05
-+    property real pistonRodTransmission: 0.0
-+    property real pistonRodOpacity: 1.0
-+    property real pistonRodIor: 1.5
-+    property real pistonRodAttenuationDistance: 10000.0
-+    property color pistonRodAttenuationColor: "#ffffff"
-+    property color pistonRodEmissiveColor: "#000000"
-+    property real pistonRodEmissiveIntensity: 0.0
-+
-+    property color jointTailBaseColor: "#2a82ff"
-+    property real jointTailMetalness: 0.9
-+    property real jointTailRoughness: 0.35
-+    property real jointTailSpecularAmount: 1.0
-+    property real jointTailSpecularTint: 0.0
-+    property real jointTailClearcoat: 0.1
-+    property real jointTailClearcoatRoughness: 0.08
-+    property real jointTailTransmission: 0.0
-+    property real jointTailOpacity: 1.0
-+    property real jointTailIor: 1.5
-+    property real jointTailAttenuationDistance: 10000.0
-+    property color jointTailAttenuationColor: "#ffffff"
-+    property color jointTailEmissiveColor: "#000000"
-+    property real jointTailEmissiveIntensity: 0.0
-+
-+    property color jointArmBaseColor: "#ff9c3a"
-+    property real jointArmMetalness: 0.9
-+    property real jointArmRoughness: 0.32
-+    property real jointArmSpecularAmount: 1.0
-+    property real jointArmSpecularTint: 0.0
-+    property real jointArmClearcoat: 0.12
-+    property real jointArmClearcoatRoughness: 0.08
-+    property real jointArmTransmission: 0.0
-+    property real jointArmOpacity: 1.0
-+    property real jointArmIor: 1.5
-+    property real jointArmAttenuationDistance: 10000.0
-+    property color jointArmAttenuationColor: "#ffffff"
-+    property color jointArmEmissiveColor: "#000000"
-+    property real jointArmEmissiveIntensity: 0.0
-+
-+    property color jointRodOkColor: "#00ff55"
-+    property color jointRodErrorColor: "#ff0000"
-
-     // ===============================================================
-     // ANIMATION AND GEOMETRY PROPERTIES (preserved)
-     // ===============================================================
-
-     property real animationTime: 0.0
-     property bool isRunning: false
-
-     // User-controlled animation parameters
-     property real userAmplitude: 8.0
-     property real userFrequency: 1.0
-     property real userPhaseGlobal: 0.0
-     property real userPhaseFL: 0.0
-     property real userPhaseFR: 0.0
-     property real userPhaseRL: 0.0
-     property real userPhaseRR: 0.0
-
-     // Piston positions from Python
-     property real userPistonPositionFL: 250.0
-     property real userPistonPositionFR: 250.0
-     property real userPistonPositionRL: 250.0
-     property real userPistonPositionRR: 250.0
-
-     // ✅ ОПТИМИЗИРОВАННЫЕ углы (используют кэшированные значения)
-     property real fl_angle: isRunning ? userAmplitude * animationCache.flSin : 0.0
-@@ -213,50 +364,63 @@ Item {
-     property real userPistonThickness: 25
-     property real userPistonRodLength: 200
-
-     // ===============================================================
-     // SMOOTH CAMERA BEHAVIORS (preserved)
-     // ===============================================================
-
-     Behavior on yawDeg         { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
-     Behavior on pitchDeg       { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
-     Behavior on cameraDistance { NumberAnimation { duration: 90; easing.type: Easing.OutCubic } }
-     Behavior on panX           { NumberAnimation { duration: 60; easing.type: Easing.OutQuad } }
-     Behavior on panY           { NumberAnimation { duration: 60; easing.type: Easing.OutQuad } }
-
-     // ===============================================================
-     // UTILITY FUNCTIONS (preserved)
-     // ===============================================================
-
-     function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
-
-     function normAngleDeg(a) {
-         var x = a % 360;
-         if (x > 180) x -= 360;
-         if (x < -180) x += 360;
-         return x;
-     }
-+
-+    function resolveUrl(path) {
-+        if (!path || path === "")
-+            return "";
-+        if (path.startsWith("file:") || path.startsWith("http:") || path.startsWith("https:") ||
-+            path.startsWith("qrc:") || path.startsWith("data:"))
-+            return path;
-+        if (path.length >= 2 && path.charAt(1) === ":")
-+            return "file:///" + path.replace(/\\/g, "/");
-+        if (path.startsWith("/"))
-+            return "file://" + path;
-+        return Qt.resolvedUrl(path);
-+    }
-
-     function autoFitFrame(marginFactor) {
-         const L = Math.max(1, userFrameLength)
-         const T = Math.max(1, userTrackWidth)
-         const H = Math.max(1, userFrameHeight)
-         const margin = marginFactor !== undefined ? marginFactor : 1.15
-         const R = 0.5 * Math.sqrt(L*L + T*T + H*H)
-         const fov = cameraFov * Math.PI / 180.0
-         const dist = (R * margin) / Math.tan(fov * 0.5)
-         cameraDistance = Math.max(minDistance, Math.min(maxDistance, dist))
-     }
-
-     // ✅ УЛУЧШЕННАЯ функция resetView с сохранением позиции камеры
-     function resetView() {
-         // Сохраняем текущую позицию камеры если она разумная
-         var preserveCamera = (Math.abs(yawDeg) < 720 &&
-                              Math.abs(pitchDeg) < 90 &&
-                              cameraDistance > minDistance &&
-                              cameraDistance < maxDistance)
-
-         if (preserveCamera) {
-             console.log("🔄 Soft reset: preserving camera position")
-             // Обновляем только pivot, камера остается
-             pivot = Qt.vector3d(0, userBeamSize/2, userFrameLength/2)
-         } else {
-@@ -371,390 +535,549 @@ Item {
-
-     function applyAnimationUpdates(params) {
-         console.log("🎬 main.qml: applyAnimationUpdates() called")
-         if (params.amplitude !== undefined) userAmplitude = params.amplitude
-         if (params.frequency !== undefined) userFrequency = params.frequency
-         if (params.phase !== undefined) userPhaseGlobal = params.phase
-         if (params.lf_phase !== undefined) userPhaseFL = params.lf_phase
-         if (params.rf_phase !== undefined) userPhaseFR = params.rf_phase
-         if (params.lr_phase !== undefined) userPhaseRL = params.lr_phase
-         if (params.rr_phase !== undefined) userPhaseRR = params.rr_phase
-         console.log("  ✅ Animation updated successfully")
-     }
-
-     function applyLightingUpdates(params) {
-         console.log("💡 main.qml: applyLightingUpdates() called")
-         if (params.key_light) {
-             if (params.key_light.brightness !== undefined) keyLightBrightness = params.key_light.brightness
-             if (params.key_light.color !== undefined) keyLightColor = params.key_light.color
-             if (params.key_light.angle_x !== undefined) keyLightAngleX = params.key_light.angle_x
-             if (params.key_light.angle_y !== undefined) keyLightAngleY = params.key_light.angle_y
-         }
-         if (params.fill_light) {
-             if (params.fill_light.brightness !== undefined) fillLightBrightness = params.fill_light.brightness
-             if (params.fill_light.color !== undefined) fillLightColor = params.fill_light.color
-         }
-+        if (params.rim_light) {
-+            if (params.rim_light.brightness !== undefined) rimLightBrightness = params.rim_light.brightness
-+            if (params.rim_light.color !== undefined) rimLightColor = params.rim_light.color
-+        }
-         if (params.point_light) {
-             if (params.point_light.brightness !== undefined) pointLightBrightness = params.point_light.brightness
-+            if (params.point_light.color !== undefined) pointLightColor = params.point_light.color
-             if (params.point_light.position_y !== undefined) pointLightY = params.point_light.position_y
-+            if (params.point_light.range !== undefined) pointLightRange = Math.max(1, params.point_light.range)
-         }
-         console.log("  ✅ Lighting updated successfully")
-     }
-
--    // ✅ ПОЛНАЯ реализация updateMaterials()
-     function applyMaterialUpdates(params) {
-         console.log("🎨 main.qml: applyMaterialUpdates() called")
--
--        if (params.metal !== undefined) {
--            if (params.metal.roughness !== undefined) metalRoughness = params.metal.roughness
--            if (params.metal.metalness !== undefined) metalMetalness = params.metal.metalness
--            if (params.metal.clearcoat !== undefined) metalClearcoat = params.metal.clearcoat
-+        function applyCommon(values, prefix) {
-+            if (values.base_color !== undefined) root[prefix + "BaseColor"] = values.base_color
-+            if (values.metalness !== undefined) root[prefix + "Metalness"] = values.metalness
-+            if (values.roughness !== undefined) root[prefix + "Roughness"] = values.roughness
-+            if (values.specular !== undefined) root[prefix + "SpecularAmount"] = values.specular
-+            if (values.specular_tint !== undefined) root[prefix + "SpecularTint"] = values.specular_tint
-+            if (values.clearcoat !== undefined) root[prefix + "Clearcoat"] = values.clearcoat
-+            if (values.clearcoat_roughness !== undefined) root[prefix + "ClearcoatRoughness"] = values.clearcoat_roughness
-+            if (values.transmission !== undefined) root[prefix + "Transmission"] = values.transmission
-+            if (values.opacity !== undefined) root[prefix + "Opacity"] = values.opacity
-+            if (values.ior !== undefined) root[prefix + "Ior"] = values.ior
-+            if (values.attenuation_distance !== undefined) root[prefix + "AttenuationDistance"] = values.attenuation_distance
-+            if (values.attenuation_color !== undefined) root[prefix + "AttenuationColor"] = values.attenuation_color
-+            if (values.emissive_color !== undefined) root[prefix + "EmissiveColor"] = values.emissive_color
-+            if (values.emissive_intensity !== undefined) root[prefix + "EmissiveIntensity"] = values.emissive_intensity
-         }
--
--        if (params.glass !== undefined) {
--            if (params.glass.opacity !== undefined) glassOpacity = params.glass.opacity
--            if (params.glass.roughness !== undefined) glassRoughness = params.glass.roughness
--            // ✅ НОВОЕ: Коэффициент преломления
--            if (params.glass.ior !== undefined) {
--                glassIOR = params.glass.ior
--                console.log("  🔍 Glass IOR updated to:", glassIOR)
--            }
-+
-+        if (params.frame !== undefined) applyCommon(params.frame, "frame")
-+        if (params.lever !== undefined) applyCommon(params.lever, "lever")
-+        if (params.tail !== undefined) applyCommon(params.tail, "tailRod")
-+        if (params.cylinder !== undefined) applyCommon(params.cylinder, "cylinder")
-+        if (params.piston_body !== undefined) {
-+            applyCommon(params.piston_body, "pistonBody")
-+            if (params.piston_body.warning_color !== undefined) pistonBodyWarningColor = params.piston_body.warning_color
-         }
--
--        if (params.frame !== undefined) {
--            if (params.frame.metalness !== undefined) frameMetalness = params.frame.metalness
--            if (params.frame.roughness !== undefined) frameRoughness = params.frame.roughness
-+        if (params.piston_rod !== undefined) {
-+            applyCommon(params.piston_rod, "pistonRod")
-+            if (params.piston_rod.warning_color !== undefined) pistonRodWarningColor = params.piston_rod.warning_color
-         }
--
--        console.log("  ✅ Materials updated successfully (including IOR)")
-+        if (params.joint_tail !== undefined) {
-+            applyCommon(params.joint_tail, "jointTail")
-+            if (params.joint_tail.ok_color !== undefined) jointRodOkColor = params.joint_tail.ok_color
-+            if (params.joint_tail.error_color !== undefined) jointRodErrorColor = params.joint_tail.error_color
-+        }
-+        if (params.joint_arm !== undefined) {
-+            applyCommon(params.joint_arm, "jointArm")
-+        }
-+
-+        console.log("  ✅ Materials updated successfully")
-     }
-
-     // ✅ ПОЛНАЯ реализация updateEnvironment()
-     function applyEnvironmentUpdates(params) {
-         console.log("🌍 main.qml: applyEnvironmentUpdates() called")
--
--        if (params.background_color !== undefined) backgroundColor = params.background_color
--        if (params.skybox_enabled !== undefined) skyboxEnabled = params.skybox_enabled
--
--        // ✅ НОВОЕ: IBL параметры
--        if (params.ibl_enabled !== undefined) {
--            iblEnabled = params.ibl_enabled
--            console.log("  🌟 IBL enabled:", iblEnabled)
-+
-+        if (params.background) {
-+            if (params.background.mode !== undefined) backgroundMode = params.background.mode
-+            if (params.background.color !== undefined) backgroundColor = params.background.color
-         }
--        if (params.ibl_intensity !== undefined) {
--            iblIntensity = params.ibl_intensity
--            console.log("  🌟 IBL intensity:", iblIntensity)
-+
-+        if (params.ibl) {
-+            if (params.ibl.enabled !== undefined) iblEnabled = params.ibl.enabled
-+            if (params.ibl.intensity !== undefined) iblIntensity = params.ibl.intensity
-+            if (params.ibl.blur !== undefined) skyboxBlur = params.ibl.blur
-+            if (params.ibl.source !== undefined) {
-+                var resolvedSource = resolveUrl(params.ibl.source)
-+                if (resolvedSource && resolvedSource !== "") {
-+                    iblLoader._fallbackTried = false
-+                    iblPrimarySource = resolvedSource
-+                    console.log("  🌟 IBL source:", iblPrimarySource)
-+                }
-+            }
-+            if (params.ibl.fallback !== undefined) {
-+                var resolvedFallback = resolveUrl(params.ibl.fallback)
-+                if (resolvedFallback && resolvedFallback !== "") {
-+                    iblLoader._fallbackTried = false
-+                    iblFallbackSource = resolvedFallback
-+                    console.log("  🌟 IBL fallback:", iblFallbackSource)
-+                }
-+            }
-         }
--
--        // Туман
--        if (params.fog_enabled !== undefined) fogEnabled = params.fog_enabled
--        if (params.fog_color !== undefined) fogColor = params.fog_color
--        if (params.fog_density !== undefined) fogDensity = params.fog_density
--
--        console.log("  ✅ Environment updated successfully (including IBL)")
-+
-+        if (params.fog) {
-+            if (params.fog.enabled !== undefined) fogEnabled = params.fog.enabled
-+            if (params.fog.color !== undefined) fogColor = params.fog.color
-+            if (params.fog.density !== undefined) fogDensity = params.fog.density
-+            if (params.fog.near !== undefined) fogNear = params.fog.near
-+            if (params.fog.far !== undefined) fogFar = params.fog.far
-+        }
-+
-+        if (params.ambient_occlusion) {
-+            if (params.ambient_occlusion.enabled !== undefined) aoEnabled = params.ambient_occlusion.enabled
-+            if (params.ambient_occlusion.strength !== undefined) aoStrength = params.ambient_occlusion.strength
-+            if (params.ambient_occlusion.radius !== undefined) aoRadius = params.ambient_occlusion.radius
-+        }
-+
-+        console.log("  ✅ Environment updated successfully")
-     }
-
-     // ✅ ПОЛНАЯ реализация updateQuality()
-     function applyQualityUpdates(params) {
-         console.log("⚙️ main.qml: applyQualityUpdates() called")
--
--        if (params.antialiasing !== undefined) antialiasingMode = params.antialiasing
--        if (params.aa_quality !== undefined) antialiasingQuality = params.aa_quality
--        if (params.shadows_enabled !== undefined) shadowsEnabled = params.shadows_enabled
--        if (params.shadow_quality !== undefined) shadowQuality = params.shadow_quality
--
--        // ✅ НОВОЕ: Мягкость теней
--        if (params.shadow_softness !== undefined) {
--            shadowSoftness = params.shadow_softness
--            console.log("  🌫️ Shadow softness:", shadowSoftness)
-+
-+        if (params.shadows) {
-+            if (params.shadows.enabled !== undefined) shadowsEnabled = params.shadows.enabled
-+            if (params.shadows.resolution !== undefined) shadowResolution = params.shadows.resolution
-+            if (params.shadows.filter !== undefined) shadowFilterSamples = params.shadows.filter
-+            if (params.shadows.bias !== undefined) shadowBias = params.shadows.bias
-+            if (params.shadows.darkness !== undefined) shadowFactor = params.shadows.darkness
-         }
--
--        console.log("  ✅ Quality updated successfully (including shadow softness)")
-+
-+        if (params.antialiasing) {
-+            if (params.antialiasing.primary !== undefined) aaPrimaryMode = params.antialiasing.primary
-+            if (params.antialiasing.quality !== undefined) aaQualityLevel = params.antialiasing.quality
-+            if (params.antialiasing.post !== undefined) aaPostMode = params.antialiasing.post
-+        }
-+
-+        if (params.taa_enabled !== undefined) taaEnabled = params.taa_enabled
-+        if (params.taa_strength !== undefined) taaStrength = params.taa_strength
-+        if (params.fxaa_enabled !== undefined) fxaaEnabled = params.fxaa_enabled
-+        if (params.specular_aa !== undefined) specularAAEnabled = params.specular_aa
-+        if (params.dithering !== undefined) ditheringEnabled = params.dithering
-+        if (params.render_scale !== undefined) renderScale = params.render_scale
-+        if (params.render_policy !== undefined) renderPolicy = params.render_policy
-+        if (params.frame_rate_limit !== undefined) frameRateLimit = params.frame_rate_limit
-+        if (params.oit !== undefined) oitMode = params.oit
-+        if (params.preset !== undefined) qualityPreset = params.preset
-+
-+        console.log("  🎚 Quality preset:", qualityPreset, ", FPS limit:", frameRateLimit)
-+        console.log("  ✅ Quality updated successfully")
-     }
-
-     // ✅ ПОЛНАЯ реализация updateCamera()
-     function applyCameraUpdates(params) {
-         console.log("📷 main.qml: applyCameraUpdates() called")
-
-         if (params.fov !== undefined) cameraFov = params.fov
-         if (params.near !== undefined) cameraNear = params.near
-         if (params.far !== undefined) cameraFar = params.far
-         if (params.speed !== undefined) cameraSpeed = params.speed
-         if (params.auto_rotate !== undefined) autoRotate = params.auto_rotate
-         if (params.auto_rotate_speed !== undefined) autoRotateSpeed = params.auto_rotate_speed
-
-         console.log("  ✅ Camera updated successfully")
-     }
-
-     // ✅ ПОЛНАЯ реализация updateEffects()
-     function applyEffectsUpdates(params) {
-         console.log("✨ main.qml: applyEffectsUpdates() called")
-
--        // Bloom - РАСШИРЕННЫЙ
-         if (params.bloom_enabled !== undefined) bloomEnabled = params.bloom_enabled
-         if (params.bloom_intensity !== undefined) bloomIntensity = params.bloom_intensity
--        if (params.bloom_threshold !== undefined) {
--            bloomThreshold = params.bloom_threshold
--            console.log("  🌟 Bloom threshold:", bloomThreshold)
--        }
--
--        // SSAO - РАСШИРЕННЫЙ
--        if (params.ssao_enabled !== undefined) ssaoEnabled = params.ssao_enabled
--        if (params.ssao_intensity !== undefined) ssaoIntensity = params.ssao_intensity
--        if (params.ssao_radius !== undefined) {
--            ssaoRadius = params.ssao_radius
--            console.log("  🌑 SSAO radius:", ssaoRadius)
--        }
--
--        // ✅ НОВОЕ: Тонемаппинг
--        if (params.tonemap_enabled !== undefined) {
--            tonemapEnabled = params.tonemap_enabled
--            console.log("  🎨 Tonemap enabled:", tonemapEnabled)
--        }
--        if (params.tonemap_mode !== undefined) {
--            tonemapMode = params.tonemap_mode
--            console.log("  🎨 Tonemap mode:", tonemapMode)
--        }
--
--        // ✅ НОВОЕ: Depth of Field
-+        if (params.bloom_threshold !== undefined) bloomThreshold = params.bloom_threshold
-+        if (params.bloom_spread !== undefined) bloomSpread = params.bloom_spread
-+
-         if (params.depth_of_field !== undefined) depthOfFieldEnabled = params.depth_of_field
--        if (params.dof_focus_distance !== undefined) {
--            dofFocusDistance = params.dof_focus_distance
--            console.log("  🔍 DoF focus distance:", dofFocusDistance)
--        }
--        if (params.dof_focus_range !== undefined) {
--            dofFocusRange = params.dof_focus_range
--            console.log("  🔍 DoF focus range:", dofFocusRange)
--        }
--
--        // ✅ НОВОЕ: Виньетирование
--        if (params.vignette_enabled !== undefined) {
--            vignetteEnabled = params.vignette_enabled
--            console.log("  🖼️ Vignette enabled:", vignetteEnabled)
--        }
--        if (params.vignette_strength !== undefined) {
--            vignetteStrength = params.vignette_strength
--            console.log("  🖼️ Vignette strength:", vignetteStrength)
--        }
--
--        // ✅ НОВОЕ: Lens Flare
--        if (params.lens_flare_enabled !== undefined) {
--            lensFlareEnabled = params.lens_flare_enabled
--            console.log("  ✨ Lens Flare enabled:", lensFlareEnabled)
--        }
--
--        // Motion Blur
-+        if (params.dof_focus_distance !== undefined) dofFocusDistance = params.dof_focus_distance
-+        if (params.dof_blur !== undefined) dofBlurAmount = params.dof_blur
-+
-         if (params.motion_blur !== undefined) motionBlurEnabled = params.motion_blur
--
--        console.log("  ✅ Visual effects updated successfully (COMPLETE)")
-+        if (params.motion_blur_amount !== undefined) motionBlurAmount = params.motion_blur_amount
-+
-+        if (params.lens_flare !== undefined) lensFlareEnabled = params.lens_flare
-+        if (params.vignette !== undefined) vignetteEnabled = params.vignette
-+        if (params.vignette_strength !== undefined) vignetteStrength = params.vignette_strength
-+
-+        if (params.tonemap_enabled !== undefined) tonemapEnabled = params.tonemap_enabled
-+        if (params.tonemap_mode !== undefined) {
-+            var allowedModes = ["filmic", "aces", "reinhard", "gamma", "linear"]
-+            if (allowedModes.indexOf(params.tonemap_mode) !== -1)
-+                tonemapModeName = params.tonemap_mode
-+        }
-+
-+        console.log("  ✅ Visual effects updated successfully")
-     }
-
-     // Legacy functions for backward compatibility
-     function updateGeometry(params) { applyGeometryUpdates(params) }
-     function updateLighting(params) { applyLightingUpdates(params) }
-     function updateMaterials(params) { applyMaterialUpdates(params) }     // ✅ РЕАЛИЗОВАНО
-     function updateEnvironment(params) { applyEnvironmentUpdates(params) } // ✅ РЕАЛИЗОВАНО
-     function updateQuality(params) { applyQualityUpdates(params) }         // ✅ РЕАЛИЗОВАНО
-     function updateEffects(params) { applyEffectsUpdates(params) }         // ✅ РЕАЛИЗОВАНО
-     function updateCamera(params) { applyCameraUpdates(params) }           // ✅ РЕАЛИЗОВАНО
-
-     function updatePistonPositions(positions) {
-         if (positions.fl !== undefined) userPistonPositionFL = Number(positions.fl)
-         if (positions.fr !== undefined) userPistonPositionFR = Number(positions.fr)
-         if (positions.rl !== undefined) userPistonPositionRL = Number(positions.rl)
-         if (positions.rr !== undefined) userPistonPositionRR = Number(positions.rr)
-     }
-
-     // ===============================================================
-     // 3D SCENE (ENHANCED with all new parameters)
-     // ===============================================================
-
-     View3D {
-         id: view3d
-         anchors.fill: parent
-
-+        renderSettings: RenderSettings {
-+            renderScale: root.renderScale
-+            renderPolicy: root.renderPolicy === "ondemand" ? RenderSettings.OnDemand : RenderSettings.Always
-+            maximumFrameRate: root.frameRateLimit
-+        }
-+
-         environment: ExtendedSceneEnvironment {
--            backgroundMode: skyboxEnabled ? SceneEnvironment.SkyBox : SceneEnvironment.Color
--            clearColor: backgroundColor
--            lightProbe: iblEnabled ? null : null                           // ✅ НОВОЕ: IBL
--            probeExposure: iblIntensity                                    // ✅ НОВОЕ: IBL
--
--            tonemapMode: tonemapEnabled ?
--                (tonemapMode === 3 ? SceneEnvironment.TonemapModeFilmic :
--                 tonemapMode === 2 ? SceneEnvironment.TonemapModeReinhard :
--                 tonemapMode === 1 ? SceneEnvironment.TonemapModeLinear :
--                 SceneEnvironment.TonemapModeNone) : SceneEnvironment.TonemapModeNone
-+            id: mainEnvironment
-+            backgroundMode: root.backgroundMode === "skybox" && root.iblReady ? SceneEnvironment.SkyBox : SceneEnvironment.Color
-+            clearColor: root.backgroundColor
-+            lightProbe: root.iblEnabled && root.iblReady ? iblLoader.probe : null
-+            probeExposure: root.iblIntensity
-+            skyBoxBlurAmount: root.skyboxBlur
-+            fogEnabled: root.fogEnabled
-+            fogColor: root.fogColor
-+            fogDensity: root.fogDensity
-+            fogDepthBegin: root.fogNear
-+            fogDepthEnd: root.fogFar
-+
-+            tonemapMode: root.tonemapEnabled ?
-+                (root.tonemapModeName === "filmic" ? SceneEnvironment.TonemapModeFilmic :
-+                 root.tonemapModeName === "aces" ?
-+                     (SceneEnvironment.TonemapModeAces !== undefined ? SceneEnvironment.TonemapModeAces
-+                                                                       : SceneEnvironment.TonemapModeFilmic) :
-+                 root.tonemapModeName === "reinhard" ? SceneEnvironment.TonemapModeReinhard :
-+                 root.tonemapModeName === "gamma" ?
-+                     (SceneEnvironment.TonemapModeGamma !== undefined ? SceneEnvironment.TonemapModeGamma
-+                                                                       : SceneEnvironment.TonemapModeLinear) :
-+                 SceneEnvironment.TonemapModeLinear) : SceneEnvironment.TonemapModeNone
-             exposure: 1.0
-             whitePoint: 2.0
--
--            antialiasingMode: antialiasingMode === 3 ? SceneEnvironment.ProgressiveAA :
--                             antialiasingMode === 2 ? SceneEnvironment.MSAA :
--                             antialiasingMode === 1 ? SceneEnvironment.SSAA :
-+
-+            antialiasingMode: root.aaPrimaryMode === "msaa" ? SceneEnvironment.MSAA :
-+                             root.aaPrimaryMode === "ssaa" ? SceneEnvironment.SSAA :
-                              SceneEnvironment.NoAA
--            antialiasingQuality: (antialiasingQuality !== undefined && antialiasingQuality === 2) ? SceneEnvironment.High :
--                               (antialiasingQuality !== undefined && antialiasingQuality === 1) ? SceneEnvironment.Medium :
-+            antialiasingQuality: root.aaQualityLevel === "high" ? SceneEnvironment.High :
-+                               root.aaQualityLevel === "medium" ? SceneEnvironment.Medium :
-                                SceneEnvironment.Low
--
--            specularAAEnabled: true
--            ditheringEnabled: true
--            fxaaEnabled: true
--            temporalAAEnabled: isRunning
--
--            aoEnabled: ssaoEnabled
--            aoStrength: ssaoIntensity * 100
--            aoDistance: ssaoRadius                                         // ✅ НОВОЕ: Радиус SSAO
-+            fxaaEnabled: root.aaPostMode === "fxaa" && root.fxaaEnabled
-+            temporalAAEnabled: (root.aaPostMode === "taa" && root.taaEnabled && root.aaPrimaryMode !== "msaa")
-+            temporalAAStrength: root.taaStrength
-+            specularAAEnabled: root.specularAAEnabled
-+            ditheringEnabled: root.ditheringEnabled
-+
-+            aoEnabled: root.aoEnabled
-+            aoStrength: root.aoStrength
-+            aoDistance: Math.max(1.0, root.aoRadius)
-             aoSoftness: 20
-             aoDither: true
-             aoSampleRate: 3
--
--            glowEnabled: bloomEnabled
--            glowIntensity: bloomIntensity
--            glowBloom: 0.5
--            glowStrength: 0.8
-+
-+            glowEnabled: root.bloomEnabled
-+            glowIntensity: root.bloomIntensity
-+            glowBloom: root.bloomSpread
-+            glowStrength: 0.9
-             glowQualityHigh: true
-             glowUseBicubicUpscale: true
--            glowHDRMinimumValue: bloomThreshold                            // ✅ НОВОЕ: Порог Bloom
--            glowHDRMaximumValue: 8.0
--            glowHDRScale: 2.0
--
--            lensFlareEnabled: lensFlareEnabled                             // ✅ НОВОЕ: Lens Flare
-+            glowHDRMinimumValue: root.bloomThreshold
-+            glowHDRMaximumValue: 6.0
-+            glowHDRScale: 1.5
-+
-+            lensFlareEnabled: root.lensFlareEnabled
-             lensFlareGhostCount: 3
-             lensFlareGhostDispersal: 0.6
-             lensFlareHaloWidth: 0.25
-             lensFlareBloomBias: 0.35
-             lensFlareStretchToAspect: 1.0
--
--            depthOfFieldEnabled: depthOfFieldEnabled
--            depthOfFieldFocusDistance: dofFocusDistance                    // ✅ НОВОЕ: Дистанция фокуса
--            depthOfFieldFocusRange: dofFocusRange                          // ✅ НОВОЕ: Диапазон фокуса
--            depthOfFieldBlurAmount: 3.0
--
--            vignetteEnabled: vignetteEnabled                               // ✅ НОВОЕ: Виньетирование
-+
-+            depthOfFieldEnabled: root.depthOfFieldEnabled
-+            depthOfFieldFocusDistance: root.dofFocusDistance
-+            depthOfFieldBlurAmount: root.dofBlurAmount
-+
-+            motionBlurEnabled: root.motionBlurEnabled
-+            motionBlurAmount: root.motionBlurAmount
-+
-+            vignetteEnabled: root.vignetteEnabled
-             vignetteRadius: 0.4
--            vignetteStrength: vignetteStrength                             // ✅ НОВОЕ: Сила виньетирования
--
-+            vignetteStrength: root.vignetteStrength
-+
-+            oitMethod: root.oitMode === "weighted" ? SceneEnvironment.OITWeightedBlended : SceneEnvironment.OITNone
-+
-             colorAdjustmentsEnabled: true
-             adjustmentBrightness: 1.0
-             adjustmentContrast: 1.05
-             adjustmentSaturation: 1.05
-         }
-
-+        // ===============================================================
-+        // MATERIAL LIBRARY (shared instances to avoid duplication)
-+        // ===============================================================
-+
-+        PrincipledMaterial {
-+            id: frameMaterial
-+            baseColor: frameBaseColor
-+            metalness: frameMetalness
-+            roughness: frameRoughness
-+            specularAmount: frameSpecularAmount
-+            specularTint: frameSpecularTint
-+            clearcoatAmount: frameClearcoat
-+            clearcoatRoughnessAmount: frameClearcoatRoughness
-+            transmissionFactor: frameTransmission
-+            opacity: frameOpacity
-+            indexOfRefraction: frameIor
-+            attenuationDistance: frameAttenuationDistance
-+            attenuationColor: frameAttenuationColor
-+            emissiveColor: frameEmissiveColor
-+            emissiveFactor: frameEmissiveIntensity
-+        }
-+
-+        PrincipledMaterial {
-+            id: leverMaterial
-+            baseColor: leverBaseColor
-+            metalness: leverMetalness
-+            roughness: leverRoughness
-+            specularAmount: leverSpecularAmount
-+            specularTint: leverSpecularTint
-+            clearcoatAmount: leverClearcoat
-+            clearcoatRoughnessAmount: leverClearcoatRoughness
-+            transmissionFactor: leverTransmission
-+            opacity: leverOpacity
-+            indexOfRefraction: leverIor
-+            attenuationDistance: leverAttenuationDistance
-+            attenuationColor: leverAttenuationColor
-+            emissiveColor: leverEmissiveColor
-+            emissiveFactor: leverEmissiveIntensity
-+        }
-+
-+        PrincipledMaterial {
-+            id: tailRodMaterial
-+            baseColor: tailRodBaseColor
-+            metalness: tailRodMetalness
-+            roughness: tailRodRoughness
-+            specularAmount: tailRodSpecularAmount
-+            specularTint: tailRodSpecularTint
-+            clearcoatAmount: tailRodClearcoat
-+            clearcoatRoughnessAmount: tailRodClearcoatRoughness
-+            transmissionFactor: tailRodTransmission
-+            opacity: tailRodOpacity
-+            indexOfRefraction: tailRodIor
-+            attenuationDistance: tailRodAttenuationDistance
-+            attenuationColor: tailRodAttenuationColor
-+            emissiveColor: tailRodEmissiveColor
-+            emissiveFactor: tailRodEmissiveIntensity
-+        }
-+
-+        PrincipledMaterial {
-+            id: cylinderMaterial
-+            baseColor: cylinderBaseColor
-+            metalness: cylinderMetalness
-+            roughness: cylinderRoughness
-+            specularAmount: cylinderSpecularAmount
-+            specularTint: cylinderSpecularTint
-+            clearcoatAmount: cylinderClearcoat
-+            clearcoatRoughnessAmount: cylinderClearcoatRoughness
-+            transmissionFactor: cylinderTransmission
-+            opacity: cylinderOpacity
-+            indexOfRefraction: cylinderIor
-+            attenuationDistance: cylinderAttenuationDistance
-+            attenuationColor: cylinderAttenuationColor
-+            emissiveColor: cylinderEmissiveColor
-+            emissiveFactor: cylinderEmissiveIntensity
-+            alphaMode: PrincipledMaterial.Blend
-+        }
-+
-+        PrincipledMaterial {
-+            id: jointTailMaterial
-+            baseColor: jointTailBaseColor
-+            metalness: jointTailMetalness
-+            roughness: jointTailRoughness
-+            specularAmount: jointTailSpecularAmount
-+            specularTint: jointTailSpecularTint
-+            clearcoatAmount: jointTailClearcoat
-+            clearcoatRoughnessAmount: jointTailClearcoatRoughness
-+            transmissionFactor: jointTailTransmission
-+            opacity: jointTailOpacity
-+            indexOfRefraction: jointTailIor
-+            attenuationDistance: jointTailAttenuationDistance
-+            attenuationColor: jointTailAttenuationColor
-+            emissiveColor: jointTailEmissiveColor
-+            emissiveFactor: jointTailEmissiveIntensity
-+        }
-+
-+        PrincipledMaterial {
-+            id: jointArmMaterial
-+            baseColor: jointArmBaseColor
-+            metalness: jointArmMetalness
-+            roughness: jointArmRoughness
-+            specularAmount: jointArmSpecularAmount
-+            specularTint: jointArmSpecularTint
-+            clearcoatAmount: jointArmClearcoat
-+            clearcoatRoughnessAmount: jointArmClearcoatRoughness
-+            transmissionFactor: jointArmTransmission
-+            opacity: jointArmOpacity
-+            indexOfRefraction: jointArmIor
-+            attenuationDistance: jointArmAttenuationDistance
-+            attenuationColor: jointArmAttenuationColor
-+            emissiveColor: jointArmEmissiveColor
-+            emissiveFactor: jointArmEmissiveIntensity
-+        }
-+
-         // Camera rig (preserved)
-         Node {
-             id: cameraRig
-             position: root.pivot
-             eulerRotation: Qt.vector3d(root.pitchDeg, root.yawDeg, 0)
-
-             Node {
-                 id: panNode
-                 position: Qt.vector3d(root.panX, root.panY, 0)
-
-                 PerspectiveCamera {
-                     id: camera
-                     position: Qt.vector3d(0, 0, root.cameraDistance)
-                     fieldOfView: root.cameraFov
-                     clipNear: root.cameraNear
-                     clipFar: root.cameraFar
-                 }
-             }
-         }
-
-         // Lighting (with shadow softness)
-         DirectionalLight {
-             id: keyLight
--            eulerRotation.x: keyLightAngleX
--            eulerRotation.y: keyLightAngleY
--            brightness: keyLightBrightness
--            color: keyLightColor
--            castsShadow: shadowsEnabled
--            shadowMapQuality: shadowQuality === 2 ? Light.ShadowMapQualityHigh :
--                             shadowQuality === 1 ? Light.ShadowMapQualityMedium :
-+            eulerRotation.x: root.keyLightAngleX
-+            eulerRotation.y: root.keyLightAngleY
-+            brightness: root.keyLightBrightness
-+            color: root.keyLightColor
-+            castsShadow: root.shadowsEnabled
-+            shadowMapQuality: root.shadowResolution === "4096" ?
-+                                 (typeof Light.ShadowMapQualityUltra !== "undefined" ? Light.ShadowMapQualityUltra
-+                                                                                       : Light.ShadowMapQualityVeryHigh) :
-+                             root.shadowResolution === "2048" ? Light.ShadowMapQualityVeryHigh :
-+                             root.shadowResolution === "1024" ? Light.ShadowMapQualityHigh :
-+                             root.shadowResolution === "512" ? Light.ShadowMapQualityMedium :
-                              Light.ShadowMapQualityLow
--            shadowFactor: 75
--            shadowBias: shadowSoftness * 0.001                            // ✅ НОВОЕ: Мягкость теней
-+            shadowFactor: root.shadowFactor
-+            shadowBias: root.shadowBias
-+            shadowFilter: root.shadowFilterSamples === 32 ? Light.ShadowFilterPCF32 :
-+                           root.shadowFilterSamples === 16 ? Light.ShadowFilterPCF16 :
-+                           root.shadowFilterSamples === 8 ? Light.ShadowFilterPCF8 :
-+                           root.shadowFilterSamples === 4 ? Light.ShadowFilterPCF4 :
-+                           Light.ShadowFilterNone
-         }
--
-+
-         DirectionalLight {
-             id: fillLight
-             eulerRotation.x: -60
-             eulerRotation.y: 135
--            brightness: fillLightBrightness
--            color: fillLightColor
-+            brightness: root.fillLightBrightness
-+            color: root.fillLightColor
-             castsShadow: false
-         }
--
-+
-         DirectionalLight {
-             id: rimLight
-             eulerRotation.x: 15
-             eulerRotation.y: 180
--            brightness: 1.5
--            color: "#ffffcc"
-+            brightness: root.rimLightBrightness
-+            color: root.rimLightColor
-             castsShadow: false
-         }
--
-+
-         PointLight {
-             id: accentLight
--            position: Qt.vector3d(0, pointLightY, 1500)
--            brightness: pointLightBrightness
--            color: "#ffffff"
--            quadraticFade: 0.00008
-+            position: Qt.vector3d(0, root.pointLightY, 1500)
-+            brightness: root.pointLightBrightness
-+            color: root.pointLightColor
-+            constantFade: 1.0
-+            linearFade: 2.0 / Math.max(200.0, root.pointLightRange)
-+            quadraticFade: 1.0 / Math.pow(Math.max(200.0, root.pointLightRange), 2)
-         }
-
-         // ===============================================================
-         // SUSPENSION SYSTEM GEOMETRY (with IOR support)
-         // ===============================================================
-
-         // U-FRAME (3 beams) with controlled materials
-         Model {
-             source: "#Cube"
-             position: Qt.vector3d(0, userBeamSize/2, userFrameLength/2)
-             scale: Qt.vector3d(userBeamSize/100, userBeamSize/100, userFrameLength/100)
--            materials: PrincipledMaterial {
--                baseColor: "#cc0000"
--                metalness: frameMetalness
--                roughness: frameRoughness
--            }
-+            materials: [frameMaterial]
-         }
-         Model {
-             source: "#Cube"
-             position: Qt.vector3d(0, userBeamSize + userFrameHeight/2, userBeamSize/2)
-             scale: Qt.vector3d(userBeamSize/100, userFrameHeight/100, userBeamSize/100)
--            materials: PrincipledMaterial {
--                baseColor: "#cc0000"
--                metalness: frameMetalness
--                roughness: frameRoughness
--            }
-+            materials: [frameMaterial]
-         }
-         Model {
-             source: "#Cube"
-             position: Qt.vector3d(0, userBeamSize + userFrameHeight/2, userFrameLength - userBeamSize/2)
-             scale: Qt.vector3d(userBeamSize/100, userFrameHeight/100, userBeamSize/100)
--            materials: PrincipledMaterial {
--                baseColor: "#cc0000"
--                metalness: frameMetalness
--                roughness: frameRoughness
--            }
-+            materials: [frameMaterial]
-         }
-
-         // ✅ OPTIMIZED SUSPENSION COMPONENT (with CORRECT rod length calculation)
-         component OptimizedSuspensionCorner: Node {
-             property vector3d j_arm
-             property vector3d j_tail
-             property real leverAngle
-             property real pistonPositionFromPython: 250.0
-
-             // ✅ ИСПРАВЛЕНО: Избегаем циклические зависимости - используем прямые вычисления
-             // Базовая геометрия рычага
-             readonly property real baseAngle: (j_arm.x < 0) ? 180 : 0
-             readonly property real totalAngle: baseAngle + leverAngle
-             readonly property real totalAngleRad: totalAngle * Math.PI / 180
-
-             // Позиция шарнира штока на рычаге
-             readonly property vector3d j_rod: Qt.vector3d(
-                 j_arm.x + (userLeverLength * userRodPosition) * Math.cos(totalAngleRad),
-                 j_arm.y + (userLeverLength * userRodPosition) * Math.sin(totalAngleRad),
-                 j_arm.z
-             )
-
-             // Направление от j_tail к j_rod (направление цилиндра)
-             readonly property vector3d cylDirection: Qt.vector3d(j_rod.x - j_tail.x, j_rod.y - j_tail.y, 0)
-             readonly property real cylDirectionLength: Math.hypot(cylDirection.x, cylDirection.y)
-@@ -806,153 +1129,162 @@ Item {
-             readonly property real rodLengthSquared: pistonRodLength * pistonRodLength
-             readonly property real perpDistSquared: perpendicularDistance * perpendicularDistance
-             readonly property real axialDistanceFromProjection: Math.sqrt(Math.max(0, rodLengthSquared - perpDistSquared))
-
-             // Позиция поршня на оси цилиндра (назад от проекции j_rod)
-             readonly property real pistonPositionOnAxis: projectionOnCylAxis - axialDistanceFromProjection
-
-             // Ограничиваем поршень в пределах цилиндра
-             readonly property real clampedPistonPosition: Math.max(10, Math.min(userCylinderLength - 10, pistonPositionOnAxis))
-
-             // ✅ ФИНАЛЬНАЯ позиция поршня (на оси цилиндра)
-             readonly property vector3d pistonCenter: Qt.vector3d(
-                 tailRodEnd.x + cylDirectionNorm.x * clampedPistonPosition,
-                 tailRodEnd.y + cylDirectionNorm.y * clampedPistonPosition,
-                 tailRodEnd.z
-             )
-
-             // ✅ ПРОВЕРКА: реальная длина штока (для отладки)
-             readonly property real actualRodLength: Math.hypot(j_rod.x - pistonCenter.x, j_rod.y - pistonCenter.y)
-             readonly property real rodLengthError: Math.abs(actualRodLength - pistonRodLength)
-
-             // LEVER (рычаг)
-             Model {
-                 source: "#Cube"
-                 position: Qt.vector3d(
--                    j_arm.x + (userLeverLength/2) * Math.cos(totalAngleRad),
--                    j_arm.y + (userLeverLength/2) * Math.sin(totalAngleRad),
-+                    j_arm.x + (userLeverLength/2) * Math.cos(totalAngleRad),
-+                    j_arm.y + (userLeverLength/2) * Math.sin(totalAngleRad),
-                     j_arm.z
-                 )
-                 scale: Qt.vector3d(userLeverLength/100, 0.8, 0.8)
-                 eulerRotation: Qt.vector3d(0, 0, totalAngle)
--                materials: PrincipledMaterial {
--                    baseColor: "#888888"
--                    metalness: metalMetalness
--                    roughness: metalRoughness
--                    clearcoatAmount: metalClearcoat
--                }
-+                materials: [leverMaterial]
-             }
-
-             // TAIL ROD (хвостовой шток) - КОНСТАНТНАЯ длина
-             Model {
-                 source: "#Cylinder"
-                 position: Qt.vector3d((j_tail.x + tailRodEnd.x)/2, (j_tail.y + tailRodEnd.y)/2, j_tail.z)
-                 scale: Qt.vector3d(userRodDiameter/100, tailRodLength/100, userRodDiameter/100)
-                 eulerRotation: Qt.vector3d(0, 0, cylAngle)
--                materials: PrincipledMaterial {
--                    baseColor: "#cccccc"
--                    metalness: metalMetalness
--                    roughness: metalRoughness
--                }
-+                materials: [tailRodMaterial]
-             }
-
-             // CYLINDER BODY (корпус цилиндра) с IOR
-             Model {
-                 source: "#Cylinder"
-                 position: Qt.vector3d((tailRodEnd.x + cylinderEnd.x)/2, (tailRodEnd.y + cylinderEnd.y)/2, tailRodEnd.z)
-                 scale: Qt.vector3d(userBoreHead/100, userCylinderLength/100, userBoreHead/100)
-                 eulerRotation: Qt.vector3d(0, 0, cylAngle)
--                materials: PrincipledMaterial {
--                    baseColor: "#ffffff"
--                    metalness: 0.0
--                    roughness: glassRoughness
--                    opacity: glassOpacity
--                    indexOfRefraction: glassIOR          // ✅ Коэффициент преломления
--                    alphaMode: PrincipledMaterial.Blend
--                }
-+                materials: [cylinderMaterial]
-             }
-
-             // ✅ PISTON (поршень) - правильная позиция для константной длины штока
-             Model {
-                 source: "#Cylinder"
-                 position: pistonCenter
-                 scale: Qt.vector3d((userBoreHead - 2)/100, userPistonThickness/100, (userBoreHead - 2)/100)
-                 eulerRotation: Qt.vector3d(0, 0, cylAngle)
--                materials: PrincipledMaterial {
--                    baseColor: rodLengthError > 1.0 ? "#ff4444" : "#ff0066"  // Краснее если большая ошибка
--                    metalness: metalMetalness
--                    roughness: metalRoughness
-+                materials: PrincipledMaterial {
-+                    baseColor: rodLengthError > 1.0 ? pistonBodyWarningColor : pistonBodyBaseColor
-+                    metalness: pistonBodyMetalness
-+                    roughness: pistonBodyRoughness
-+                    specularAmount: pistonBodySpecularAmount
-+                    specularTint: pistonBodySpecularTint
-+                    clearcoatAmount: pistonBodyClearcoat
-+                    clearcoatRoughnessAmount: pistonBodyClearcoatRoughness
-+                    transmissionFactor: pistonBodyTransmission
-+                    opacity: pistonBodyOpacity
-+                    indexOfRefraction: pistonBodyIor
-+                    attenuationDistance: pistonBodyAttenuationDistance
-+                    attenuationColor: pistonBodyAttenuationColor
-+                    emissiveColor: pistonBodyEmissiveColor
-+                    emissiveFactor: pistonBodyEmissiveIntensity
-                 }
-             }
--
-+
-             // ✅ PISTON ROD (шток поршня) - КОНСТАНТНАЯ длина!
-             Model {
-                 source: "#Cylinder"
-                 position: Qt.vector3d((pistonCenter.x + j_rod.x)/2, (pistonCenter.y + j_rod.y)/2, pistonCenter.z)
-                 scale: Qt.vector3d(userRodDiameter/100, pistonRodLength/100, userRodDiameter/100)  // ✅ КОНСТАНТНАЯ ДЛИНА!
-                 eulerRotation: Qt.vector3d(0, 0, Math.atan2(j_rod.y - pistonCenter.y, j_rod.x - pistonCenter.x) * 180 / Math.PI + 90)
--                materials: PrincipledMaterial {
--                    baseColor: rodLengthError > 1.0 ? "#ff0000" : "#cccccc"  // Красный если ошибка > 1мм
--                    metalness: metalMetalness
--                    roughness: metalRoughness
-+                materials: PrincipledMaterial {
-+                    baseColor: rodLengthError > 1.0 ? pistonRodWarningColor : pistonRodBaseColor  // Красный если ошибка > 1мм
-+                    metalness: pistonRodMetalness
-+                    roughness: pistonRodRoughness
-+                    specularAmount: pistonRodSpecularAmount
-+                    specularTint: pistonRodSpecularTint
-+                    clearcoatAmount: pistonRodClearcoat
-+                    clearcoatRoughnessAmount: pistonRodClearcoatRoughness
-+                    transmissionFactor: pistonRodTransmission
-+                    opacity: pistonRodOpacity
-+                    indexOfRefraction: pistonRodIor
-+                    attenuationDistance: pistonRodAttenuationDistance
-+                    attenuationColor: pistonRodAttenuationColor
-+                    emissiveColor: pistonRodEmissiveColor
-+                    emissiveFactor: pistonRodEmissiveIntensity
-                 }
-             }
-
-             // JOINTS (шарниры) - цветные маркеры
-             Model {
-                 source: "#Cylinder"
-                 position: j_tail
-                 scale: Qt.vector3d(1.2, 2.4, 1.2)
-                 eulerRotation: Qt.vector3d(90, 0, 0)
--                materials: PrincipledMaterial {
--                    baseColor: "#0088ff"  // Синий - шарнир цилиндра
--                    metalness: metalMetalness
--                    roughness: metalRoughness
--                }
-+                materials: [jointTailMaterial]
-             }
-
-             Model {
-                 source: "#Cylinder"
-                 position: j_arm
-                 scale: Qt.vector3d(1.0, 2.0, 1.0)
-                 eulerRotation: Qt.vector3d(90, 0, 0)
--                materials: PrincipledMaterial {
--                    baseColor: "#ff8800"  // Оранжевый - шарнир рычага
--                    metalness: metalMetalness
--                    roughness: metalRoughness
--                }
-+                materials: [jointArmMaterial]
-             }
-
-             Model {
-                 source: "#Cylinder"
-                 position: j_rod
-                 scale: Qt.vector3d(0.8, 1.6, 0.8)
-                 eulerRotation: Qt.vector3d(90, 0, leverAngle * 0.1)
--                materials: PrincipledMaterial {
--                    baseColor: rodLengthError > 1.0 ? "#ff0000" : "#00ff44"  // Красный если ошибка, зеленый если OK
--                    metalness: metalMetalness
--                    roughness: metalRoughness
-+                materials: PrincipledMaterial {
-+                    baseColor: rodLengthError > 1.0 ? jointRodErrorColor : jointRodOkColor  // Красный если ошибка, зеленый если OK
-+                    metalness: jointTailMetalness
-+                    roughness: jointTailRoughness
-+                    specularAmount: jointTailSpecularAmount
-+                    specularTint: jointTailSpecularTint
-+                    clearcoatAmount: jointTailClearcoat
-+                    clearcoatRoughnessAmount: jointTailClearcoatRoughness
-+                    transmissionFactor: jointTailTransmission
-+                    opacity: jointTailOpacity
-+                    indexOfRefraction: jointTailIor
-+                    attenuationDistance: jointTailAttenuationDistance
-+                    attenuationColor: jointTailAttenuationColor
-+                    emissiveColor: jointTailEmissiveColor
-+                    emissiveFactor: jointTailEmissiveIntensity
-                 }
-             }
-
-             // ✅ DEBUG: Логирование ошибок длины штока
-             onRodLengthErrorChanged: {
-                 if (rodLengthError > 1.0) {  // Если ошибка больше 1мм
-                     console.warn("⚠️ Rod length error:", rodLengthError.toFixed(2), "mm (target:", pistonRodLength, "actual:", actualRodLength.toFixed(2), ")")
-                 }
-             }
-         }
-
-         // Four suspension corners with fixed rod lengths
-         OptimizedSuspensionCorner {
-             id: flCorner
-             j_arm: Qt.vector3d(-userFrameToPivot, userBeamSize, userBeamSize/2)
-             j_tail: Qt.vector3d(-userTrackWidth/2, userBeamSize + userFrameHeight, userBeamSize/2)
-             leverAngle: fl_angle
-             pistonPositionFromPython: root.userPistonPositionFL
-         }
-
-         OptimizedSuspensionCorner {
-             id: frCorner
-             j_arm: Qt.vector3d(userFrameToPivot, userBeamSize, userBeamSize/2)
-             j_tail: Qt.vector3d(userTrackWidth/2, userBeamSize + userFrameHeight, userBeamSize/2)
-             leverAngle: fr_angle
diff --git a/src/mechanics/components.py b/src/mechanics/components.py
index ddce35b8d58a63df7700914bdbe230b3ba59d461..95705115a35619d2035b2749bed336e643f74e33 100644
--- a/src/mechanics/components.py
+++ b/src/mechanics/components.py
@@ -1,161 +1,242 @@
+"""Mechanical component models used by the simulation core.
+
+The original implementation exposed a number of placeholder classes that
+returned hard coded values.  The runtime now relies on the real geometric
+description that lives in :mod:`src.pneumo.geometry` and
+``CylinderSpec``/:class:`~src.pneumo.cylinder.CylinderState`.  This module
+provides small wrappers that translate lever angles into cylinder
+displacements, compute spring and damper forces and evaluate pneumatic
+forces from the actual chamber pressures.
 """
-Mechanical components: levers, springs, dampers
-Minimal stubs for physics integration
-"""
 
-from dataclasses import dataclass
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass, field
+from typing import Tuple
 
-# TODO: Replace with real implementations
+from src.pneumo.cylinder import CylinderSpec, CylinderState
+from src.pneumo.geometry import LeverGeom, CylinderGeom
 
 
 @dataclass
 class Lever:
-    """Lever mechanism stub"""
+    """Lever kinematics based on the validated geometry definition."""
+
+    lever_geom: LeverGeom
+    cylinder_geom: CylinderGeom
+    neutral_angle: float = 0.0
+
+    def _cylinder_length(self, angle: float) -> float:
+        """Return the distance between tail and rod joint for ``angle``."""
 
-    length: float = 0.8
-    pivot_distance: float = 0.2
+        rod_x, rod_y = self.lever_geom.rod_joint_pos(angle)
+        rod_point = (0.0, rod_x, self.cylinder_geom.Z_axle + rod_y)
+        tail_point = (0.0, self.cylinder_geom.Y_tail, self.cylinder_geom.Z_axle)
+        return self.cylinder_geom.project_to_cyl_axis(tail_point, rod_point)
+
+    def joint_position(self, angle: float) -> Tuple[float, float, float]:
+        """Return the 3D coordinates of the rod joint for ``angle``."""
+
+        rod_x, rod_y = self.lever_geom.rod_joint_pos(angle)
+        return (0.0, rod_x, self.cylinder_geom.Z_axle + rod_y)
 
     def angle_to_displacement(self, angle: float) -> float:
-        """Convert lever angle to linear displacement"""
-        return self.pivot_distance * angle
+        """Convert lever rotation to cylinder axis displacement."""
+
+        current_length = self._cylinder_length(angle)
+        neutral_length = self._cylinder_length(self.neutral_angle)
+        return current_length - neutral_length
+
+    def mechanical_advantage(self, angle: float, delta: float = 1e-4) -> float:
+        """Return the instantaneous displacement/angle ratio.
+
+        The derivative is estimated with a small symmetric difference which
+        remains stable for the ranges enforced by the geometry validators.
+        """
+
+        disp_plus = self.angle_to_displacement(angle + delta)
+        disp_minus = self.angle_to_displacement(angle - delta)
+        return (disp_plus - disp_minus) / (2.0 * delta)
 
 
 @dataclass
 class Spring:
-    """One-sided spring stub"""
+    """Linear spring model with configurable preload."""
+
+    k: float = 50_000.0  # Spring constant (N/m)
+    rest_length: float = 0.0
+    preload: float = 0.0
+
+    def force(self, length: float) -> float:
+        """Return the restoring force for the current spring length."""
 
-    k: float = 50000.0  # Spring constant (N/m)
-    rest_length: float = 0.0  # Rest position
+        extension = length - self.rest_length
+        return -self.k * extension + self.preload
 
-    def force(self, position: float) -> float:
-        """Compute spring force (compression only)"""
-        compression = self.rest_length - position
-        return self.k * max(0.0, compression)
+    def potential_energy(self, length: float) -> float:
+        """Energy stored in the spring for convenience diagnostics."""
+
+        extension = length - self.rest_length
+        return 0.5 * self.k * extension * extension
 
 
 @dataclass
 class Damper:
-    """Linear damper stub"""
+    """Viscous damper resisting relative motion."""
 
-    c: float = 2000.0  # Damping coefficient (N?s/m)
-    threshold: float = 50.0  # Minimum force threshold
+    c: float = 2_000.0  # Damping coefficient (N*s/m)
+    threshold: float = 0.0
 
     def force(self, velocity: float) -> float:
-        """Compute damper force"""
-        F = self.c * velocity
-        return F if abs(F) > self.threshold else 0.0
+        """Return the damping force opposing ``velocity``."""
+
+        raw = -self.c * velocity
+        if abs(raw) < self.threshold:
+            return 0.0
+        return raw
 
 
 @dataclass
 class PneumaticCylinder:
-    """Pneumatic cylinder stub"""
+    """Convenience wrapper exposing force and volume helpers."""
+
+    spec: CylinderSpec
+    state: CylinderState | None = None
 
-    area_head: float = 0.005  # Head area (m?)
-    area_rod: float = 0.004  # Rod area (m?)
+    def __post_init__(self) -> None:  # pragma: no cover - simple guard
+        if self.state is None:
+            self.state = CylinderState(spec=self.spec)
+
+    @property
+    def geometry(self) -> CylinderGeom:
+        return self.spec.geometry
+
+    def clamp_position(self, x: float) -> float:
+        """Clamp piston displacement to the physical travel."""
+
+        half_travel = self.geometry.L_travel_max / 2.0
+        return max(-half_travel, min(half_travel, x))
+
+    def set_position(self, x: float) -> None:
+        assert self.state is not None
+        self.state.x = self.clamp_position(x)
+
+    def volumes(self) -> Tuple[float, float]:
+        """Return head/rod chamber volumes for the current position."""
+
+        assert self.state is not None
+        return self.state.vol_head(), self.state.vol_rod()
 
     def force(self, p_head: float, p_rod: float) -> float:
-        """Compute net cylinder force"""
-        return p_head * self.area_head - p_rod * self.area_rod
+        """Compute the net pneumatic force produced by the cylinder."""
+
+        geom = self.geometry
+        area_head = geom.area_head(self.spec.is_front)
+        area_rod = geom.area_rod(self.spec.is_front)
+        return p_head * area_head - p_rod * area_rod
 
 
 @dataclass
-class DetailedLever:
-    """Detailed lever mechanics"""
+class DetailedLever(Lever):
+    """Lever with inertia that can integrate applied torques."""
 
-    length: float = 0.8
-    pivot_distance: float = 0.2
-    angle: float = 0.0
+    moment_of_inertia: float = 1.0
+    angular_velocity: float = 0.0
+    applied_torque: float = 0.0
 
-    def apply_force(self, force_magnitude: float, force_angle: float):
-        """Apply a force to the lever"""
-        # TODO: Implement force application
-        pass
+    def apply_force(self, force_magnitude: float, force_angle: float) -> None:
+        """Store the torque produced by ``force_magnitude``."""
 
-    def compute_torque(self) -> float:
-        """Compute torque around the pivot"""
-        return self.angle_to_displacement(self.angle) * self.length
+        lever_arm = self.lever_geom.L_lever * math.sin(force_angle - self.neutral_angle)
+        self.applied_torque = force_magnitude * lever_arm
 
-    def angle_to_displacement(self, angle: float) -> float:
-        """Convert lever angle to linear displacement"""
-        return self.pivot_distance * angle
+    def integrate(self, dt: float) -> None:
+        """Advance the lever state using semi-implicit Euler integration."""
+
+        if dt <= 0.0:
+            return
+        angular_accel = self.applied_torque / max(self.moment_of_inertia, 1e-6)
+        self.angular_velocity += angular_accel * dt
+        self.neutral_angle += self.angular_velocity * dt
+        self.applied_torque = 0.0
+
+    def compute_torque(self) -> float:
+        return self.applied_torque
 
 
 @dataclass
-class DetailedSpring:
-    """Detailed spring mechanics"""
-
-    k: float = 50000.0  # Spring constant (N/m)
-    rest_length: float = 0.0  # Rest position
-    damping_coefficient: float = 5.0  # Critical damping coefficient
-    position: float = 0.0  # Current position
-    velocity: float = 0.0  # Current velocity
-    acceleration: float = 0.0  # Current acceleration
-
-    def apply_force(self, force: float):
-        """Apply a force to the spring-mass system"""
-        # TODO: Implement force application
-        pass
-
-    def update(self, time_step: float):
-        """Update the spring-mass system state"""
-        # TODO: Implement system dynamics
-        pass
-
-    def force(self, position: float) -> float:
-        """Compute spring force (compression only)"""
-        compression = self.rest_length - position
-        return self.k * max(0.0, compression)
+class DetailedSpring(Spring):
+    """Spring with first order dynamics and viscous damping."""
+
+    damping_coefficient: float = 0.0
+    mass: float = 1.0
+    position: float = 0.0
+    velocity: float = 0.0
+    acceleration: float = 0.0
+
+    def apply_force(self, external_force: float) -> None:
+        spring_force = super().force(self.position)
+        damping_force = -self.damping_coefficient * self.velocity
+        net_force = external_force + spring_force + damping_force
+        self.acceleration = net_force / max(self.mass, 1e-6)
+
+    def update(self, time_step: float) -> None:
+        if time_step <= 0.0:
+            return
+        self.velocity += self.acceleration * time_step
+        self.position += self.velocity * time_step
+        self.acceleration = 0.0
 
     def damping_force(self) -> float:
-        """Compute the damping force"""
         return -self.damping_coefficient * self.velocity
 
 
 @dataclass
-class DetailedDamper:
-    """Detailed damper mechanics"""
+class DetailedDamper(Damper):
+    """Damper with explicit state integration."""
 
-    c: float = 2000.0  # Damping coefficient (N?s/m)
-    threshold: float = 50.0  # Minimum force threshold
-    extension: float = 0.0  # Current extension
-    velocity: float = 0.0  # Current velocity
+    mass: float = 1.0
+    extension: float = 0.0
+    velocity: float = 0.0
+    acceleration: float = 0.0
 
-    def apply_force(self, force: float):
-        """Apply a force to the damper"""
-        # TODO: Implement force application
-        pass
+    def apply_force(self, external_force: float) -> None:
+        damping = self.force(self.velocity)
+        net_force = external_force + damping
+        self.acceleration = net_force / max(self.mass, 1e-6)
 
-    def force(self, velocity: float) -> float:
-        """Compute damper force"""
-        F = self.c * velocity
-        return F if abs(F) > self.threshold else 0.0
+    def update(self, time_step: float) -> None:
+        if time_step <= 0.0:
+            return
+        self.velocity += self.acceleration * time_step
+        self.extension += self.velocity * time_step
+        self.acceleration = 0.0
 
 
 @dataclass
-class DetailedPneumaticCylinder:
-    """Detailed pneumatic cylinder mechanics"""
-
-    area_head: float = 0.005  # Head area (m?)
-    area_rod: float = 0.004  # Rod area (m?)
-    damping_coefficient: float = 5.0  # Critical damping coefficient
-    position: float = 0.0  # Current position
-    velocity: float = 0.0  # Current velocity
-    acceleration: float = 0.0  # Current acceleration
-
-    def apply_force(self, force: float):
-        """Apply a force to the cylinder"""
-        # TODO: Implement force application
-        pass
-
-    def update(self, time_step: float):
-        """Update the cylinder state"""
-        # TODO: Implement state update
-        pass
-
-    def force(self, p_head: float, p_rod: float) -> float:
-        """Compute net cylinder force"""
-        return p_head * self.area_head - p_rod * self.area_rod
+class DetailedPneumaticCylinder(PneumaticCylinder):
+    """Pneumatic cylinder with lumped mass and viscous losses."""
+
+    damping_coefficient: float = 0.0
+    mass: float = 1.0
+    velocity: float = 0.0
+    acceleration: float = 0.0
+
+    def apply_force(self, p_head: float, p_rod: float) -> None:
+        pneumatic = self.force(p_head, p_rod)
+        damping = -self.damping_coefficient * self.velocity
+        net_force = pneumatic + damping
+        self.acceleration = net_force / max(self.mass, 1e-6)
+
+    def update(self, time_step: float) -> None:
+        if time_step <= 0.0:
+            return
+        self.velocity += self.acceleration * time_step
+        assert self.state is not None
+        new_position = self.state.x + self.velocity * time_step
+        self.set_position(new_position)
+        self.acceleration = 0.0
 
     def damping_force(self) -> float:
-        """Compute the damping force"""
         return -self.damping_coefficient * self.velocity
diff --git a/src/pneumo/network.py b/src/pneumo/network.py
index 3cfbce6304c8fd0c1fd66410795a7661e29e33f5..463fb07aad111f92565d9d4f0eb8f7b9e4cb7741 100644
--- a/src/pneumo/network.py
+++ b/src/pneumo/network.py
@@ -60,100 +60,110 @@ class GasNetwork:
 
                 total_volume += volume
 
             volumes[line_name] = total_volume
 
         return volumes
 
     def update_pressures_due_to_volume(self, thermo_mode: ThermoMode):
         """Update line pressures due to volume changes from kinematics
 
         Args:
             thermo_mode: ISOTHERMAL or ADIABATIC process
         """
         volumes = self.compute_line_volumes()
 
         for line_name, new_volume in volumes.items():
             line_state = self.lines[line_name]
 
             if thermo_mode == ThermoMode.ISOTHERMAL:
                 iso_update(line_state, new_volume, T_AMBIENT)
             elif thermo_mode == ThermoMode.ADIABATIC:
                 adiabatic_update(line_state, new_volume)
             else:
                 raise ValueError(f"Unknown thermo mode: {thermo_mode}")
 
-    def apply_valves_and_flows(self, dt: float, log: Optional[logging.Logger] = None):
+    def apply_valves_and_flows(
+        self, dt: float, log: Optional[logging.Logger] = None
+    ) -> Dict[str, Dict[str, float]]:
         """Apply valve flows for one time step
 
         Args:
             dt: Time step (s)
             log: Optional logger for diagnostics
         """
         if dt <= 0:
             raise ValueError(f"Time step must be positive: {dt}")
 
         # Process flows for each line
+        line_flows: Dict[Line, Dict[str, float]] = {
+            line_name: {"flow_atmo": 0.0, "flow_tank": 0.0}
+            for line_name in self.lines.keys()
+        }
         for line_name, line_state in self.lines.items():
             pneumo_line = self.system_ref.lines[line_name]
 
             # ATMOSPHERE -> LINE flow
             cv_atmo = pneumo_line.cv_atmo
             if cv_atmo.is_open(PA_ATM, line_state.p):
                 m_dot_atmo = mass_flow_orifice(
                     PA_ATM, T_AMBIENT, line_state.p, line_state.T, cv_atmo.d_eq
                 )
 
                 # Add mass to line
                 mass_added = m_dot_atmo * dt
                 self._add_mass_to_line(line_state, mass_added, T_AMBIENT)
+                line_flows[line_name]["flow_atmo"] = float(m_dot_atmo)
 
                 if log:
                     log.debug(
                         f"Atmo->Line {line_name.value}: +{mass_added:.6f}kg, m_dot={m_dot_atmo:.6f}kg/s"
                     )
 
             # LINE -> TANK flow
             cv_tank = pneumo_line.cv_tank
             if cv_tank.is_open(line_state.p, self.tank.p):
                 m_dot_tank = mass_flow_orifice(
                     line_state.p, line_state.T, self.tank.p, self.tank.T, cv_tank.d_eq
                 )
 
                 # Transfer mass from line to tank
                 mass_transferred = min(
                     m_dot_tank * dt, line_state.m * 0.99
                 )  # Prevent complete depletion
                 self._transfer_mass_line_to_tank(line_state, mass_transferred)
+                line_flows[line_name]["flow_tank"] = float(m_dot_tank)
 
                 if log:
                     log.debug(
                         f"Line->Tank {line_name.value}: -{mass_transferred:.6f}kg, m_dot={m_dot_tank:.6f}kg/s"
                     )
 
         # Process receiver relief valves
-        self._apply_receiver_relief_valves(dt, log)
+        relief_flows = self._apply_receiver_relief_valves(dt, log)
+
+        return {"lines": line_flows, "relief": relief_flows}
 
     def _add_mass_to_line(
         self, line_state: LineGasState, mass_added: float, T_inlet: float
     ):
         """Add mass to line with temperature mixing
 
         Args:
             line_state: Line to add mass to
             mass_added: Mass to add (kg)
             T_inlet: Temperature of incoming gas (K)
         """
         if mass_added <= 0:
             return
 
         # Temperature mixing (mass-weighted average)
         old_mass = line_state.m
         new_total_mass = old_mass + mass_added
 
         if new_total_mass > 0:
             line_state.T = (
                 old_mass * line_state.T + mass_added * T_inlet
             ) / new_total_mass
 
         line_state.m = new_total_mass
 
@@ -174,116 +184,122 @@ class GasNetwork:
 
         # Remove mass from line
         line_state.m -= mass_transferred
 
         # Add mass to tank with temperature mixing
         old_tank_mass = self.tank.m
         new_tank_mass = old_tank_mass + mass_transferred
 
         if new_tank_mass > 0:
             self.tank.T = (
                 old_tank_mass * self.tank.T + mass_transferred * line_state.T
             ) / new_tank_mass
 
         self.tank.m = new_tank_mass
 
         # Recalculate pressures
         if line_state.m > 0:
             line_state.p = p_from_mTV(line_state.m, line_state.T, line_state.V_curr)
         else:
             line_state.p = 0.0  # No mass left
 
         self.tank.p = p_from_mTV(self.tank.m, self.tank.T, self.tank.V)
 
     def _apply_receiver_relief_valves(
         self, dt: float, log: Optional[logging.Logger] = None
-    ):
+    ) -> Dict[str, float]:
         """Apply receiver relief valve flows
 
         Args:
             dt: Time step (s)
             log: Optional logger
         """
         # Get relief valves from system (we'll need to add these to the system)
         # For now, use default thresholds
 
         p_min_threshold = 1.05 * PA_ATM  # 5% above atmospheric
         p_stiff_threshold = 1.5 * PA_ATM  # 50% above atmospheric
         p_safety_threshold = 2.0 * PA_ATM  # 100% above atmospheric
 
         d_eq_min_bleed = 1.0e-3  # 1mm throttle
         d_eq_stiff_bleed = 1.0e-3  # 1mm throttle
 
         total_mass_out = 0.0
+        relief_log = {"flow_min": 0.0, "flow_stiff": 0.0, "flow_safety": 0.0}
 
         # MIN_PRESS relief (maintain minimum pressure)
         if self.tank.p > p_min_threshold:
             m_dot_min = mass_flow_orifice(
                 self.tank.p, self.tank.T, PA_ATM, T_AMBIENT, d_eq_min_bleed
             )
             mass_out_min = m_dot_min * dt
             total_mass_out += mass_out_min
+            relief_log["flow_min"] = float(m_dot_min)
 
             if log:
                 log.debug(
                     f"MIN_PRESS relief: -{mass_out_min:.6f}kg, m_dot={m_dot_min:.6f}kg/s"
                 )
 
         # STIFFNESS relief
         if self.tank.p > p_stiff_threshold:
             m_dot_stiff = mass_flow_orifice(
                 self.tank.p, self.tank.T, PA_ATM, T_AMBIENT, d_eq_stiff_bleed
             )
             mass_out_stiff = m_dot_stiff * dt
             total_mass_out += mass_out_stiff
+            relief_log["flow_stiff"] = float(m_dot_stiff)
 
             if log:
                 log.debug(
                     f"STIFFNESS relief: -{mass_out_stiff:.6f}kg, m_dot={m_dot_stiff:.6f}kg/s"
                 )
 
         # SAFETY relief (unlimited flow)
         if self.tank.p > p_safety_threshold:
             m_dot_safety = mass_flow_unlimited(self.tank.p, self.tank.T)
             mass_out_safety = m_dot_safety * dt
             total_mass_out += mass_out_safety
+            relief_log["flow_safety"] = float(m_dot_safety)
 
             if log:
                 log.debug(
                     f"SAFETY relief: -{mass_out_safety:.6f}kg, m_dot={m_dot_safety:.6f}kg/s"
                 )
 
         # Remove total mass from tank (prevent negative mass)
         if total_mass_out > 0:
             self.tank.m = max(0.0, self.tank.m - total_mass_out)
 
             # Recalculate pressure
             if self.tank.m > 0:
                 self.tank.p = p_from_mTV(self.tank.m, self.tank.T, self.tank.V)
             else:
                 self.tank.p = 0.0
 
+        return relief_log
+
     def enforce_master_isolation(self, log: Optional[logging.Logger] = None):
         """Enforce master isolation when enabled - equalize all line pressures
 
         Args:
             log: Optional logger
         """
         if not self.master_isolation_open:
             return
 
         # Calculate total mass and volume
         total_mass = sum(line.m for line in self.lines.values())
 
         volumes = self.compute_line_volumes()
         total_volume = sum(volumes.values())
 
         if total_mass <= 0 or total_volume <= 0:
             return
 
         # Calculate mass-weighted average temperature
         total_enthalpy = sum(line.m * line.T for line in self.lines.values())
         avg_temperature = total_enthalpy / total_mass if total_mass > 0 else T_AMBIENT
 
         # Calculate equalized pressure
         equalized_pressure = p_from_mTV(total_mass, avg_temperature, total_volume)
 
diff --git a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py
index 5c5cd8a5cbf74de1fb9c45e10b05d2d192f36355..5f066ddd268de4084145925a7e93bf5285ab9e43 100644
--- a/src/runtime/sim_loop.py
+++ b/src/runtime/sim_loop.py
@@ -1,113 +1,157 @@
 """
 Physics simulation loop with fixed timestep
 Runs in dedicated QThread with QTimer for precise timing
 """
 
+import math
 import time
 import logging
 from typing import Optional, Dict, Any
 import numpy as np
 
 from PySide6.QtCore import QObject, QTimer, Signal, Slot, Qt
 from PySide6.QtCore import QThread
 
 from .state import (
     StateSnapshot,
     StateBus,
     FrameState,
     WheelState,
     LineState,
     TankState,
     SystemAggregates,
 )
 from .sync import (
     LatestOnlyQueue,
     PerformanceMetrics,
     TimingAccumulator,
     ThreadSafeCounter,
 )
 
 # Измененные импорты на абсолютные пути
 from src.physics.odes import RigidBody3DOF, create_initial_conditions
 from src.physics.integrator import (
     step_dynamics,
     create_default_rigid_body,
 )
 from src.pneumo.enums import (
     Wheel,
     Line,
     ThermoMode,
+    ReceiverVolumeMode,
+    Port,
 )
-from src.pneumo.receiver import ReceiverState
+from src.pneumo.cylinder import CylinderSpec, CylinderState
+from src.pneumo.receiver import ReceiverSpec, ReceiverState
 from src.pneumo.system import create_standard_diagonal_system
 from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
 from src.pneumo.network import GasNetwork
 from src.road.engine import RoadInput
 from src.road.scenarios import get_preset_by_name
+from src.road.types import RoadConfig
 
 # Settings manager (используем абсолютный импорт, т.к. общий модуль)
 from src.common.settings_manager import get_settings_manager
+from src.common.units import PA_ATM, T_AMBIENT
+from src.app.config_defaults import create_default_system_configuration
+from src.mechanics.components import Lever, PneumaticCylinder
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
         self.max_frame_time: float = 0.05
 
         # Simulation state
         self.is_running = False
         self.is_configured = False
         self.simulation_time = 0.0
         self.step_counter = 0
 
         # Physics objects (will be initialized in configure)
         self.rigid_body: Optional[RigidBody3DOF] = None
         self.road_input: Optional[Any] = None  # Changed type hint
         self.pneumatic_system: Optional[Any] = None
         self.gas_network: Optional[Any] = None
 
+        # Geometry and component models
+        self.frame_geom = None
+        self.lever_geom = None
+        self.cylinder_geom = None
+        self._lever_models: Dict[Wheel, Lever] = {}
+        self._cylinder_wrappers: Dict[Wheel, PneumaticCylinder] = {}
+        self._cylinder_volume_limits: Dict[Wheel, Dict[str, float]] = {}
+        self._lever_angle_limits: Dict[Wheel, tuple[float, float]] = {}
+        self._wheel_line_map: Dict[Wheel, Dict[Port, Line]] = {}
+        self._line_volume_limits: Dict[Line, tuple[float, float]] = {}
+        self._line_pressure_limits: tuple[float, float] = (0.0, 0.0)
+        self._tank_pressure_limits: tuple[float, float] = (0.0, 0.0)
+        self._previous_piston_positions: Dict[Wheel, float] = {}
+        self._piston_velocities: Dict[Wheel, float] = {}
+        self._current_lever_angles: Dict[Wheel, float] = {
+            wheel: 0.0 for wheel in Wheel
+        }
+        self._wheel_to_road_key: Dict[Wheel, str] = {
+            Wheel.LP: "LF",
+            Wheel.PP: "RF",
+            Wheel.LZ: "LR",
+            Wheel.PZ: "RR",
+        }
+        self._current_road_inputs: Dict[str, float] = {
+            key: 0.0 for key in self._wheel_to_road_key.values()
+        }
+        self._last_line_flows: Dict[Line, Dict[str, float]] = {
+            line: {"flow_atmo": 0.0, "flow_tank": 0.0}
+            for line in (Line.A1, Line.B1, Line.A2, Line.B2)
+        }
+        self._last_relief_flows = {
+            "flow_min": 0.0,
+            "flow_stiff": 0.0,
+            "flow_safety": 0.0,
+        }
+
         # Current physics state
         self.physics_state: np.ndarray = np.zeros(6)  # [Y, φz, θx, dY, dφz, dθx]
 
         # Simulation modes (overridden by persisted settings)
         self.thermo_mode = ThermoMode.ISOTHERMAL
         self.master_isolation_open = False
 
         # Receiver parameters and limits (loaded from settings)
         self.receiver_volume: float = 0.0
         self.receiver_volume_mode: str = ""
         self._volume_limits: tuple[float, float] = (0.0, 0.0)
 
         # Threading objects (created in target thread)
         self.physics_timer: Optional[QTimer] = None
 
         # Performance monitoring
         self.performance = PerformanceMetrics()
         self.timing_accumulator: Optional[TimingAccumulator] = None
         self.step_time_samples = []
 
         # Thread safety
         self.error_counter = ThreadSafeCounter()
 
         # Load persisted configuration
         self._load_initial_settings()
@@ -247,101 +291,278 @@ class PhysicsWorker(QObject):
         ):
             self.vsync_render_hz = float(vsync_render_hz)
         if isinstance(max_steps_per_frame, (int, float)) and not isinstance(
             max_steps_per_frame, bool
         ):
             self.max_steps_per_frame = max(1, int(round(max_steps_per_frame)))
         if isinstance(max_frame_time, (int, float)) and not isinstance(
             max_frame_time, bool
         ):
             self.max_frame_time = float(max_frame_time)
 
         # Update timing accumulator
         self._apply_timing_configuration()
 
         # Create default physics objects
         self._initialize_physics_objects()
 
         self.is_configured = True
         self.logger.info(
             f"Physics configured: dt={self.dt_physics*1000:.3f}ms, render={self.vsync_render_hz:.1f}Hz"
         )
 
     def _initialize_physics_objects(self):
         """Initialize physics simulation objects"""
         try:
-            # Create 3-DOF rigid body
+            # Create 3-DOF rigid body and initial conditions
             self.rigid_body = create_default_rigid_body()
-
-            # Initialize physics state (at rest)
             self.physics_state = create_initial_conditions()
 
-            # TODO: Initialize pneumatic system and gas network
-            # For now, create minimal stubs
-            self.pneumatic_system = None  # Will be set up later
-            self.gas_network = None
+            # Build pneumatic system from validated defaults
+            defaults = create_default_system_configuration()
+            self.frame_geom = defaults["frame_geom"]
+            self.lever_geom = defaults["lever_geom"]
+            self.cylinder_geom = defaults["cylinder_geom"]
+            cylinder_specs = defaults["cylinder_specs"]
+            line_configs = defaults["line_configs"]
+
+            receiver_mode = (
+                ReceiverVolumeMode.ADIABATIC_RECALC
+                if self.receiver_volume_mode.upper() == "GEOMETRIC"
+                else ReceiverVolumeMode.NO_RECALC
+            )
 
-            # TODO: Initialize road input
-            # For now, create minimal stub
-            self.road_input = None
+            receiver_spec = ReceiverSpec(
+                V_min=self._volume_limits[0], V_max=self._volume_limits[1]
+            )
+            receiver_state = ReceiverState(
+                spec=receiver_spec,
+                V=self.receiver_volume,
+                p=PA_ATM,
+                T=T_AMBIENT,
+                mode=receiver_mode,
+            )
 
-            # NEW: Initialize road input with default scenario
-            road_scenario = "default_scenario"  # Заменить на нужный пресет
-            road_config = get_preset_by_name(road_scenario)
-            if road_config:
-                self.road_input = RoadInput(config=road_config)
-                self.logger.info(
-                    f"Road input initialized with scenario: {road_scenario}"
-                )
-            else:
-                self.logger.warning(f"Road scenario not found: {road_scenario}")
-                self.road_input = None  # Использовать заглушку
+            self.pneumatic_system = create_standard_diagonal_system(
+                cylinder_specs=cylinder_specs,
+                line_configs=line_configs,
+                receiver=receiver_state,
+                master_isolation_open=self.master_isolation_open,
+            )
 
-            # NEW: Initialize pneumatic system with standard configuration
-            try:
-                self.pneumatic_system = create_standard_diagonal_system()
-                self.logger.info(
-                    "Pneumatic system initialized with standard configuration"
+            # Wrap cylinders for convenience calculations
+            self._cylinder_wrappers = {
+                wheel: PneumaticCylinder(
+                    spec=spec, state=self.pneumatic_system.cylinders[wheel]
+                )
+                for wheel, spec in cylinder_specs.items()
+            }
+
+            # Pre-compute cylinder and line volume limits
+            self._compute_volume_and_angle_limits()
+
+            # Initialise gas network with current volumes
+            line_states = {}
+            line_volumes = self.pneumatic_system.get_line_volumes()
+
+            for line, volume_info in line_volumes.items():
+                total_volume = volume_info["total_volume"]
+                line_states[line] = create_line_gas_state(
+                    line,
+                    p_initial=PA_ATM,
+                    T_initial=T_AMBIENT,
+                    V_initial=total_volume,
                 )
-            except Exception as e:
-                self.logger.warning(f"Failed to create standard pneumatic system: {e}")
-                self.pneumatic_system = None  # Использовать заглушку
 
-            # NEW: Initialize gas network with default parameters
-            try:
-                self.gas_network = GasNetwork()
-                self.logger.info("Gas network initialized with default parameters")
-            except Exception as e:
-                self.logger.warning(f"Failed to create gas network: {e}")
-                self.gas_network = None  # Использовать заглушку
+            tank_state = create_tank_gas_state(
+                V_initial=self.receiver_volume,
+                p_initial=PA_ATM,
+                T_initial=T_AMBIENT,
+                mode=receiver_mode,
+            )
+
+            self.gas_network = GasNetwork(
+                lines=line_states,
+                tank=tank_state,
+                system_ref=self.pneumatic_system,
+                master_isolation_open=self.master_isolation_open,
+            )
+
+            self._initialize_pressure_limits()
+
+            # Configure road input from preset
+            self._initialize_road_input()
 
             self.logger.info("Physics objects initialized successfully")
 
         except Exception as e:
             self.logger.error(f"Failed to initialize physics objects: {e}")
             raise
 
+    def _cylinder_position_from_angle(self, spec: CylinderSpec, angle: float) -> float:
+        temp_state = CylinderState(spec=spec)
+        temp_state.update_from_lever_angle(angle)
+        return temp_state.x
+
+    def _solve_angle_for_position(self, spec: CylinderSpec, target: float) -> float:
+        sign = 1.0 if target >= 0 else -1.0
+        lower = 0.0 if sign > 0 else -math.radians(85.0)
+        upper = math.radians(85.0) if sign > 0 else 0.0
+        for _ in range(10):
+            pos = self._cylinder_position_from_angle(spec, upper)
+            if (sign > 0 and pos < target) or (sign < 0 and pos > target):
+                upper += sign * math.radians(5.0)
+            else:
+                break
+
+        for _ in range(50):
+            mid = 0.5 * (lower + upper)
+            pos = self._cylinder_position_from_angle(spec, mid)
+            if abs(pos - target) < 1e-6:
+                return mid
+            if (pos - target) * sign > 0:
+                upper = mid
+            else:
+                lower = mid
+        return 0.5 * (lower + upper)
+
+    def _compute_volume_and_angle_limits(self) -> None:
+        if not self.pneumatic_system:
+            return
+
+        half_travel = self.cylinder_geom.L_travel_max / 2.0
+        self._lever_models = {
+            wheel: Lever(self.lever_geom, self.cylinder_geom)
+            for wheel in Wheel
+        }
+
+        self._cylinder_volume_limits = {}
+        self._lever_angle_limits = {}
+        self._wheel_line_map = {wheel: {} for wheel in Wheel}
+
+        for line_name, pneumo_line in self.pneumatic_system.lines.items():
+            for wheel, port in pneumo_line.endpoints:
+                self._wheel_line_map[wheel][port] = line_name
+
+        for wheel, wrapper in self._cylinder_wrappers.items():
+            spec = wrapper.spec
+            geom = spec.geometry
+            is_front = spec.is_front
+
+            head_candidates = [
+                wrapper.state.vol_head(-half_travel),
+                wrapper.state.vol_head(half_travel),
+            ]
+            rod_candidates = [
+                wrapper.state.vol_rod(-half_travel),
+                wrapper.state.vol_rod(half_travel),
+            ]
+
+            head_min = max(geom.min_volume_head(is_front), min(head_candidates))
+            head_max = max(head_candidates)
+            rod_min = max(geom.min_volume_rod(is_front), min(rod_candidates))
+            rod_max = max(rod_candidates)
+
+            self._cylinder_volume_limits[wheel] = {
+                "head_min": head_min,
+                "head_max": head_max,
+                "rod_min": rod_min,
+                "rod_max": rod_max,
+            }
+
+            neg_angle = self._solve_angle_for_position(spec, -half_travel)
+            pos_angle = self._solve_angle_for_position(spec, half_travel)
+            self._lever_angle_limits[wheel] = (neg_angle, pos_angle)
+            self._previous_piston_positions[wheel] = 0.0
+            self._piston_velocities[wheel] = 0.0
+
+        self._line_volume_limits = {}
+        for line_name, pneumo_line in self.pneumatic_system.lines.items():
+            min_volume = 0.0
+            max_volume = 0.0
+            for wheel, port in pneumo_line.endpoints:
+                limits = self._cylinder_volume_limits[wheel]
+                if port == Port.HEAD:
+                    min_volume += limits["head_min"]
+                    max_volume += limits["head_max"]
+                else:
+                    min_volume += limits["rod_min"]
+                    max_volume += limits["rod_max"]
+            self._line_volume_limits[pneumo_line.name] = (min_volume, max_volume)
+
+    def _initialize_pressure_limits(self) -> None:
+        min_pressure = float(
+            self.settings_manager.get("pneumatic.relief_min_pressure", PA_ATM)
+        )
+        safety_pressure = float(
+            self.settings_manager.get(
+                "pneumatic.relief_safety_pressure", 5.0 * PA_ATM
+            )
+        )
+        min_pressure = max(1e4, min_pressure)
+        safety_pressure = max(min_pressure * 1.5, safety_pressure)
+        self._line_pressure_limits = (min_pressure * 0.5, safety_pressure * 1.1)
+        self._tank_pressure_limits = (min_pressure * 0.9, safety_pressure * 1.05)
+
+    def _initialize_road_input(self) -> None:
+        preset_name = self.settings_manager.get("modes.mode_preset", "sine_sweep")
+        if not isinstance(preset_name, str) or not preset_name:
+            preset_name = "sine_sweep"
+        preset = get_preset_by_name(preset_name)
+        if preset is None:
+            self.logger.warning(
+                "Unknown road preset '%s', falling back to sine_sweep", preset_name
+            )
+            preset = get_preset_by_name("sine_sweep")
+
+        if preset is None:
+            self.logger.error("Failed to resolve road preset for simulation")
+            self.road_input = None
+            return
+
+        track_value = self.settings_manager.get("geometry.track", 1.6)
+        try:
+            track = float(track_value)
+        except (TypeError, ValueError):
+            track = 1.6
+
+        road_config = RoadConfig(
+            source=preset.source_kind,
+            preset=preset,
+            wheelbase=getattr(self.frame_geom, "L_wb", 3.2),
+            track=track,
+        )
+
+        self.road_input = RoadInput()
+        try:
+            self.road_input.configure(road_config, system=self.pneumatic_system)
+            self.road_input.prime()
+            self.logger.info("Road input initialized with preset '%s'", preset.name)
+        except Exception as exc:
+            self.logger.warning(f"Failed to configure road input: {exc}")
+            self.road_input = None
+
     @Slot()
     def start_simulation(self):
         """Start physics simulation (called from UI thread)"""
         if not self.is_configured:
             self.error_occurred.emit("Physics worker not configured")
             return
 
         if self.is_running:
             self.logger.warning("Simulation already running")
             return
 
         # Create timer in this thread (will be moved to physics thread)
         if self.physics_timer is None:
             self.physics_timer = QTimer()
             self.physics_timer.timeout.connect(self._physics_step)
             self.physics_timer.setSingleShot(False)
 
         # Start timer with high precision
         timer_interval_ms = max(1, int(self.dt_physics * 1000))  # At least 1ms
         self.physics_timer.start(timer_interval_ms)
 
         self.is_running = True
         self.timing_accumulator.reset()
 
         self.logger.info(
@@ -456,55 +677,74 @@ class PhysicsWorker(QObject):
 
         self.logger.info(f"Thermo mode set to: {mode}")
 
     @Slot(bool)
     def set_master_isolation(self, open: bool):
         """Set master isolation valve state"""
         self.master_isolation_open = open
         self.logger.info(f"Master isolation: {'OPEN' if open else 'CLOSED'}")
 
     @Slot(float, str)
     def set_receiver_volume(self, volume: float, mode: str):
         """Set receiver volume and recalculation mode
 
         Args:
             volume: New receiver volume in m?
             mode: Recalculation mode ('NO_RECALC' or 'ADIABATIC_RECALC')
         """
         if volume <= 0 or volume > 1.0:  # Reasonable limits (0-1000L)
             self.error_occurred.emit(f"Invalid receiver volume: {volume} m?")
             return
 
         # Store volume and mode for gas network updates
         self.receiver_volume = volume
         self.receiver_volume_mode = mode
 
-        # TODO: Update actual ReceiverState when gas network is integrated
-        # For now, just log the change
-        self.logger.info(f"Receiver volume set: {volume:.3f}m? (mode: {mode})")
+        self.logger.info(f"Receiver volume set: {volume:.3f}m³ (mode: {mode})")
+
+        recalculation_mode = mode.upper()
+        receiver_mode = (
+            ReceiverVolumeMode.ADIABATIC_RECALC
+            if recalculation_mode == "GEOMETRIC"
+            else ReceiverVolumeMode.NO_RECALC
+        )
+
+        if self.pneumatic_system:
+            try:
+                receiver = self.pneumatic_system.receiver
+                receiver.mode = receiver_mode
+                receiver.apply_instant_volume_change(volume)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update receiver state: {exc}")
 
-        print(f"?? PhysicsWorker: Receiver volume={volume*1000:.1f}L, mode={mode}")
+        if self.gas_network:
+            try:
+                self.gas_network.tank.V = volume
+                self.gas_network.tank.V_prev = volume
+                self.gas_network.tank.update_ideal_gas()
+            except Exception as exc:
+                self.logger.warning(f"Failed to update tank volume: {exc}")
 
     @Slot(float)
     def set_physics_dt(self, dt: float):
         """Change physics timestep"""
         if dt <= 0 or dt > 0.1:  # Reasonable limits
             self.error_occurred.emit(f"Invalid physics dt: {dt}")
             return
 
         old_dt = self.dt_physics
         self.dt_physics = dt
         self.timing_accumulator = TimingAccumulator(dt)
         self.performance.target_dt = dt
 
         # Restart timer if running
         if self.is_running and self.physics_timer:
             self.physics_timer.stop()
             timer_interval_ms = max(1, int(dt * 1000))
             self.physics_timer.start(timer_interval_ms)
 
         self.logger.info(f"Physics dt changed: {old_dt*1000:.3f}ms ? {dt*1000:.3f}ms")
 
     @Slot()
     def _physics_step(self):
         """Single physics simulation step (called by QTimer)"""
         if not self.is_running:
@@ -523,190 +763,258 @@ class PhysicsWorker(QObject):
             step_end_time = time.perf_counter()
             step_time = step_end_time - step_start_time
             self.performance.update_step_time(step_time)
 
             # Emit performance update periodically
             if self.step_counter % 100 == 0:  # Every 100 steps
                 self.performance_update.emit(self.performance.get_summary())
 
             # Create and emit state snapshot
             snapshot = self._create_state_snapshot()
             if snapshot and snapshot.validate():
                 self.state_ready.emit(snapshot)
             else:
                 self.error_counter.increment()
                 if self.error_counter.get() > 10:  # Too many invalid states
                     self.error_occurred.emit("Too many invalid state snapshots")
                     self.stop_simulation()
 
         except Exception as e:
             self.logger.error(f"Physics step failed: {e}")
             self.error_occurred.emit(f"Physics step error: {str(e)}")
             self.stop_simulation()
 
     def _execute_physics_step(self):
         """Execute single physics timestep"""
-        # 1. Get road inputs
         road_inputs = self._get_road_inputs()
+        self._current_road_inputs.update(road_inputs)
 
-        # 2. Update geometry/kinematics
-        if self.rigid_body:
+        if self.pneumatic_system:
             try:
-                # Update lever angles and piston positions from road inputs
-                if self.pneumatic_system:
-                    for wheel, input_value in road_inputs.items():
-                        if wheel in {Wheel.LP.value, Wheel.PP.value}:  # Левые колеса
-                            cylinder = self.pneumatic_system.left_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-                        elif wheel in {Wheel.LZ.value, Wheel.PZ.value}:  # Правые колеса
-                            cylinder = self.pneumatic_system.right_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-            except Exception as e:
-                self.logger.warning(f"Failed to update kinematics: {e}")
+                for wheel, road_key in self._wheel_to_road_key.items():
+                    excitation = self._current_road_inputs.get(road_key, 0.0)
+                    min_angle, max_angle = self._lever_angle_limits.get(
+                        wheel, (-math.pi / 2.0, math.pi / 2.0)
+                    )
+                    lever_length = max(self.lever_geom.L_lever, 1e-6)
+                    target_angle = math.atan2(excitation, lever_length)
+                    target_angle = max(min_angle, min(max_angle, target_angle))
+                    self._current_lever_angles[wheel] = target_angle
+
+                    cylinder_state = self.pneumatic_system.cylinders[wheel]
+                    previous = self._previous_piston_positions.get(
+                        wheel, cylinder_state.x
+                    )
+                    cylinder_state.update_from_lever_angle(target_angle)
+                    new_position = cylinder_state.x
+                    self._cylinder_wrappers[wheel].state = cylinder_state
+                    self._piston_velocities[wheel] = (
+                        (new_position - previous) / self.dt_physics
+                        if self.dt_physics > 0
+                        else 0.0
+                    )
+                    self._previous_piston_positions[wheel] = new_position
+            except Exception as exc:
+                self.logger.warning(f"Failed to update kinematics: {exc}")
 
-        # 3. Update gas system
         if self.gas_network:
             try:
-                # Получаем текущее состояние газа в трубопроводах и резервуарах
-                line_gas_states = create_line_gas_state(self.gas_network)
-                tank_gas_states = create_tank_gas_state(self.gas_network)
-
-                # Обновляем состояния резервуаров в системе
-                for state in tank_gas_states:
-                    if state.receiver_id == "default_receiver":
-                        # Применяем новое состояние газа к резервуару
-                        receiver_state = ReceiverState(
-                            pressure=state.pressure,
-                            temperature=state.temperature,
-                            volume=self.receiver_volume,
-                        )
-                        self.gas_network.update_receiver_state(receiver_state)
-
-            except Exception as e:
-                self.logger.warning(f"Failed to update gas network: {e}")
+                self.gas_network.master_isolation_open = self.master_isolation_open
+                self.gas_network.update_pressures_due_to_volume(self.thermo_mode)
+                flow_log = self.gas_network.apply_valves_and_flows(
+                    self.dt_physics, log=None
+                )
+                if isinstance(flow_log, dict):
+                    self._last_line_flows = flow_log.get("lines", self._last_line_flows)
+                    self._last_relief_flows = flow_log.get(
+                        "relief", self._last_relief_flows
+                    )
+                if not self.master_isolation_open:
+                    self.gas_network.enforce_master_isolation(self.logger)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update gas network: {exc}")
 
-        # 4. Integrate 3-DOF dynamics
         if self.rigid_body:
             try:
-                # Use placeholder system/gas for now
                 result = step_dynamics(
                     y0=self.physics_state,
                     t0=self.simulation_time,
                     dt=self.dt_physics,
                     params=self.rigid_body,
                     system=self.pneumatic_system,
                     gas=self.gas_network,
                     method="Radau",
                 )
 
                 if result.success:
                     self.physics_state = result.y_final
                 else:
                     self.performance.integration_failures += 1
-                    self.logger.warning(f"Integration failed: {result.message}")
+                    message = result.message or "Integrator reported failure"
+                    self.logger.error(f"Integration failed: {message}")
+                    self.error_occurred.emit(f"Integration failure: {message}")
+                    self.stop_simulation()
+                    return
 
-            except Exception as e:
+            except Exception as exc:
                 self.performance.integration_failures += 1
-                self.logger.error(f"Integration error: {e}")
+                self.logger.error(f"Integration error: {exc}")
+                self.error_occurred.emit(f"Integration error: {exc}")
+                self.stop_simulation()
+                return
 
-        # Update simulation time and step counter
         self.simulation_time += self.dt_physics
         self.step_counter += 1
 
     def _get_road_inputs(self) -> Dict[str, float]:
         """Get road excitation for all wheels"""
         if self.road_input:
             try:
                 return self.road_input.get_wheel_excitation(self.simulation_time)
             except Exception as e:
                 self.logger.warning(f"Road input error: {e}")
 
         # Return zero excitation as fallback
-        return {"LP": 0.0, "PP": 0.0, "LZ": 0.0, "PZ": 0.0}
+        return {"LF": 0.0, "RF": 0.0, "LR": 0.0, "RR": 0.0}
 
     def _create_state_snapshot(self) -> Optional[StateSnapshot]:
         """Create current state snapshot"""
         try:
             snapshot = StateSnapshot()
 
             # Basic timing info
             snapshot.simulation_time = self.simulation_time
             snapshot.dt_physics = self.dt_physics
             snapshot.step_number = self.step_counter
 
             # Frame state from physics integration
             if len(self.physics_state) >= 6:
                 Y, phi_z, theta_x, dY, dphi_z, dtheta_x = self.physics_state
 
                 snapshot.frame = FrameState(
                     heave=float(Y),
                     roll=float(phi_z),
                     pitch=float(theta_x),
                     heave_rate=float(dY),
                     roll_rate=float(dphi_z),
                     pitch_rate=float(dtheta_x),
                 )
 
-            # Road excitations
-            road_excitations = self._get_road_inputs()
-
             # Wheel states
-            for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
-                wheel_state = WheelState(wheel=wheel)
-
-                # Add road excitation
-                wheel_key = wheel.value  # LP, PP, LZ, PZ
-                if wheel_key in road_excitations:
-                    wheel_state.road_excitation = road_excitations[wheel_key]
-
-                # TODO: Add actual wheel state from pneumatic system
+            if self.pneumatic_system and self.gas_network:
+                for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
+                    wheel_state = snapshot.wheels[wheel]
+                    cylinder_state = self.pneumatic_system.cylinders[wheel]
+                    wrapper = self._cylinder_wrappers.get(wheel)
+                    lever_angle = self._current_lever_angles.get(wheel, 0.0)
+                    wheel_state.lever_angle = lever_angle
+                    wheel_state.lever_angle_min, wheel_state.lever_angle_max = (
+                        self._lever_angle_limits.get(wheel, (None, None))
+                    )
+                    wheel_state.piston_position = float(cylinder_state.x)
+                    wheel_state.piston_velocity = float(
+                        self._piston_velocities.get(wheel, 0.0)
+                    )
+                    wheel_state.road_excitation = self._current_road_inputs.get(
+                        self._wheel_to_road_key[wheel], 0.0
+                    )
 
-                snapshot.wheels[wheel] = wheel_state
+                    if wrapper is not None:
+                        head_volume, rod_volume = wrapper.volumes()
+                        volume_limits = self._cylinder_volume_limits.get(wheel, {})
+                        wheel_state.vol_head = float(head_volume)
+                        wheel_state.vol_rod = float(rod_volume)
+                        wheel_state.vol_head_min = volume_limits.get("head_min", 0.0)
+                        wheel_state.vol_head_max = volume_limits.get("head_max", 0.0)
+                        wheel_state.vol_rod_min = volume_limits.get("rod_min", 0.0)
+                        wheel_state.vol_rod_max = volume_limits.get("rod_max", 0.0)
+
+                        head_line = self._wheel_line_map[wheel][Port.HEAD]
+                        rod_line = self._wheel_line_map[wheel][Port.ROD]
+                        head_state = self.gas_network.lines[head_line]
+                        rod_state = self.gas_network.lines[rod_line]
+                        wheel_state.force_pneumatic = wrapper.force(
+                            head_state.p, rod_state.p
+                        )
 
-            # Line states (placeholder)
-            for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
-                line_state = LineState(line=line)
-                # TODO: Get actual line state from gas network
-                snapshot.lines[line] = line_state
+                    joint_pos = self._lever_models[wheel].joint_position(lever_angle)
+                    wheel_state.joint_x = joint_pos[0]
+                    wheel_state.joint_y = joint_pos[1]
+                    wheel_state.joint_z = joint_pos[2]
+
+            # Line states
+            if self.gas_network:
+                for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
+                    gas_state = self.gas_network.lines[line]
+                    min_vol, max_vol = self._line_volume_limits.get(line, (0.0, 0.0))
+                    flows = self._last_line_flows.get(
+                        line, {"flow_atmo": 0.0, "flow_tank": 0.0}
+                    )
+                    snapshot.lines[line] = LineState(
+                        line=line,
+                        pressure=float(gas_state.p),
+                        temperature=float(gas_state.T),
+                        mass=float(gas_state.m),
+                        volume=float(gas_state.V_curr),
+                        pressure_min=self._line_pressure_limits[0],
+                        pressure_max=self._line_pressure_limits[1],
+                        volume_min=min_vol,
+                        volume_max=max_vol,
+                        flow_atmo=float(flows.get("flow_atmo", 0.0)),
+                        flow_tank=float(flows.get("flow_tank", 0.0)),
+                    )
 
-            # Tank state (placeholder)
-            snapshot.tank = TankState()
+            # Tank state
+            if self.gas_network:
+                tank = self.gas_network.tank
+                snapshot.tank = TankState(
+                    pressure=float(tank.p),
+                    temperature=float(tank.T),
+                    mass=float(tank.m),
+                    volume=float(tank.V),
+                    pressure_min=self._tank_pressure_limits[0],
+                    pressure_max=self._tank_pressure_limits[1],
+                    volume_min=self._volume_limits[0],
+                    volume_max=self._volume_limits[1],
+                    flow_min=float(self._last_relief_flows.get("flow_min", 0.0)),
+                    flow_stiff=float(self._last_relief_flows.get("flow_stiff", 0.0)),
+                    flow_safety=float(self._last_relief_flows.get("flow_safety", 0.0)),
+                )
+                snapshot.tank.relief_min_open = snapshot.tank.flow_min > 0.0
+                snapshot.tank.relief_stiff_open = snapshot.tank.flow_stiff > 0.0
+                snapshot.tank.relief_safety_open = snapshot.tank.flow_safety > 0.0
 
-            # NEW: Update tank volume from receiver settings
-            snapshot.tank.volume = self.receiver_volume
+            total_in = sum(flow.get("flow_atmo", 0.0) for flow in self._last_line_flows.values())
+            total_out = sum(flow.get("flow_tank", 0.0) for flow in self._last_line_flows.values())
 
-            # System aggregates
             snapshot.aggregates = SystemAggregates(
                 physics_step_time=self.performance.avg_step_time,
                 integration_steps=self.step_counter,
                 integration_failures=self.performance.integration_failures,
+                total_flow_in=float(total_in),
+                total_flow_out=float(total_out),
+                net_flow=float(total_in - total_out),
             )
 
             # Configuration
             snapshot.master_isolation_open = self.master_isolation_open
             snapshot.thermo_mode = (
                 self.thermo_mode.name
                 if hasattr(self.thermo_mode, "name")
                 else str(self.thermo_mode)
             )
 
             return snapshot
 
         except Exception as e:
             self.logger.error(f"Failed to create state snapshot: {e}")
             return None
 
 
 class SimulationManager(QObject):
     """High-level simulation manager
 
     Manages PhysicsWorker in separate thread and provides
     unified interface for UI interaction.
     """
 
     def __init__(self, parent=None):
diff --git a/src/runtime/state.py b/src/runtime/state.py
index fd70559dc4d52c5df62d4695167da0cf6f944c1f..eb9300e7179288db141daa767b3af64be5d6ca22 100644
--- a/src/runtime/state.py
+++ b/src/runtime/state.py
@@ -1,94 +1,109 @@
 """
 Runtime state management and signal bus
 Provides snapshot-based state sharing between physics and UI threads
 """
 
 import time
 from dataclasses import dataclass, field
-from typing import Dict
+from typing import Dict, Optional
 import numpy as np
 from PySide6.QtCore import QObject, Signal, Qt
 
 # Updated imports to use absolute paths
 from src.pneumo.enums import Line, Wheel
 
 
 @dataclass
 class WheelState:
     """State of a single wheel/suspension point"""
 
     wheel: Wheel
     lever_angle: float = 0.0  # Lever angle (rad)
     piston_position: float = 0.0  # Piston position (m)
     piston_velocity: float = 0.0  # Piston velocity (m/s)
 
     # Cylinder volumes
     vol_head: float = 0.0  # Head side volume (m3)
     vol_rod: float = 0.0  # Rod side volume (m3)
+    vol_head_min: float = 0.0
+    vol_head_max: float = 0.0
+    vol_rod_min: float = 0.0
+    vol_rod_max: float = 0.0
+    lever_angle_min: Optional[float] = None
+    lever_angle_max: Optional[float] = None
 
     # Joint coordinates
     joint_x: float = 0.0  # Joint X coordinate (m)
     joint_y: float = 0.0  # Joint Y coordinate (m)
     joint_z: float = 0.0  # Joint Z coordinate (m)
 
     # Forces
     force_pneumatic: float = 0.0  # Net pneumatic force (N)
     force_spring: float = 0.0  # Spring force (N)
     force_damper: float = 0.0  # Damper force (N)
 
     # Road input
     road_excitation: float = 0.0  # Road input (m)
 
 
 @dataclass
 class LineState:
     """State of a pneumatic line"""
 
     line: Line
 
-    # Gas state (TEMPORARY: different initial pressures for visibility)
-    pressure: float = 150000.0  # Pressure (Pa) -1.5 bar for lines
-    temperature: float = 293.15  # Temperature (K)
+    pressure: float = 0.0  # Pressure (Pa)
+    temperature: float = 0.0  # Temperature (K)
     mass: float = 0.0  # Gas mass (kg)
     volume: float = 0.0  # Total volume (m3)
+    pressure_min: Optional[float] = None
+    pressure_max: Optional[float] = None
+    volume_min: Optional[float] = None
+    volume_max: Optional[float] = None
+    temperature_min: Optional[float] = None
+    temperature_max: Optional[float] = None
 
     # Valve states and flows
     cv_atmo_open: bool = False  # Atmosphere check valve open
     cv_tank_open: bool = False  # Tank check valve open
     flow_atmo: float = 0.0  # Flow from atmosphere (kg/s)
     flow_tank: float = 0.0  # Flow to tank (kg/s)
 
 
 @dataclass
 class TankState:
     """State of receiver tank"""
 
-    pressure: float = 200000.0  # Pressure (Pa) -2.0 bar for tank
-    temperature: float = 293.15  # Temperature (K)
+    pressure: float = 0.0  # Pressure (Pa)
+    temperature: float = 0.0  # Temperature (K)
     mass: float = 0.0  # Gas mass (kg)
-    volume: float = 0.0005  # Volume (m3)
+    volume: float = 0.0  # Volume (m3)
+    pressure_min: Optional[float] = None
+    pressure_max: Optional[float] = None
+    volume_min: Optional[float] = None
+    volume_max: Optional[float] = None
 
     # Relief valve states
     relief_min_open: bool = False  # Min pressure relief open
     relief_stiff_open: bool = False  # Stiffness relief open
     relief_safety_open: bool = False  # Safety relief open
 
     flow_min: float = 0.0  # Min relief flow (kg/s)
     flow_stiff: float = 0.0  # Stiffness relief flow (kg/s)
     flow_safety: float = 0.0  # Safety relief flow (kg/s)
 
 
 @dataclass
 class FrameState:
     """State of vehicle frame (3-DOF rigid body)"""
 
     # Position (Y-down coordinate system)
     heave: float = 0.0  # Vertical position (m, positive down)
     roll: float = 0.0  # Roll angle (rad, positive = right down)
     pitch: float = 0.0  # Pitch angle (rad, positive = nose down)
 
     # Velocity
     heave_rate: float = 0.0  # Vertical velocity (m/s)
     roll_rate: float = 0.0  # Roll rate (rad/s)
     pitch_rate: float = 0.0  # Pitch rate (rad/s)
 
@@ -218,59 +233,159 @@ class StateSnapshot:
         """Validate snapshot for reasonable values
 
         Returns:
         True if snapshot appears valid
         """
         try:
             # Check frame state for NaN/inf
             frame_values = [
                 self.frame.heave,
                 self.frame.roll,
                 self.frame.pitch,
                 self.frame.heave_rate,
                 self.frame.roll_rate,
                 self.frame.pitch_rate,
             ]
 
             if not all(np.isfinite(v) for v in frame_values):
                 return False
 
             # Check reasonable angle limits (~45 degrees)
             if abs(self.frame.roll) > 0.785 or abs(self.frame.pitch) > 0.785:
                 return False
 
             # Check line pressures (must be positive, reasonable range)
             for line_state in self.lines.values():
-                if line_state.pressure <= 0 or line_state.pressure > 1e7:  # 0 to100 bar
+                if not np.isfinite(line_state.pressure) or not np.isfinite(
+                    line_state.volume
+                ):
                     return False
-                if not np.isfinite(line_state.pressure):
+
+                if line_state.pressure <= 0.0:
+                    return False
+
+                if line_state.volume <= 0.0:
+                    return False
+
+                if (
+                    line_state.pressure_min is not None
+                    and line_state.pressure < line_state.pressure_min * 0.999
+                ):
+                    return False
+
+                if (
+                    line_state.pressure_max is not None
+                    and line_state.pressure > line_state.pressure_max * 1.001
+                ):
+                    return False
+
+                if (
+                    line_state.volume_min is not None
+                    and line_state.volume < line_state.volume_min * 0.999
+                ):
+                    return False
+
+                if (
+                    line_state.volume_max is not None
+                    and line_state.volume > line_state.volume_max * 1.001
+                ):
                     return False
 
             # Check tank pressure
-            if self.tank.pressure <= 0 or not np.isfinite(self.tank.pressure):
+            if not np.isfinite(self.tank.pressure) or not np.isfinite(
+                self.tank.volume
+            ):
+                return False
+
+            if self.tank.pressure <= 0 or self.tank.volume <= 0:
+                return False
+
+            if (
+                self.tank.pressure_min is not None
+                and self.tank.pressure < self.tank.pressure_min * 0.999
+            ):
                 return False
 
+            if (
+                self.tank.pressure_max is not None
+                and self.tank.pressure > self.tank.pressure_max * 1.001
+            ):
+                return False
+
+            if (
+                self.tank.volume_min is not None
+                and self.tank.volume < self.tank.volume_min * 0.999
+            ):
+                return False
+
+            if (
+                self.tank.volume_max is not None
+                and self.tank.volume > self.tank.volume_max * 1.001
+            ):
+                return False
+
+            # Wheel volumes and lever angles
+            for wheel_state in self.wheels.values():
+                if not np.isfinite(wheel_state.lever_angle):
+                    return False
+                if (
+                    wheel_state.lever_angle_min is not None
+                    and wheel_state.lever_angle < wheel_state.lever_angle_min - 1e-6
+                ):
+                    return False
+                if (
+                    wheel_state.lever_angle_max is not None
+                    and wheel_state.lever_angle > wheel_state.lever_angle_max + 1e-6
+                ):
+                    return False
+                if not np.isfinite(wheel_state.vol_head) or not np.isfinite(
+                    wheel_state.vol_rod
+                ):
+                    return False
+                if wheel_state.vol_head <= 0 or wheel_state.vol_rod <= 0:
+                    return False
+                if (
+                    wheel_state.vol_head_min > 0
+                    and wheel_state.vol_head < wheel_state.vol_head_min * 0.999
+                ):
+                    return False
+                if (
+                    wheel_state.vol_head_max > 0
+                    and wheel_state.vol_head > wheel_state.vol_head_max * 1.001
+                ):
+                    return False
+                if (
+                    wheel_state.vol_rod_min > 0
+                    and wheel_state.vol_rod < wheel_state.vol_rod_min * 0.999
+                ):
+                    return False
+                if (
+                    wheel_state.vol_rod_max > 0
+                    and wheel_state.vol_rod > wheel_state.vol_rod_max * 1.001
+                ):
+                    return False
+
             return True
 
         except Exception:
             return False
 
 
 class StateBus(QObject):
     """Signal bus for thread-safe state communication
 
     Provides Qt signals for communicating between physics and UI threads.
     All signals use queued connections for thread safety.
     """
 
     # Main state signal - emitted from physics thread
     state_ready = Signal(object)  # StateSnapshot
 
     # Control signals - emitted from UI thread
     start_simulation = Signal()
     stop_simulation = Signal()
     reset_simulation = Signal()
     pause_simulation = Signal()
 
     # Configuration signals
     set_physics_dt = Signal(float)  # Change physics timestep
     set_thermo_mode = Signal(str)  # "ISOTHERMAL" or "ADIABATIC"
diff --git a/tests/system/test_runtime_state.py b/tests/system/test_runtime_state.py
new file mode 100644
index 0000000000000000000000000000000000000000..c81679cfe9caff0e7aa98e7cdf34a75e78b9a7cf
--- /dev/null
+++ b/tests/system/test_runtime_state.py
@@ -0,0 +1,76 @@
+import pytest
+
+pytest.importorskip("PySide6")
+
+from runtime.sim_loop import PhysicsWorker
+from runtime.state import StateSnapshot
+from src.pneumo.enums import Wheel, Line, Port
+
+
+@pytest.fixture
+def physics_worker():
+    worker = PhysicsWorker()
+    worker.configure()
+    try:
+        yield worker
+    finally:
+        worker.force_cleanup()
+
+
+def _advance_worker(worker: PhysicsWorker, steps: int = 3) -> StateSnapshot:
+    for _ in range(steps):
+        worker._execute_physics_step()
+    snapshot = worker._create_state_snapshot()
+    assert snapshot is not None
+    return snapshot
+
+
+def test_worker_produces_valid_snapshot(physics_worker: PhysicsWorker):
+    snapshot = _advance_worker(physics_worker)
+    assert snapshot.validate()
+
+    for wheel_state in snapshot.wheels.values():
+        assert wheel_state.vol_head_min < wheel_state.vol_head < wheel_state.vol_head_max
+        assert wheel_state.vol_rod_min < wheel_state.vol_rod < wheel_state.vol_rod_max
+
+    for line_state in snapshot.lines.values():
+        assert line_state.volume_min is None or line_state.volume_min < line_state.volume
+        assert line_state.volume_max is None or line_state.volume < line_state.volume_max
+
+
+def test_integration_failure_stops_simulation(monkeypatch):
+    worker = PhysicsWorker()
+    worker.configure()
+
+    class DummyResult:
+        success = False
+        message = "forced failure"
+        y_final = None
+
+    monkeypatch.setattr("runtime.sim_loop.step_dynamics", lambda **kwargs: DummyResult())
+
+    worker.is_running = True
+    worker._execute_physics_step()
+
+    assert worker.performance.integration_failures == 1
+    assert not worker.is_running
+    worker.force_cleanup()
+
+
+def test_pneumatic_force_consistency(physics_worker: PhysicsWorker):
+    snapshot = _advance_worker(physics_worker)
+    assert snapshot.validate()
+
+    for wheel in Wheel:
+        wheel_state = snapshot.wheels[wheel]
+        wrapper = physics_worker._cylinder_wrappers[wheel]
+        head_line = physics_worker._wheel_line_map[wheel][Port.HEAD]
+        rod_line = physics_worker._wheel_line_map[wheel][Port.ROD]
+        head_state = physics_worker.gas_network.lines[head_line]
+        rod_state = physics_worker.gas_network.lines[rod_line]
+        expected_force = wrapper.force(head_state.p, rod_state.p)
+        assert wheel_state.force_pneumatic == pytest.approx(expected_force)
+
+    total_in = sum(state.flow_atmo for state in snapshot.lines.values())
+    total_out = sum(state.flow_tank for state in snapshot.lines.values())
+    assert snapshot.aggregates.net_flow == pytest.approx(total_in - total_out)
diff --git a/tests/test_runtime_basic.py b/tests/test_runtime_basic.py
index e6a07e2b9b12036333bff9ef6049a19cc03cea5e..eff86029ef1d55a6352e3324fa3f1312239f7723 100644
--- a/tests/test_runtime_basic.py
+++ b/tests/test_runtime_basic.py
@@ -1,58 +1,119 @@
 """Pytest-based smoke tests for runtime state and sync components."""
 
 import sys
 from pathlib import Path
 
 import pytest
 
+PA_ATM = 101325.0
+T_AMBIENT = 293.15
+
 project_root = Path(__file__).parent.parent
 src_path = project_root / "src"
 if str(src_path) not in sys.path:
     sys.path.insert(0, str(src_path))
 
 pytest.importorskip("PySide6")
 
 from runtime.state import StateSnapshot, StateBus, Line, Wheel  # noqa: E402
 from runtime.sync import LatestOnlyQueue, PerformanceMetrics  # noqa: E402
 
 
 def test_state_snapshot_defaults_are_valid():
     snapshot = StateSnapshot()
 
     assert snapshot.step_number == 0
     assert snapshot.simulation_time == pytest.approx(0.0)
+
+    for wheel_state in snapshot.wheels.values():
+        wheel_state.lever_angle = 0.0
+        wheel_state.lever_angle_min = -0.5
+        wheel_state.lever_angle_max = 0.5
+        wheel_state.vol_head = 1e-4
+        wheel_state.vol_head_min = 5e-5
+        wheel_state.vol_head_max = 2e-4
+        wheel_state.vol_rod = 1e-4
+        wheel_state.vol_rod_min = 5e-5
+        wheel_state.vol_rod_max = 2e-4
+
+    for line_state in snapshot.lines.values():
+        line_state.pressure = PA_ATM
+        line_state.pressure_min = PA_ATM * 0.5
+        line_state.pressure_max = PA_ATM * 5.0
+        line_state.volume = 1e-4
+        line_state.volume_min = 5e-5
+        line_state.volume_max = 2e-4
+        line_state.temperature = T_AMBIENT
+
+    snapshot.tank.pressure = PA_ATM
+    snapshot.tank.pressure_min = PA_ATM * 0.5
+    snapshot.tank.pressure_max = PA_ATM * 5.0
+    snapshot.tank.volume = 5e-3
+    snapshot.tank.volume_min = 1e-3
+    snapshot.tank.volume_max = 1e-2
+    snapshot.tank.temperature = T_AMBIENT
+
     assert snapshot.validate()
     expected_wheels = {Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ}
     expected_lines = {Line.A1, Line.B1, Line.A2, Line.B2}
 
     assert set(snapshot.wheels.keys()) == expected_wheels
     assert set(snapshot.lines.keys()) == expected_lines
 
 
 def test_state_snapshot_invalid_pressure_fails_validation():
     snapshot = StateSnapshot()
+
+    for wheel_state in snapshot.wheels.values():
+        wheel_state.lever_angle = 0.0
+        wheel_state.lever_angle_min = -0.5
+        wheel_state.lever_angle_max = 0.5
+        wheel_state.vol_head = 1e-4
+        wheel_state.vol_head_min = 5e-5
+        wheel_state.vol_head_max = 2e-4
+        wheel_state.vol_rod = 1e-4
+        wheel_state.vol_rod_min = 5e-5
+        wheel_state.vol_rod_max = 2e-4
+
+    for line_state in snapshot.lines.values():
+        line_state.pressure = PA_ATM
+        line_state.pressure_min = PA_ATM * 0.5
+        line_state.pressure_max = PA_ATM * 5.0
+        line_state.volume = 1e-4
+        line_state.volume_min = 5e-5
+        line_state.volume_max = 2e-4
+        line_state.temperature = T_AMBIENT
+
+    snapshot.tank.pressure = PA_ATM
+    snapshot.tank.pressure_min = PA_ATM * 0.5
+    snapshot.tank.pressure_max = PA_ATM * 5.0
+    snapshot.tank.volume = 5e-3
+    snapshot.tank.volume_min = 1e-3
+    snapshot.tank.volume_max = 1e-2
+    snapshot.tank.temperature = T_AMBIENT
+
     first_line = next(iter(snapshot.lines.values()))
     first_line.pressure = -10.0
 
     assert not snapshot.validate()
 
 
 def test_latest_only_queue_keeps_only_latest_item():
     queue = LatestOnlyQueue()
 
     assert queue.get_nowait() is None
 
     assert queue.put_nowait("first")
     assert queue.put_nowait("second")
 
     assert queue.get_nowait() == "second"
     assert queue.get_nowait() is None
 
     stats = queue.get_stats()
     assert stats["put_count"] == 2
     assert stats["dropped_count"] == 1
     assert stats["get_count"] == 1
     assert stats["efficiency"] == pytest.approx(0.5)
 
 
 def test_performance_metrics_accumulates_statistics():
