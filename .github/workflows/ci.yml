name: Continuous Integration

on:
  push:
    branches: [main, develop, 'feature/*', 'feature/hdr-assets-migration']
  pull_request:
    branches: [main, develop, 'feature/*', 'feature/hdr-assets-migration']
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.13"
  QT_VERSION: "6.10.0"
  QT_QPA_PLATFORM: offscreen
  PSS_ENV_PRESET: trace

jobs:
  quality:
    name: Quality gate (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
    env:
      PYTHONPATH: src
      PSS_ENV_PRESET: ${{ env.PSS_ENV_PRESET }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Install GNU Make (Windows)
        if: runner.os == 'Windows'
        run: choco install make --no-progress -y

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements*.txt
            pyproject.toml

      - name: Upgrade pip and install tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install uv aqtinstall

      - name: Bootstrap Linux environment
        if: runner.os == 'Linux'
        env:
          QT_VERSION: ${{ env.QT_VERSION }}
        run: bash ./scripts/setup_linux.sh --qt-version ${{ env.QT_VERSION }} --skip-qt

      - name: Bootstrap Windows environment
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process -Force
          ./scripts/setup_windows.ps1 -QtVersion $env:QT_VERSION -PythonPath "${{ env.pythonLocation }}\\python.exe" -SkipQt:$true

      - name: Discover available Qt versions
        run: |
          python -m aqt list-qt linux desktop
          python -m aqt list-qt windows desktop

      - name: Check dependency graph with uv
        shell: bash
        run: |
          set -o pipefail
          mkdir -p reports/dependencies
          uv pip check | tee reports/dependencies/uv-pip-check.log
          {
            echo "### uv pip check";
            echo '```';
            cat reports/dependencies/uv-pip-check.log;
            echo '```';
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Provision Qt ${{ env.QT_VERSION }}
        run: python tools/setup_qt.py --qt-version ${{ env.QT_VERSION }} --force --prune-archives

      - name: Export Qt paths
        shell: python
        run: |
          import os
          import platform
          from pathlib import Path

          version = os.environ["QT_VERSION"]
          root = Path.cwd() / "Qt" / version
          system = platform.system().lower()
          if system == "windows":
              arch = "win64_msvc2019_64"
          elif system == "linux":
              arch = "gcc_64"
          else:
              arch = "clang_64"

          base = root / arch
          bin_path = base / "bin"
          plugin_path = base / "plugins"
          qml_path = base / "qml"

          github_path = Path(os.environ["GITHUB_PATH"])
          with github_path.open("a", encoding="utf-8") as fh:
              fh.write(f"{bin_path}{os.linesep}")

          github_env = Path(os.environ["GITHUB_ENV"])
          with github_env.open("a", encoding="utf-8") as fh:
              fh.write(f"QT_PLUGIN_PATH={plugin_path}{os.linesep}")
              fh.write(f"QML2_IMPORT_PATH={qml_path}{os.linesep}")

      - name: Document headless Qt environment
        shell: bash
        run: |
          {
            echo "### Headless Qt environment";
            echo "- QT_VERSION=${QT_VERSION}";
            echo "- QT_QPA_PLATFORM=${QT_QPA_PLATFORM}";
            echo "- QT_QUICK_BACKEND=${QT_QUICK_BACKEND:-n/a}";
            echo "- QSG_RHI_BACKEND=${QSG_RHI_BACKEND:-n/a}";
            echo "- QT_OPENGL=${QT_OPENGL:-n/a}";
            echo "- DISPLAY=${DISPLAY:-<empty>}";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Run make full_verify (Linux)
        if: runner.os == 'Linux'
        id: make-check-linux
        continue-on-error: true
        env:
          PSS_HEADLESS: "1"
          QT_QPA_PLATFORM: offscreen
          QT_QUICK_BACKEND: software
          QSG_RHI_BACKEND: opengl
          LIBGL_ALWAYS_SOFTWARE: "1"
          MESA_GL_VERSION_OVERRIDE: "4.1"
          MESA_GLSL_VERSION_OVERRIDE: "410"
        run: bash scripts/xvfb_wrapper.sh make full_verify

      - name: Run make full_verify (Windows)
        if: runner.os == 'Windows'
        id: make-check-windows
        continue-on-error: true
        env:
          QSG_RHI_BACKEND: d3d11
          QT_QUICK_BACKEND: rhi
        run: make full_verify

      - name: Audit shader logs
        run: python tools/check_shader_logs.py reports/shaders --recursive --expect-fallback

      - name: Aggregate analyser warnings
        if: always()
        run: python -m tools.quality.emit_pr_annotations

      - name: Publish collected warnings
        if: always()
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const core = require('@actions/core');
            const fs = require('fs');
            const path = 'reports/warnings.log';

            if (!fs.existsSync(path)) {
              core.info('warnings.log not found, skipping annotations.');
              return;
            }

            const raw = fs.readFileSync(path, 'utf8');
            const lines = raw
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter((line) => line.length > 0 && !line.startsWith('#'));

            if (lines.length === 0) {
              core.info('warnings.log is empty.');
              return;
            }

            for (const entry of lines) {
              const match = entry.match(/^(.*?)(?::(\d+))?\s*-\s*(.*)$/);
              if (match) {
                const file = match[1].trim();
                const lineNumber = match[2] ? Number(match[2]) : undefined;
                const message = match[3].trim() || 'Warning detected';
                const options = { file };
                if (Number.isFinite(lineNumber)) {
                  options.startLine = lineNumber;
                  options.endLine = lineNumber;
                }
                core.warning(message, options);
              } else {
                core.warning(entry);
              }
            }

      - name: Generate AI failure report
        if: failure()
        shell: bash
        run: |
          python - <<'PY'
          import pathlib
          import subprocess
          import sys

          reports_dir = pathlib.Path("reports/quality")
          reports_dir.mkdir(parents=True, exist_ok=True)
          output_path = reports_dir / "ai_failure_report.log"

          result = subprocess.run(
              [sys.executable, "analyze_logs.py"],
              capture_output=True,
              text=True,
          )

          payload = result.stdout
          if result.stderr:
              payload += "\n" + result.stderr

          output_path.write_text(payload, encoding="utf-8")

          sys.stdout.write(result.stdout)
          if result.stderr:
              sys.stderr.write(result.stderr)
          if result.returncode != 0:
              sys.stdout.write(
                  f"\n[ci] analyze_logs.py exited with status {result.returncode}; continuing for diagnostics.\n"
              )
          PY

      - name: Upload quality artefacts
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: quality-${{ matrix.os }}
          path: |
            reports/quality/**
            reports/environment/**
            reports/tests/**
            logs/**
          if-no-files-found: warn

      - name: Fail if make full_verify failed
        if: |
          (steps.make-check-linux.conclusion == 'failure') ||
          (steps.make-check-windows.conclusion == 'failure')
        run: exit 1
