name: Continuous Integration

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.13"
  QT_VERSION: "6.10.0"
  QT_QPA_PLATFORM: offscreen
  QT_QUICK_BACKEND: software
  LIBGL_ALWAYS_SOFTWARE: "1"
  MESA_GL_VERSION_OVERRIDE: "4.1"
  MESA_GLSL_VERSION_OVERRIDE: "410"

jobs:
  quality:
    name: Quality gate (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
    env:
      QT_QPA_PLATFORM: ${{ env.QT_QPA_PLATFORM }}
      QT_QUICK_BACKEND: ${{ env.QT_QUICK_BACKEND }}
      LIBGL_ALWAYS_SOFTWARE: ${{ env.LIBGL_ALWAYS_SOFTWARE }}
      MESA_GL_VERSION_OVERRIDE: ${{ env.MESA_GL_VERSION_OVERRIDE }}
      MESA_GLSL_VERSION_OVERRIDE: ${{ env.MESA_GLSL_VERSION_OVERRIDE }}
      PYTHONPATH: src
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Install headless Qt Quick dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            xvfb xauth dbus-x11 \
            mesa-utils mesa-utils-extra \
            libgl1 libgl1-mesa-dri libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev \
            libegl1 libegl1-mesa libegl1-mesa-dev libgles2-mesa libgles2-mesa-dev \
            libosmesa6 libosmesa6-dev libgbm1 libdrm2 \
            libxcb-xinerama0 libxkbcommon0 libxkbcommon-x11-0 \
            libxcb-keysyms1 libxcb-image0 libxcb-icccm4 libxcb-render-util0 libxcb-xfixes0 libxcb-shape0 libxcb-randr0 libxcb-glx0 \
            libvulkan1 mesa-vulkan-drivers vulkan-tools

      - name: Install GNU Make (Windows)
        if: runner.os == 'Windows'
        run: choco install make --no-progress -y

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements*.txt
            pyproject.toml

      - name: Upgrade pip and install tooling
        run: |
          python -m pip install --upgrade pip
          python -m pip install uv aqtinstall

      - name: Discover available Qt versions
        run: |
          python -m aqt list-qt linux desktop
          python -m aqt list-qt windows desktop

      - name: Install project dependencies
        run: python -m pip install -r requirements-dev.txt

      - name: Provision Qt ${{ env.QT_VERSION }}
        run: python tools/setup_qt.py --qt-version ${{ env.QT_VERSION }} --force --prune-archives

      - name: Export Qt paths
        shell: python
        run: |
          import os
          import platform
          from pathlib import Path

          version = os.environ["QT_VERSION"]
          root = Path.cwd() / "Qt" / version
          system = platform.system().lower()
          if system == "windows":
              arch = "win64_msvc2019_64"
          elif system == "linux":
              arch = "gcc_64"
          else:
              arch = "clang_64"

          base = root / arch
          bin_path = base / "bin"
          plugin_path = base / "plugins"
          qml_path = base / "qml"

          github_path = Path(os.environ["GITHUB_PATH"])
          with github_path.open("a", encoding="utf-8") as fh:
              fh.write(f"{bin_path}{os.linesep}")

          github_env = Path(os.environ["GITHUB_ENV"])
          with github_env.open("a", encoding="utf-8") as fh:
              fh.write(f"QT_PLUGIN_PATH={plugin_path}{os.linesep}")
              fh.write(f"QML2_IMPORT_PATH={qml_path}{os.linesep}")

      - name: Run make check
        id: make-check
        continue-on-error: true
        run: |
          if [ "${{ runner.os }}" = "Linux" ]; then
            bash scripts/xvfb_wrapper.sh make check
          else
            make check
          fi

      - name: Audit shader logs
        run: python tools/check_shader_logs.py reports/shaders --recursive --expect-fallback

      - name: Aggregate analyser warnings
        if: always()
        run: python -m tools.quality.emit_pr_annotations

      - name: Publish collected warnings
        if: always()
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const core = require('@actions/core');
            const fs = require('fs');
            const path = 'reports/warnings.log';

            if (!fs.existsSync(path)) {
              core.info('warnings.log not found, skipping annotations.');
              return;
            }

            const raw = fs.readFileSync(path, 'utf8');
            const lines = raw
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter((line) => line.length > 0 && !line.startsWith('#'));

            if (lines.length === 0) {
              core.info('warnings.log is empty.');
              return;
            }

            for (const entry of lines) {
              const match = entry.match(/^(.*?)(?::(\d+))?\s*-\s*(.*)$/);
              if (match) {
                const file = match[1].trim();
                const lineNumber = match[2] ? Number(match[2]) : undefined;
                const message = match[3].trim() || 'Warning detected';
                const options = { file };
                if (Number.isFinite(lineNumber)) {
                  options.startLine = lineNumber;
                  options.endLine = lineNumber;
                }
                core.warning(message, options);
              } else {
                core.warning(entry);
              }
            }

      - name: Generate AI failure report
        if: failure()
        shell: bash
        run: |
          python - <<'PY'
          import pathlib
          import subprocess
          import sys

          reports_dir = pathlib.Path("reports/quality")
          reports_dir.mkdir(parents=True, exist_ok=True)
          output_path = reports_dir / "ai_failure_report.log"

          result = subprocess.run(
              [sys.executable, "analyze_logs.py"],
              capture_output=True,
              text=True,
          )

          payload = result.stdout
          if result.stderr:
              payload += "\n" + result.stderr

          output_path.write_text(payload, encoding="utf-8")

          sys.stdout.write(result.stdout)
          if result.stderr:
              sys.stderr.write(result.stderr)
          if result.returncode != 0:
              sys.stdout.write(
                  f"\n[ci] analyze_logs.py exited with status {result.returncode}; continuing for diagnostics.\n"
              )
          PY

      - name: Upload quality artefacts
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: quality-${{ matrix.os }}
          path: |
            reports/quality/**
            reports/environment/**
            reports/tests/**
            logs/**
          if-no-files-found: warn

      - name: Fail if make check failed
        if: steps.make-check.conclusion == 'failure'
        run: exit 1
