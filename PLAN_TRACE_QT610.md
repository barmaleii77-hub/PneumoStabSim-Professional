# План сквозной трассировки и аудита настроек

Документ описывает последовательность действий для полного аудита взаимодействия Python ↔ QML и пользовательского интерфейса.
Он учитывает требования Qt6.10, полную управляемость параметров через `config/app_settings.json`
и лучшие практики, описанные в Qt Documentation, Qt Design Studio Manual и Qt Quick3D Guidelines.

##1. Подготовка окружения

1. Зафиксировать состав зависимостей из `pyproject.toml` и настроить виртуальное окружение, устанавливая основные и dev-пакеты (PySide6≥6.10 — ключевой компонент).
2. Дополнительно поставить инструменты статического анализа QML (`qmlformat`, `qmllint`) и Python (`flake8`, `mypy`, `black`) для автоматизированных проверок стиля и типизации.
3. Подготовить скрипт запуска приложения, который экспортирует все переменные окружения, используемые загрузчиком настроек (`PSS_SETTINGS_FILE`, `PSS_VERBOSE_CONFIG`) и Qt (RHI backend), чтобы можно было воспроизводить сценарии из `ApplicationRunner` на каждой машине.
4. Зафиксировать версии утилит трассировки (например, `py-spy`, `Qt Creator Analyzer`) и включить флаги Qt Quick Controls `QT_QUICK_CONTROLS_STYLE_ITEMS=1` для диагностики недоступных элементов.

##2. Аудит системы настроек

1. Проследить полный цикл `SettingsManager`: разрешение пути, чтение/миграция ключей, авто-сохранение и отсутствие заглушек. Подготовить журнал трассировки с фиксацией каждого шага, чтобы убедиться, что единственный источник истины — `config/app_settings.json` и нет скрытых дефолтов.
2. Проверить структуру `app_settings.json`, сопоставить все параметры (geometry/pneumatic/modes/graphics) с ожидаемыми типами и диапазонами, фиксируя несовпадения для дальнейших правок UI.
3. Убедиться, что `StateSync.save_settings` агрегирует состояния всех панелей и сохраняет их атомарно, без пропусков категорий и с корректной обработкой исключений; при необходимости расширить логирование и добавить проверки прав доступа к файлу.
4. Разработать автоматический тест на консистентность: загрузить JSON, пройтись по всем путям dot-нотацией через `SettingsManager.get`, сравнить с фактическими UI-значениями, убедиться в симметрии `set`/`save`.
5. Сформировать «путевой лист» параметров: для каждого ключа указать источник (JSON), потребителя (панель/компонент) и точку сохранения, чтобы обеспечить полную трассировку при ревью.

##3. Процедура запуска приложения

1. По шагам проследить `app.py → ApplicationRunner`: настройку окружения, регистрацию обработчиков сигналов, запуск `QApplication`, выбор MainWindow. Зафиксировать каждый сигнал/slot, чтобы обнаружить потенциальные гонки при старте/выключении.
2. Проверить, что `_validate_settings_file` действительно прекращает запуск при некорректном конфиге и показывает пользователю понятную диагностику (MessageBox + лог).

##4. Архитектура MainWindow и UI

1. Пройтись по конструктору `MainWindow`: убедиться, что все подмодули подключены, QML-виджет создаётся до подключения сигналов, инициализация рендер-таймера и загрузка панелей происходят в корректном порядке. Создать блок-схему запуска и восстановления состояния.
2. Проанализировать `UISetup`: проверить, что контекст QML получает ссылку на окно и пути импортов настроены до загрузки QML; обеспечить, что fallback-виджет обрабатывает ошибки загрузки без скрытых заглушек.
3. Убедиться, что `SignalsRouter.connect_all_signals` покрывает все панели, симуляцию и QML, не оставляя «висячих» сигналов; составить таблицу «сигнал → обработчик» для дальнейшей регрессии.
4. Проверить, что методы `_on_*` в `MainWindow` не содержат логики, а только делегируют в роутеры/менеджеры (координаторский паттерн соблюдён).
5. Подготовить сценарии «горячего» переподключения QML (reload), чтобы убедиться, что повторная инициализация не создаёт дублированных подписок.

##5. Панели параметров и соответствие требованиям «один параметр— один контрол»

1. Для `GraphicsPanel` собрать матрицу соответствия: каждый ключ из `app_settings.json["graphics"]` → конкретный таб/виджет, тип ввода, диапазон, биндинг сигналов. Обратить внимание на отсутствие встроенных дефолтов и покрытие всех под-настроек (lighting/environment/quality/camera/effects/materials).
2. Аналогично проверить `GeometryPanel`: убедиться, что `GeometryStateManager` опирается на JSON-значения, а не внутренние константы; зафиксировать элементы UI, которые пока не синхронизируются с файлом настроек (например, коэффициенты шарниров).
3. Проверить оставшиеся панели (pneumo, modes, road) на предмет:
 - наличия методов `collect_state`/`load_state`;
 - отсутствия скрытой логики (магических коэффициентов);
 - отключения контролов, если параметр read-only.
4. Везде, где обнаружены жёстко прошитые значения (например, `GeometryTo3DConverter` или `SuspensionCorner.qml`), запланировать перенос в JSON/SettingsManager и привязку к UI-контролам.
5. Использовать методику Qt Quick Controls Accessibility Review: включить аутлайн доступности (`QT_QUICK_CONTROLS_ACCESSIBILITY=1`) и убедиться, что все управляющие элементы доступны и помечены.

##6. Мост Python↔QML и анимация

1. Проверить архитектуру `QMLBridge`: очередь батч-обновлений, подготовка данных, ACK-логика. Убедиться, что `pendingPythonUpdates` используется строго по протоколу (передача → очистка → ack).
2. Убедиться, что `SignalsRouter.handle_*` вызывает QML только через мост и корректно логирует применение/откат при ошибке; при необходимости добавить обратное уведомление о провале применения параметра.
3. Проследить цепочку анимации: изменения в `ModesPanel` → `_on_animation_changed` → `applyAnimationUpdates` в QML (включая поддержку всех параметров частоты/фазы/амплитуды и режимов).
4. Проверить `GeometryTo3DConverter` и `SuspensionCorner.qml` на предмет корректности пересчёта координат: расчёты длин, углов, ограничения и отсутствие жёстко заданных значений (все параметры должны приходить из настроек/UI).
5. Проследить обработку runtime-снимков (`StateSnapshot`) — обновление лейблов, графиков, передачи положения цилиндров и т.д., чтобы исключить несогласованность между физикой и визуализацией.
6. Проверить время жизни и потоковую безопасность объектов, связанных с QML (использовать `QObject::destroyed` и тесты на утечки при многократном открытии окон).

##7. QML сцена и визуальные настройки

1. Провести построчную ревизию `assets/qml/main.qml`:
 - убедиться, что `apply*Updates` покрывают все параметры из JSON и используют `require*`-валидацию по стандартам Qt6.10;
 - проверить ограничения `clamp`, чтобы диапазоны соответствовали документации (например, тонемапинг, SSAO, TAA).
2. Проверить определение свойств root-объекта и дочерних компонентов на предмет «скрытых» дефолтов — все значения должны быть либо заданы в конфиге, либо приходить из Python, либо явно отображаться в UI.
3. Для каждого визуального параметра убедиться, что в UI есть элемент управления и что QML свойство `enabled` связано с флагами доступности (например, если SSAO выключен, слайдеры радиуса недоступны).
4. Проверить модули `geometry`, `lighting`, `scene`, `components` на совместимость с Qt6.10 (использование `required property`, отсутствие устаревших API) и подготовить список мест, где нужно обновить синтаксис/типы.
5. Выполнить аудит слоёв материалов и эффектов с учётом рекомендаций Qt Quick3D по производительности: профилировать количество draw call и использование `Lightmapper`, задокументировать границы допустимых значений.

##8. Система симуляции и синхронизация

1. Проанализировать `runtime/sync.py` и связанные циклы симуляции, чтобы убедиться в корректном обмене состояниями «последнее значение выигрывает», отсутствии гонок и корректном обновлении метрик производительности (это влияет на отображение FPS/меток в UI).
2. Проверить, что структура snapshot-а содержит все необходимые данные для QML (положения цилиндров, углы, давления и т.д.) и что они доставляются в сцену без пропусков.
3. Настроить стресс-тесты с увеличенной частотой обновления, чтобы убедиться в корректности LatestOnly-очередей и отсутствии дрейфа параметров.

##9. Логирование и диагностика

1. Убедиться, что каждый критичный шаг (чтение настроек, применение параметров, ACK от QML, ошибки симуляции) логируется как минимум на уровне INFO, чтобы обеспечить трассировку «от конфигурации до визуализации».
2. Проверить интеграцию `event_logger` и `graphics_logger`, убедиться, что записи не дублируются и достаточно информации для аудита (особенно при batched-обновлениях).
3. Настроить сводный отчёт диагностики: автоматическая выгрузка логов и снимков настроек при завершении работы приложения для воспроизводимости ошибок.

##10. Тесты и проверки (план запуска)

- ✅ `python -m venv .venv && source .venv/bin/activate && pip install -e .[dev]` — подготовка окружения и установка зависимостей (повторять при изменении `pyproject.toml`).
- ✅ `pytest` — регрессия Python-части, включая тесты на синхронизацию и загрузку настроек; сохранять отчёты `pytest --maxfail=1 --disable-warnings -q`.
- ✅ `mypy src` — статическая типизация для Python-модулей.
- ✅ `flake8 src` — линтер для выявления нарушений стиля и потенциальных ошибок.
- ✅ `qmllint assets/qml/main.qml` и `qmllint assets/qml/**/*.qml` — статический анализ QML, проверка на соответствие Qt6.10.
- ✅ `qmlformat -n assets/qml/**/*.qml` — проверка форматирования (без изменения файлов в рамках тестового прогона).
- ✅ `pytest tests/ui --qt-api=pyside6 -k "graphics or geometry"` — интеграционные Qt-тесты для панелей и сигналов.
- ✅ `pytest tests/runtime -k "sync"` — проверка очереди LatestOnly и метрик.

##11. Лучшие практики и ссылки

1. Qt6.10 Documentation — Qt Quick3D Rendering and Performance Guidelines: соблюдать рекомендации по настройке освещения, материалов и пост-эффектов, избегать лишних `TextureLoader`.
2. Qt Design Studio Manual — UI/UX Best Practices: каждый параметр получает собственный контрол, обязательные состояния `enabled/disabled` привязаны к данным, отсутствуют скрытые пресеты.
3. Qt Quick Controls2 Guidelines — внедрить `Control::Accessible` описания для каждого элемента, чтобы улучшить тестирование и соответствие требованиям доступности.
4. Python logging best practices (PEP282, structlog): использовать структурированное логирование для трассировки настроек и сигналов.
5. QML Coding Conventions — применять `pragma Singleton` и `required property` в соответствии с официальными рекомендациями, избегать устаревших типов.

##12. Отчётность и публикация результатов

1. Подготовить итоговый Markdown-отчёт с результатами каждого этапа проверки, приложить таблицы соответствия параметров UI ↔ JSON.
2. Сформировать ветку `audit/qt610-trace-plan` и запушить её в удалённый репозиторий вместе с журналом выполненных тестов и ссылкой на этот документ.
3. Создать issue/PR в основном репозитории, чтобы команда могла отслеживать прогресс и оставлять комментарии к плану.
