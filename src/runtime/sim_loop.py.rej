diff a/src/runtime/sim_loop.py b/src/runtime/sim_loop.py	(rejected hunks)
@@ -1,113 +1,157 @@
 """
 Physics simulation loop with fixed timestep
 Runs in dedicated QThread with QTimer for precise timing
 """
 
+import math
 import time
 import logging
 from typing import Optional, Dict, Any
 import numpy as np
 
 from PySide6.QtCore import QObject, QTimer, Signal, Slot, Qt
 from PySide6.QtCore import QThread
 
 from .state import (
     StateSnapshot,
     StateBus,
     FrameState,
     WheelState,
     LineState,
     TankState,
     SystemAggregates,
 )
 from .sync import (
     LatestOnlyQueue,
     PerformanceMetrics,
     TimingAccumulator,
     ThreadSafeCounter,
 )
 
 # Измененные импорты на абсолютные пути
 from src.physics.odes import RigidBody3DOF, create_initial_conditions
 from src.physics.integrator import (
     step_dynamics,
     create_default_rigid_body,
 )
 from src.pneumo.enums import (
     Wheel,
     Line,
     ThermoMode,
+    ReceiverVolumeMode,
+    Port,
 )
-from src.pneumo.receiver import ReceiverState
+from src.pneumo.cylinder import CylinderSpec, CylinderState
+from src.pneumo.receiver import ReceiverSpec, ReceiverState
 from src.pneumo.system import create_standard_diagonal_system
 from src.pneumo.gas_state import create_line_gas_state, create_tank_gas_state
 from src.pneumo.network import GasNetwork
 from src.road.engine import RoadInput
 from src.road.scenarios import get_preset_by_name
+from src.road.types import RoadConfig
 
 # Settings manager (используем абсолютный импорт, т.к. общий модуль)
 from src.common.settings_manager import get_settings_manager
+from src.common.units import PA_ATM, T_AMBIENT
+from src.app.config_defaults import create_default_system_configuration
+from src.mechanics.components import Lever, PneumaticCylinder
 
 
 class PhysicsWorker(QObject):
     """Physics simulation worker running in dedicated thread
 
     Handles fixed-timestep physics simulation with road inputs,
     pneumatic system, and3-DOF frame dynamics.
     """
 
     # Signals emitted to UI thread
     state_ready = Signal(object)  # StateSnapshot
     error_occurred = Signal(str)  # Error message
     performance_update = Signal(object)  # PerformanceMetrics
 
     def __init__(self, parent=None):
         super().__init__(parent)
 
         # Logging and settings access
         self.logger = logging.getLogger(__name__)
         self.settings_manager = get_settings_manager()
 
         # Physics configuration (loaded from settings file)
         self.dt_physics: float = 0.0
         self.vsync_render_hz: float = 0.0
         self.max_steps_per_frame: int = 1
         self.max_frame_time: float = 0.05
 
         # Simulation state
         self.is_running = False
         self.is_configured = False
         self.simulation_time = 0.0
         self.step_counter = 0
 
         # Physics objects (will be initialized in configure)
         self.rigid_body: Optional[RigidBody3DOF] = None
         self.road_input: Optional[Any] = None  # Changed type hint
         self.pneumatic_system: Optional[Any] = None
         self.gas_network: Optional[Any] = None
 
+        # Geometry and component models
+        self.frame_geom = None
+        self.lever_geom = None
+        self.cylinder_geom = None
+        self._lever_models: Dict[Wheel, Lever] = {}
+        self._cylinder_wrappers: Dict[Wheel, PneumaticCylinder] = {}
+        self._cylinder_volume_limits: Dict[Wheel, Dict[str, float]] = {}
+        self._lever_angle_limits: Dict[Wheel, tuple[float, float]] = {}
+        self._wheel_line_map: Dict[Wheel, Dict[Port, Line]] = {}
+        self._line_volume_limits: Dict[Line, tuple[float, float]] = {}
+        self._line_pressure_limits: tuple[float, float] = (0.0, 0.0)
+        self._tank_pressure_limits: tuple[float, float] = (0.0, 0.0)
+        self._previous_piston_positions: Dict[Wheel, float] = {}
+        self._piston_velocities: Dict[Wheel, float] = {}
+        self._current_lever_angles: Dict[Wheel, float] = {
+            wheel: 0.0 for wheel in Wheel
+        }
+        self._wheel_to_road_key: Dict[Wheel, str] = {
+            Wheel.LP: "LF",
+            Wheel.PP: "RF",
+            Wheel.LZ: "LR",
+            Wheel.PZ: "RR",
+        }
+        self._current_road_inputs: Dict[str, float] = {
+            key: 0.0 for key in self._wheel_to_road_key.values()
+        }
+        self._last_line_flows: Dict[Line, Dict[str, float]] = {
+            line: {"flow_atmo": 0.0, "flow_tank": 0.0}
+            for line in (Line.A1, Line.B1, Line.A2, Line.B2)
+        }
+        self._last_relief_flows = {
+            "flow_min": 0.0,
+            "flow_stiff": 0.0,
+            "flow_safety": 0.0,
+        }
+
         # Current physics state
         self.physics_state: np.ndarray = np.zeros(6)  # [Y, φz, θx, dY, dφz, dθx]
 
         # Simulation modes (overridden by persisted settings)
         self.thermo_mode = ThermoMode.ISOTHERMAL
         self.master_isolation_open = False
 
         # Receiver parameters and limits (loaded from settings)
         self.receiver_volume: float = 0.0
         self.receiver_volume_mode: str = ""
         self._volume_limits: tuple[float, float] = (0.0, 0.0)
 
         # Threading objects (created in target thread)
         self.physics_timer: Optional[QTimer] = None
 
         # Performance monitoring
         self.performance = PerformanceMetrics()
         self.timing_accumulator: Optional[TimingAccumulator] = None
         self.step_time_samples = []
 
         # Thread safety
         self.error_counter = ThreadSafeCounter()
 
         # Load persisted configuration
         self._load_initial_settings()
@@ -247,101 +291,278 @@ class PhysicsWorker(QObject):
         ):
             self.vsync_render_hz = float(vsync_render_hz)
         if isinstance(max_steps_per_frame, (int, float)) and not isinstance(
             max_steps_per_frame, bool
         ):
             self.max_steps_per_frame = max(1, int(round(max_steps_per_frame)))
         if isinstance(max_frame_time, (int, float)) and not isinstance(
             max_frame_time, bool
         ):
             self.max_frame_time = float(max_frame_time)
 
         # Update timing accumulator
         self._apply_timing_configuration()
 
         # Create default physics objects
         self._initialize_physics_objects()
 
         self.is_configured = True
         self.logger.info(
             f"Physics configured: dt={self.dt_physics*1000:.3f}ms, render={self.vsync_render_hz:.1f}Hz"
         )
 
     def _initialize_physics_objects(self):
         """Initialize physics simulation objects"""
         try:
-            # Create 3-DOF rigid body
+            # Create 3-DOF rigid body and initial conditions
             self.rigid_body = create_default_rigid_body()
-
-            # Initialize physics state (at rest)
             self.physics_state = create_initial_conditions()
 
-            # TODO: Initialize pneumatic system and gas network
-            # For now, create minimal stubs
-            self.pneumatic_system = None  # Will be set up later
-            self.gas_network = None
+            # Build pneumatic system from validated defaults
+            defaults = create_default_system_configuration()
+            self.frame_geom = defaults["frame_geom"]
+            self.lever_geom = defaults["lever_geom"]
+            self.cylinder_geom = defaults["cylinder_geom"]
+            cylinder_specs = defaults["cylinder_specs"]
+            line_configs = defaults["line_configs"]
+
+            receiver_mode = (
+                ReceiverVolumeMode.ADIABATIC_RECALC
+                if self.receiver_volume_mode.upper() == "GEOMETRIC"
+                else ReceiverVolumeMode.NO_RECALC
+            )
 
-            # TODO: Initialize road input
-            # For now, create minimal stub
-            self.road_input = None
+            receiver_spec = ReceiverSpec(
+                V_min=self._volume_limits[0], V_max=self._volume_limits[1]
+            )
+            receiver_state = ReceiverState(
+                spec=receiver_spec,
+                V=self.receiver_volume,
+                p=PA_ATM,
+                T=T_AMBIENT,
+                mode=receiver_mode,
+            )
 
-            # NEW: Initialize road input with default scenario
-            road_scenario = "default_scenario"  # Заменить на нужный пресет
-            road_config = get_preset_by_name(road_scenario)
-            if road_config:
-                self.road_input = RoadInput(config=road_config)
-                self.logger.info(
-                    f"Road input initialized with scenario: {road_scenario}"
-                )
-            else:
-                self.logger.warning(f"Road scenario not found: {road_scenario}")
-                self.road_input = None  # Использовать заглушку
+            self.pneumatic_system = create_standard_diagonal_system(
+                cylinder_specs=cylinder_specs,
+                line_configs=line_configs,
+                receiver=receiver_state,
+                master_isolation_open=self.master_isolation_open,
+            )
 
-            # NEW: Initialize pneumatic system with standard configuration
-            try:
-                self.pneumatic_system = create_standard_diagonal_system()
-                self.logger.info(
-                    "Pneumatic system initialized with standard configuration"
+            # Wrap cylinders for convenience calculations
+            self._cylinder_wrappers = {
+                wheel: PneumaticCylinder(
+                    spec=spec, state=self.pneumatic_system.cylinders[wheel]
+                )
+                for wheel, spec in cylinder_specs.items()
+            }
+
+            # Pre-compute cylinder and line volume limits
+            self._compute_volume_and_angle_limits()
+
+            # Initialise gas network with current volumes
+            line_states = {}
+            line_volumes = self.pneumatic_system.get_line_volumes()
+
+            for line, volume_info in line_volumes.items():
+                total_volume = volume_info["total_volume"]
+                line_states[line] = create_line_gas_state(
+                    line,
+                    p_initial=PA_ATM,
+                    T_initial=T_AMBIENT,
+                    V_initial=total_volume,
                 )
-            except Exception as e:
-                self.logger.warning(f"Failed to create standard pneumatic system: {e}")
-                self.pneumatic_system = None  # Использовать заглушку
 
-            # NEW: Initialize gas network with default parameters
-            try:
-                self.gas_network = GasNetwork()
-                self.logger.info("Gas network initialized with default parameters")
-            except Exception as e:
-                self.logger.warning(f"Failed to create gas network: {e}")
-                self.gas_network = None  # Использовать заглушку
+            tank_state = create_tank_gas_state(
+                V_initial=self.receiver_volume,
+                p_initial=PA_ATM,
+                T_initial=T_AMBIENT,
+                mode=receiver_mode,
+            )
+
+            self.gas_network = GasNetwork(
+                lines=line_states,
+                tank=tank_state,
+                system_ref=self.pneumatic_system,
+                master_isolation_open=self.master_isolation_open,
+            )
+
+            self._initialize_pressure_limits()
+
+            # Configure road input from preset
+            self._initialize_road_input()
 
             self.logger.info("Physics objects initialized successfully")
 
         except Exception as e:
             self.logger.error(f"Failed to initialize physics objects: {e}")
             raise
 
+    def _cylinder_position_from_angle(self, spec: CylinderSpec, angle: float) -> float:
+        temp_state = CylinderState(spec=spec)
+        temp_state.update_from_lever_angle(angle)
+        return temp_state.x
+
+    def _solve_angle_for_position(self, spec: CylinderSpec, target: float) -> float:
+        sign = 1.0 if target >= 0 else -1.0
+        lower = 0.0 if sign > 0 else -math.radians(85.0)
+        upper = math.radians(85.0) if sign > 0 else 0.0
+        for _ in range(10):
+            pos = self._cylinder_position_from_angle(spec, upper)
+            if (sign > 0 and pos < target) or (sign < 0 and pos > target):
+                upper += sign * math.radians(5.0)
+            else:
+                break
+
+        for _ in range(50):
+            mid = 0.5 * (lower + upper)
+            pos = self._cylinder_position_from_angle(spec, mid)
+            if abs(pos - target) < 1e-6:
+                return mid
+            if (pos - target) * sign > 0:
+                upper = mid
+            else:
+                lower = mid
+        return 0.5 * (lower + upper)
+
+    def _compute_volume_and_angle_limits(self) -> None:
+        if not self.pneumatic_system:
+            return
+
+        half_travel = self.cylinder_geom.L_travel_max / 2.0
+        self._lever_models = {
+            wheel: Lever(self.lever_geom, self.cylinder_geom)
+            for wheel in Wheel
+        }
+
+        self._cylinder_volume_limits = {}
+        self._lever_angle_limits = {}
+        self._wheel_line_map = {wheel: {} for wheel in Wheel}
+
+        for line_name, pneumo_line in self.pneumatic_system.lines.items():
+            for wheel, port in pneumo_line.endpoints:
+                self._wheel_line_map[wheel][port] = line_name
+
+        for wheel, wrapper in self._cylinder_wrappers.items():
+            spec = wrapper.spec
+            geom = spec.geometry
+            is_front = spec.is_front
+
+            head_candidates = [
+                wrapper.state.vol_head(-half_travel),
+                wrapper.state.vol_head(half_travel),
+            ]
+            rod_candidates = [
+                wrapper.state.vol_rod(-half_travel),
+                wrapper.state.vol_rod(half_travel),
+            ]
+
+            head_min = max(geom.min_volume_head(is_front), min(head_candidates))
+            head_max = max(head_candidates)
+            rod_min = max(geom.min_volume_rod(is_front), min(rod_candidates))
+            rod_max = max(rod_candidates)
+
+            self._cylinder_volume_limits[wheel] = {
+                "head_min": head_min,
+                "head_max": head_max,
+                "rod_min": rod_min,
+                "rod_max": rod_max,
+            }
+
+            neg_angle = self._solve_angle_for_position(spec, -half_travel)
+            pos_angle = self._solve_angle_for_position(spec, half_travel)
+            self._lever_angle_limits[wheel] = (neg_angle, pos_angle)
+            self._previous_piston_positions[wheel] = 0.0
+            self._piston_velocities[wheel] = 0.0
+
+        self._line_volume_limits = {}
+        for line_name, pneumo_line in self.pneumatic_system.lines.items():
+            min_volume = 0.0
+            max_volume = 0.0
+            for wheel, port in pneumo_line.endpoints:
+                limits = self._cylinder_volume_limits[wheel]
+                if port == Port.HEAD:
+                    min_volume += limits["head_min"]
+                    max_volume += limits["head_max"]
+                else:
+                    min_volume += limits["rod_min"]
+                    max_volume += limits["rod_max"]
+            self._line_volume_limits[pneumo_line.name] = (min_volume, max_volume)
+
+    def _initialize_pressure_limits(self) -> None:
+        min_pressure = float(
+            self.settings_manager.get("pneumatic.relief_min_pressure", PA_ATM)
+        )
+        safety_pressure = float(
+            self.settings_manager.get(
+                "pneumatic.relief_safety_pressure", 5.0 * PA_ATM
+            )
+        )
+        min_pressure = max(1e4, min_pressure)
+        safety_pressure = max(min_pressure * 1.5, safety_pressure)
+        self._line_pressure_limits = (min_pressure * 0.5, safety_pressure * 1.1)
+        self._tank_pressure_limits = (min_pressure * 0.9, safety_pressure * 1.05)
+
+    def _initialize_road_input(self) -> None:
+        preset_name = self.settings_manager.get("modes.mode_preset", "sine_sweep")
+        if not isinstance(preset_name, str) or not preset_name:
+            preset_name = "sine_sweep"
+        preset = get_preset_by_name(preset_name)
+        if preset is None:
+            self.logger.warning(
+                "Unknown road preset '%s', falling back to sine_sweep", preset_name
+            )
+            preset = get_preset_by_name("sine_sweep")
+
+        if preset is None:
+            self.logger.error("Failed to resolve road preset for simulation")
+            self.road_input = None
+            return
+
+        track_value = self.settings_manager.get("geometry.track", 1.6)
+        try:
+            track = float(track_value)
+        except (TypeError, ValueError):
+            track = 1.6
+
+        road_config = RoadConfig(
+            source=preset.source_kind,
+            preset=preset,
+            wheelbase=getattr(self.frame_geom, "L_wb", 3.2),
+            track=track,
+        )
+
+        self.road_input = RoadInput()
+        try:
+            self.road_input.configure(road_config, system=self.pneumatic_system)
+            self.road_input.prime()
+            self.logger.info("Road input initialized with preset '%s'", preset.name)
+        except Exception as exc:
+            self.logger.warning(f"Failed to configure road input: {exc}")
+            self.road_input = None
+
     @Slot()
     def start_simulation(self):
         """Start physics simulation (called from UI thread)"""
         if not self.is_configured:
             self.error_occurred.emit("Physics worker not configured")
             return
 
         if self.is_running:
             self.logger.warning("Simulation already running")
             return
 
         # Create timer in this thread (will be moved to physics thread)
         if self.physics_timer is None:
             self.physics_timer = QTimer()
             self.physics_timer.timeout.connect(self._physics_step)
             self.physics_timer.setSingleShot(False)
 
         # Start timer with high precision
         timer_interval_ms = max(1, int(self.dt_physics * 1000))  # At least 1ms
         self.physics_timer.start(timer_interval_ms)
 
         self.is_running = True
         self.timing_accumulator.reset()
 
         self.logger.info(
@@ -456,55 +677,74 @@ class PhysicsWorker(QObject):
 
         self.logger.info(f"Thermo mode set to: {mode}")
 
     @Slot(bool)
     def set_master_isolation(self, open: bool):
         """Set master isolation valve state"""
         self.master_isolation_open = open
         self.logger.info(f"Master isolation: {'OPEN' if open else 'CLOSED'}")
 
     @Slot(float, str)
     def set_receiver_volume(self, volume: float, mode: str):
         """Set receiver volume and recalculation mode
 
         Args:
             volume: New receiver volume in m?
             mode: Recalculation mode ('NO_RECALC' or 'ADIABATIC_RECALC')
         """
         if volume <= 0 or volume > 1.0:  # Reasonable limits (0-1000L)
             self.error_occurred.emit(f"Invalid receiver volume: {volume} m?")
             return
 
         # Store volume and mode for gas network updates
         self.receiver_volume = volume
         self.receiver_volume_mode = mode
 
-        # TODO: Update actual ReceiverState when gas network is integrated
-        # For now, just log the change
-        self.logger.info(f"Receiver volume set: {volume:.3f}m? (mode: {mode})")
+        self.logger.info(f"Receiver volume set: {volume:.3f}m³ (mode: {mode})")
+
+        recalculation_mode = mode.upper()
+        receiver_mode = (
+            ReceiverVolumeMode.ADIABATIC_RECALC
+            if recalculation_mode == "GEOMETRIC"
+            else ReceiverVolumeMode.NO_RECALC
+        )
+
+        if self.pneumatic_system:
+            try:
+                receiver = self.pneumatic_system.receiver
+                receiver.mode = receiver_mode
+                receiver.apply_instant_volume_change(volume)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update receiver state: {exc}")
 
-        print(f"?? PhysicsWorker: Receiver volume={volume*1000:.1f}L, mode={mode}")
+        if self.gas_network:
+            try:
+                self.gas_network.tank.V = volume
+                self.gas_network.tank.V_prev = volume
+                self.gas_network.tank.update_ideal_gas()
+            except Exception as exc:
+                self.logger.warning(f"Failed to update tank volume: {exc}")
 
     @Slot(float)
     def set_physics_dt(self, dt: float):
         """Change physics timestep"""
         if dt <= 0 or dt > 0.1:  # Reasonable limits
             self.error_occurred.emit(f"Invalid physics dt: {dt}")
             return
 
         old_dt = self.dt_physics
         self.dt_physics = dt
         self.timing_accumulator = TimingAccumulator(dt)
         self.performance.target_dt = dt
 
         # Restart timer if running
         if self.is_running and self.physics_timer:
             self.physics_timer.stop()
             timer_interval_ms = max(1, int(dt * 1000))
             self.physics_timer.start(timer_interval_ms)
 
         self.logger.info(f"Physics dt changed: {old_dt*1000:.3f}ms ? {dt*1000:.3f}ms")
 
     @Slot()
     def _physics_step(self):
         """Single physics simulation step (called by QTimer)"""
         if not self.is_running:
@@ -523,190 +763,258 @@ class PhysicsWorker(QObject):
             step_end_time = time.perf_counter()
             step_time = step_end_time - step_start_time
             self.performance.update_step_time(step_time)
 
             # Emit performance update periodically
             if self.step_counter % 100 == 0:  # Every 100 steps
                 self.performance_update.emit(self.performance.get_summary())
 
             # Create and emit state snapshot
             snapshot = self._create_state_snapshot()
             if snapshot and snapshot.validate():
                 self.state_ready.emit(snapshot)
             else:
                 self.error_counter.increment()
                 if self.error_counter.get() > 10:  # Too many invalid states
                     self.error_occurred.emit("Too many invalid state snapshots")
                     self.stop_simulation()
 
         except Exception as e:
             self.logger.error(f"Physics step failed: {e}")
             self.error_occurred.emit(f"Physics step error: {str(e)}")
             self.stop_simulation()
 
     def _execute_physics_step(self):
         """Execute single physics timestep"""
-        # 1. Get road inputs
         road_inputs = self._get_road_inputs()
+        self._current_road_inputs.update(road_inputs)
 
-        # 2. Update geometry/kinematics
-        if self.rigid_body:
+        if self.pneumatic_system:
             try:
-                # Update lever angles and piston positions from road inputs
-                if self.pneumatic_system:
-                    for wheel, input_value in road_inputs.items():
-                        if wheel in {Wheel.LP.value, Wheel.PP.value}:  # Левые колеса
-                            cylinder = self.pneumatic_system.left_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-                        elif wheel in {Wheel.LZ.value, Wheel.PZ.value}:  # Правые колеса
-                            cylinder = self.pneumatic_system.right_cylinder
-                            if cylinder:
-                                # Применяем возбуждение к позиции поршня
-                                cylinder.piston_position += input_value
-
-            except Exception as e:
-                self.logger.warning(f"Failed to update kinematics: {e}")
+                for wheel, road_key in self._wheel_to_road_key.items():
+                    excitation = self._current_road_inputs.get(road_key, 0.0)
+                    min_angle, max_angle = self._lever_angle_limits.get(
+                        wheel, (-math.pi / 2.0, math.pi / 2.0)
+                    )
+                    lever_length = max(self.lever_geom.L_lever, 1e-6)
+                    target_angle = math.atan2(excitation, lever_length)
+                    target_angle = max(min_angle, min(max_angle, target_angle))
+                    self._current_lever_angles[wheel] = target_angle
+
+                    cylinder_state = self.pneumatic_system.cylinders[wheel]
+                    previous = self._previous_piston_positions.get(
+                        wheel, cylinder_state.x
+                    )
+                    cylinder_state.update_from_lever_angle(target_angle)
+                    new_position = cylinder_state.x
+                    self._cylinder_wrappers[wheel].state = cylinder_state
+                    self._piston_velocities[wheel] = (
+                        (new_position - previous) / self.dt_physics
+                        if self.dt_physics > 0
+                        else 0.0
+                    )
+                    self._previous_piston_positions[wheel] = new_position
+            except Exception as exc:
+                self.logger.warning(f"Failed to update kinematics: {exc}")
 
-        # 3. Update gas system
         if self.gas_network:
             try:
-                # Получаем текущее состояние газа в трубопроводах и резервуарах
-                line_gas_states = create_line_gas_state(self.gas_network)
-                tank_gas_states = create_tank_gas_state(self.gas_network)
-
-                # Обновляем состояния резервуаров в системе
-                for state in tank_gas_states:
-                    if state.receiver_id == "default_receiver":
-                        # Применяем новое состояние газа к резервуару
-                        receiver_state = ReceiverState(
-                            pressure=state.pressure,
-                            temperature=state.temperature,
-                            volume=self.receiver_volume,
-                        )
-                        self.gas_network.update_receiver_state(receiver_state)
-
-            except Exception as e:
-                self.logger.warning(f"Failed to update gas network: {e}")
+                self.gas_network.master_isolation_open = self.master_isolation_open
+                self.gas_network.update_pressures_due_to_volume(self.thermo_mode)
+                flow_log = self.gas_network.apply_valves_and_flows(
+                    self.dt_physics, log=None
+                )
+                if isinstance(flow_log, dict):
+                    self._last_line_flows = flow_log.get("lines", self._last_line_flows)
+                    self._last_relief_flows = flow_log.get(
+                        "relief", self._last_relief_flows
+                    )
+                if not self.master_isolation_open:
+                    self.gas_network.enforce_master_isolation(self.logger)
+            except Exception as exc:
+                self.logger.warning(f"Failed to update gas network: {exc}")
 
-        # 4. Integrate 3-DOF dynamics
         if self.rigid_body:
             try:
-                # Use placeholder system/gas for now
                 result = step_dynamics(
                     y0=self.physics_state,
                     t0=self.simulation_time,
                     dt=self.dt_physics,
                     params=self.rigid_body,
                     system=self.pneumatic_system,
                     gas=self.gas_network,
                     method="Radau",
                 )
 
                 if result.success:
                     self.physics_state = result.y_final
                 else:
                     self.performance.integration_failures += 1
-                    self.logger.warning(f"Integration failed: {result.message}")
+                    message = result.message or "Integrator reported failure"
+                    self.logger.error(f"Integration failed: {message}")
+                    self.error_occurred.emit(f"Integration failure: {message}")
+                    self.stop_simulation()
+                    return
 
-            except Exception as e:
+            except Exception as exc:
                 self.performance.integration_failures += 1
-                self.logger.error(f"Integration error: {e}")
+                self.logger.error(f"Integration error: {exc}")
+                self.error_occurred.emit(f"Integration error: {exc}")
+                self.stop_simulation()
+                return
 
-        # Update simulation time and step counter
         self.simulation_time += self.dt_physics
         self.step_counter += 1
 
     def _get_road_inputs(self) -> Dict[str, float]:
         """Get road excitation for all wheels"""
         if self.road_input:
             try:
                 return self.road_input.get_wheel_excitation(self.simulation_time)
             except Exception as e:
                 self.logger.warning(f"Road input error: {e}")
 
         # Return zero excitation as fallback
-        return {"LP": 0.0, "PP": 0.0, "LZ": 0.0, "PZ": 0.0}
+        return {"LF": 0.0, "RF": 0.0, "LR": 0.0, "RR": 0.0}
 
     def _create_state_snapshot(self) -> Optional[StateSnapshot]:
         """Create current state snapshot"""
         try:
             snapshot = StateSnapshot()
 
             # Basic timing info
             snapshot.simulation_time = self.simulation_time
             snapshot.dt_physics = self.dt_physics
             snapshot.step_number = self.step_counter
 
             # Frame state from physics integration
             if len(self.physics_state) >= 6:
                 Y, phi_z, theta_x, dY, dphi_z, dtheta_x = self.physics_state
 
                 snapshot.frame = FrameState(
                     heave=float(Y),
                     roll=float(phi_z),
                     pitch=float(theta_x),
                     heave_rate=float(dY),
                     roll_rate=float(dphi_z),
                     pitch_rate=float(dtheta_x),
                 )
 
-            # Road excitations
-            road_excitations = self._get_road_inputs()
-
             # Wheel states
-            for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
-                wheel_state = WheelState(wheel=wheel)
-
-                # Add road excitation
-                wheel_key = wheel.value  # LP, PP, LZ, PZ
-                if wheel_key in road_excitations:
-                    wheel_state.road_excitation = road_excitations[wheel_key]
-
-                # TODO: Add actual wheel state from pneumatic system
+            if self.pneumatic_system and self.gas_network:
+                for wheel in [Wheel.LP, Wheel.PP, Wheel.LZ, Wheel.PZ]:
+                    wheel_state = snapshot.wheels[wheel]
+                    cylinder_state = self.pneumatic_system.cylinders[wheel]
+                    wrapper = self._cylinder_wrappers.get(wheel)
+                    lever_angle = self._current_lever_angles.get(wheel, 0.0)
+                    wheel_state.lever_angle = lever_angle
+                    wheel_state.lever_angle_min, wheel_state.lever_angle_max = (
+                        self._lever_angle_limits.get(wheel, (None, None))
+                    )
+                    wheel_state.piston_position = float(cylinder_state.x)
+                    wheel_state.piston_velocity = float(
+                        self._piston_velocities.get(wheel, 0.0)
+                    )
+                    wheel_state.road_excitation = self._current_road_inputs.get(
+                        self._wheel_to_road_key[wheel], 0.0
+                    )
 
-                snapshot.wheels[wheel] = wheel_state
+                    if wrapper is not None:
+                        head_volume, rod_volume = wrapper.volumes()
+                        volume_limits = self._cylinder_volume_limits.get(wheel, {})
+                        wheel_state.vol_head = float(head_volume)
+                        wheel_state.vol_rod = float(rod_volume)
+                        wheel_state.vol_head_min = volume_limits.get("head_min", 0.0)
+                        wheel_state.vol_head_max = volume_limits.get("head_max", 0.0)
+                        wheel_state.vol_rod_min = volume_limits.get("rod_min", 0.0)
+                        wheel_state.vol_rod_max = volume_limits.get("rod_max", 0.0)
+
+                        head_line = self._wheel_line_map[wheel][Port.HEAD]
+                        rod_line = self._wheel_line_map[wheel][Port.ROD]
+                        head_state = self.gas_network.lines[head_line]
+                        rod_state = self.gas_network.lines[rod_line]
+                        wheel_state.force_pneumatic = wrapper.force(
+                            head_state.p, rod_state.p
+                        )
 
-            # Line states (placeholder)
-            for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
-                line_state = LineState(line=line)
-                # TODO: Get actual line state from gas network
-                snapshot.lines[line] = line_state
+                    joint_pos = self._lever_models[wheel].joint_position(lever_angle)
+                    wheel_state.joint_x = joint_pos[0]
+                    wheel_state.joint_y = joint_pos[1]
+                    wheel_state.joint_z = joint_pos[2]
+
+            # Line states
+            if self.gas_network:
+                for line in [Line.A1, Line.B1, Line.A2, Line.B2]:
+                    gas_state = self.gas_network.lines[line]
+                    min_vol, max_vol = self._line_volume_limits.get(line, (0.0, 0.0))
+                    flows = self._last_line_flows.get(
+                        line, {"flow_atmo": 0.0, "flow_tank": 0.0}
+                    )
+                    snapshot.lines[line] = LineState(
+                        line=line,
+                        pressure=float(gas_state.p),
+                        temperature=float(gas_state.T),
+                        mass=float(gas_state.m),
+                        volume=float(gas_state.V_curr),
+                        pressure_min=self._line_pressure_limits[0],
+                        pressure_max=self._line_pressure_limits[1],
+                        volume_min=min_vol,
+                        volume_max=max_vol,
+                        flow_atmo=float(flows.get("flow_atmo", 0.0)),
+                        flow_tank=float(flows.get("flow_tank", 0.0)),
+                    )
 
-            # Tank state (placeholder)
-            snapshot.tank = TankState()
+            # Tank state
+            if self.gas_network:
+                tank = self.gas_network.tank
+                snapshot.tank = TankState(
+                    pressure=float(tank.p),
+                    temperature=float(tank.T),
+                    mass=float(tank.m),
+                    volume=float(tank.V),
+                    pressure_min=self._tank_pressure_limits[0],
+                    pressure_max=self._tank_pressure_limits[1],
+                    volume_min=self._volume_limits[0],
+                    volume_max=self._volume_limits[1],
+                    flow_min=float(self._last_relief_flows.get("flow_min", 0.0)),
+                    flow_stiff=float(self._last_relief_flows.get("flow_stiff", 0.0)),
+                    flow_safety=float(self._last_relief_flows.get("flow_safety", 0.0)),
+                )
+                snapshot.tank.relief_min_open = snapshot.tank.flow_min > 0.0
+                snapshot.tank.relief_stiff_open = snapshot.tank.flow_stiff > 0.0
+                snapshot.tank.relief_safety_open = snapshot.tank.flow_safety > 0.0
 
-            # NEW: Update tank volume from receiver settings
-            snapshot.tank.volume = self.receiver_volume
+            total_in = sum(flow.get("flow_atmo", 0.0) for flow in self._last_line_flows.values())
+            total_out = sum(flow.get("flow_tank", 0.0) for flow in self._last_line_flows.values())
 
-            # System aggregates
             snapshot.aggregates = SystemAggregates(
                 physics_step_time=self.performance.avg_step_time,
                 integration_steps=self.step_counter,
                 integration_failures=self.performance.integration_failures,
+                total_flow_in=float(total_in),
+                total_flow_out=float(total_out),
+                net_flow=float(total_in - total_out),
             )
 
             # Configuration
             snapshot.master_isolation_open = self.master_isolation_open
             snapshot.thermo_mode = (
                 self.thermo_mode.name
                 if hasattr(self.thermo_mode, "name")
                 else str(self.thermo_mode)
             )
 
             return snapshot
 
         except Exception as e:
             self.logger.error(f"Failed to create state snapshot: {e}")
             return None
 
 
 class SimulationManager(QObject):
     """High-level simulation manager
 
     Manages PhysicsWorker in separate thread and provides
     unified interface for UI interaction.
     """
 
     def __init__(self, parent=None):
