diff a/src/ui/geometry_bridge.py b/src/ui/geometry_bridge.py	(rejected hunks)
@@ -1,73 +1,87 @@
 # -*- coding: utf-8 -*-
-"""
-Geometry-to-3D bridge module
-Converts 2D kinematics geometry to 3D visualization coordinates
-INTEGRATED WITH USER INTERFACE CONTROLS
-"""
+"""Geometry-to-3D bridge utilities (SI units)."""
+
+from __future__ import annotations
+
+from typing import Any, Dict, Optional
+
 import numpy as np
+from PySide6.QtCore import QObject, Property, Signal
 from PySide6.QtGui import QVector3D
-from PySide6.QtCore import QObject, Signal, Property
-from typing import Dict, Any, Optional
 
-from ..core.settings import SettingsManager
+from ..common.settings_manager import SettingsManager, get_settings_manager
 from ..core.geometry import GeometryParams
 
 
 class GeometryTo3DConverter(QObject):
     """Converts 2D geometry parameters to 3D visualization coordinates
     WITH USER INTERFACE INTEGRATION"""
 
     # Signals for parameter changes
     geometryChanged = Signal()
     frameChanged = Signal()
 
-    def __init__(self, geometry: GeometryParams):
-        """Initialize geometry bridge converter"""
+    def __init__(
+        self,
+        geometry: GeometryParams,
+        settings_manager: Optional[SettingsManager] = None,
+    ):
+        """Initialize geometry bridge converter using SI units."""
         super().__init__()
         self.geometry = geometry
+        self._settings_manager = settings_manager or get_settings_manager()
+
+        defaults = {
+            "frame_beam_size_m": 0.12,
+            "frame_height_m": 0.65,
+            "frame_length_m": 2.0,
+            "lever_length_m": 0.315,
+            "cylinder_body_length_m": 0.25,
+            "tail_rod_length_m": 0.1,
+        }
 
-        # USER-CONTROLLABLE PARAMETERS (will be connected to UI)
-        self._frame_beam_size = 120.0  # mm - beam size
-        self._frame_height = 650.0  # mm - horn height
-        self._frame_length = 2000.0  # mm - frame length (2 meters!)
-        self._lever_length = 315.0  # mm - lever length
-        self._cylinder_body_length = 250.0  # mm - cylinder working length
-        self._tail_rod_length = 100.0  # mm - tail extension length
-
-        # Z-coordinates for front/rear - calculated from frame length
-        self._front_z = -self._frame_length / 2.0  # Front at -1000mm
-        self._rear_z = self._frame_length / 2.0  # Rear at +1000mm
-
-        print("    GeometryBridge initialized:")
-        print(
-            f"      Frame: {self._frame_length:.0f}x{self._frame_height:.0f}x{self._frame_beam_size:.0f}mm"
-        )
-        print(f"      Lever: {self._lever_length:.0f}mm")
-        print(
-            f"      Cylinder: {self._cylinder_body_length:.0f}mm + {self._tail_rod_length:.0f}mm tail"
-        )
+        settings = {}
+        try:
+            if self._settings_manager:
+                settings = self._settings_manager.get_geometry_snapshot()
+        except Exception:
+            settings = {}
+
+        merged = {**defaults, **settings}
+
+        # Store all measurements in meters
+        self._frame_beam_size = merged["frame_beam_size_m"]
+        self._frame_height = merged["frame_height_m"]
+        self._frame_length = merged["frame_length_m"]
+        self._lever_length = merged["lever_length_m"]
+        self._cylinder_body_length = merged["cylinder_body_length_m"]
+        self._tail_rod_length = merged["tail_rod_length_m"]
+
+        # Z-coordinates for front/rear in meters
+        self._front_z = -self._frame_length / 2.0
+        self._rear_z = self._frame_length / 2.0
 
     # USER-CONTROLLABLE PROPERTIES (connected to UI sliders/spinboxes)
 
     @Property(float, notify=frameChanged)
     def frameLength(self):
         return self._frame_length
 
     @frameLength.setter
     def frameLength(self, value):
         if self._frame_length != value:
             self._frame_length = value
             self._front_z = -value / 2.0
             self._rear_z = value / 2.0
             self.frameChanged.emit()
             self.geometryChanged.emit()
 
     @Property(float, notify=frameChanged)
     def frameHeight(self):
         return self._frame_height
 
     @frameHeight.setter
     def frameHeight(self, value):
         if self._frame_height != value:
             self._frame_height = value
             self.frameChanged.emit()
@@ -93,199 +107,205 @@ class GeometryTo3DConverter(QObject):
         if self._lever_length != value:
             self._lever_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
     def cylinderBodyLength(self):
         return self._cylinder_body_length
 
     @cylinderBodyLength.setter
     def cylinderBodyLength(self, value):
         if self._cylinder_body_length != value:
             self._cylinder_body_length = value
             self.geometryChanged.emit()
 
     @Property(float, notify=geometryChanged)
     def tailRodLength(self):
         return self._tail_rod_length
 
     @tailRodLength.setter
     def tailRodLength(self, value):
         if self._tail_rod_length != value:
             self._tail_rod_length = value
             self.geometryChanged.emit()
 
     def get_frame_params(self) -> Dict[str, float]:
-        """Get frame parameters for 3D visualization"""
+        """Get frame parameters for 3D visualization in meters."""
+
         return {
             "beamSize": self._frame_beam_size,
             "frameHeight": self._frame_height,
             "frameLength": self._frame_length,
+            "beamSizeM": self._frame_beam_size,
+            "frameHeightM": self._frame_height,
+            "frameLengthM": self._frame_length,
         }
 
     def get_corner_3d_coords(
         self,
         corner: str,
         lever_angle_deg: float = 0.0,
         cylinder_state: Optional[Any] = None,
     ) -> Dict[str, Any]:
         """Convert 2D kinematics to 3D coordinates for one corner
         USING CORRECTED SUSPENSION MECHANICS FROM test_2m_suspension.py
 
         Args:
             corner: 'fl', 'fr', 'rl', 'rr'
             lever_angle_deg: Current lever angle in degrees
             cylinder_state: Optional CylinderState from physics simulation
 
         Returns:
             Dictionary with 3D coordinates for QML (compatible with CorrectedSuspensionCorner)
         """
         # Determine side and position
         is_left = corner.endswith("l")  # fl, rl = left side
         is_front = corner.startswith("f")  # fl, fr = front
 
         # Side multiplier for mirroring
         side_mult = -1.0 if is_left else 1.0
 
         # Z position (longitudinal)
         z_plane = self._front_z if is_front else self._rear_z
 
         # FIXED FRAME ATTACHMENT POINTS (never change)
 
         # Lever pivot (j_arm) - FIXED attachment to frame
-        pivot_offset_x = 150.0  # mm from center
-        pivot_height = self._frame_beam_size / 2.0  # ON BEAM AXIS
+        pivot_offset_x = 0.15  # m from center
+        pivot_height = self._frame_beam_size / 2.0  # beam axis height (m)
 
         j_arm = QVector3D(
             pivot_offset_x * side_mult,  # ±150mm from center
             pivot_height,  # beam axis height
             z_plane,  # EXACTLY in plane
         )
 
         # Cylinder tail (j_tail) - FIXED attachment to frame
-        horn_height = self._frame_beam_size + self._frame_height  # total horn height
-        tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset
-        tail_offset_x = 100.0  # mm from center
+        horn_height = self._frame_beam_size + self._frame_height  # total horn height (m)
+        tail_height = horn_height - self._frame_beam_size / 2  # horn top minus offset (m)
+        tail_offset_x = 0.1  # m from center
 
         j_tail = QVector3D(
             tail_offset_x * side_mult,  # ±100mm from center
             tail_height,  # horn height
             z_plane,  # EXACTLY in plane
         )
 
         # MOVING PARTS (depend on lever angle)
 
         # Base angle: LEFT side points LEFT (180°), RIGHT side points RIGHT (0°)
         base_angle_deg = 180.0 if is_left else 0.0
         total_angle_deg = base_angle_deg + lever_angle_deg
         total_angle_rad = np.deg2rad(total_angle_deg)
 
         # Rod attachment point on lever (at lever end)
         rod_attach_x = j_arm.x() + self._lever_length * np.cos(total_angle_rad)
         rod_attach_y = j_arm.y() + self._lever_length * np.sin(total_angle_rad)
 
         j_rod = QVector3D(rod_attach_x, rod_attach_y, z_plane)
 
         # PISTON POSITION CALCULATION
         # Calculate from GEOMETRY (correct kinematics!)
         # Distance from tail to rod attachment point
         tail_to_rod_dist = np.sqrt(
             (j_rod.x() - j_tail.x()) ** 2 + (j_rod.y() - j_tail.y()) ** 2
         )
 
         # Total assembly: tail_rod + cylinder_body + piston_rod
         # tail_rod = FIXED 100mm
         # cylinder_body = FIXED 250mm
         # piston_rod = VARIABLE (depends on lever angle!)
 
         # Calculate baseline distance (lever horizontal)
         base_angle_rad = np.deg2rad(base_angle_deg)
         base_rod_x = j_arm.x() + self._lever_length * np.cos(base_angle_rad)
         base_rod_y = j_arm.y() + self._lever_length * np.sin(base_angle_rad)
         base_dist = np.sqrt(
             (base_rod_x - j_tail.x()) ** 2 + (base_rod_y - j_tail.y()) ** 2
         )
 
         # Change in distance from baseline
         delta_dist = tail_to_rod_dist - base_dist
 
         # Piston position inside cylinder:
         # When lever is horizontal (baseline), piston is centered
         # When lever rotates, distance changes ? piston moves
         # Piston moves IN SAME DIRECTION as rod extension
         # (if rod extends/distance increases, piston moves toward rod end/increases)
         # CORRECTED: Use PLUS (not minus) because piston follows rod extension
-        piston_position_mm = (self._cylinder_body_length / 2.0) + delta_dist
+        piston_position_m = (self._cylinder_body_length / 2.0) + delta_dist
 
         # Clip to safe range (10% to 90% of cylinder length)
-        piston_position_mm = float(
+        piston_position_m = float(
             np.clip(
-                piston_position_mm,
+                piston_position_m,
                 self._cylinder_body_length
                 * 0.1,  # 10% minimum (25mm for 250mm cylinder)
                 self._cylinder_body_length
                 * 0.9,  # 90% maximum (225mm for 250mm cylinder)
             )
         )
 
         # Calculate ratio for QML
-        piston_ratio = float(piston_position_mm / self._cylinder_body_length)
+        piston_ratio = float(piston_position_m / self._cylinder_body_length)
 
         # If cylinder_state provided, OVERRIDE with physics data
         if cylinder_state is not None:
             # Use actual physics data from CylinderKinematics
-            stroke_mm = cylinder_state.stroke * 1000.0  # m to mm
-
             # Calculate piston position from stroke
             # Assuming stroke 0 = center of cylinder
-            max_stroke_mm = self._cylinder_body_length * 0.4  # ±40% stroke range
-            piston_ratio_physics = 0.5 + (stroke_mm / (2 * max_stroke_mm))
+            max_stroke = self._cylinder_body_length * 0.4  # ±40% stroke range (m)
+            piston_ratio_physics = 0.5 + (
+                cylinder_state.stroke / (2 * max_stroke)
+            )
             piston_ratio_physics = float(np.clip(piston_ratio_physics, 0.1, 0.9))
-            piston_position_mm_physics = (
+            piston_position_physics = (
                 piston_ratio_physics * self._cylinder_body_length
             )
 
             # Use physics values
-            piston_position_mm = float(piston_position_mm_physics)
+            piston_position_m = float(piston_position_physics)
             piston_ratio = float(piston_ratio_physics)
 
         # Return data compatible with CorrectedSuspensionCorner.qml
         result = {
             # FIXED joints
             "j_arm": j_arm,  # Lever pivot (orange joint)
             "j_tail": j_tail,  # Cylinder mount (blue joint)
             "j_rod": j_rod,  # Rod attachment (green joint)
             # Animation
             "leverAngle": float(lever_angle_deg),
             # Dimensions (for QML calculations)
             "leverLength": float(self._lever_length),
+            "leverLengthM": float(self._lever_length),
             "cylinderBodyLength": float(self._cylinder_body_length),
+            "cylinderBodyLengthM": float(self._cylinder_body_length),
             "tailRodLength": float(self._tail_rod_length),
+            "tailRodLengthM": float(self._tail_rod_length),
             # PISTON POSITION (ALWAYS float, never None or empty!)
-            "pistonPositionMm": float(
-                piston_position_mm
-            ),  # Absolute position in cylinder (mm)
+            "pistonPositionM": float(piston_position_m),
+            "pistonPositionMm": float(piston_position_m * 1000.0),
             "pistonRatio": float(piston_ratio),  # Ratio 0..1 inside cylinder
             # Additional data for UI
             "corner": corner,
             "totalAngle": float(total_angle_deg),
             "baseAngle": float(base_angle_deg),
             "side": "left" if is_left else "right",
             "position": "front" if is_front else "rear",
         }
 
         # If cylinder_state provided, add full physics data
         if cylinder_state is not None:
             result["cylinderPhysics"] = {
                 "stroke": cylinder_state.stroke,
                 "strokeVelocity": cylinder_state.stroke_velocity,
                 "volumeHead": cylinder_state.volume_head,
                 "volumeRod": cylinder_state.volume_rod,
                 "distance": cylinder_state.distance,
                 "axisAngle": cylinder_state.cylinder_axis_angle,
             }
 
         return result
 
     def get_all_corners_3d(
         self,
         lever_angles: Optional[Dict[str, float]] = None,
@@ -325,153 +345,169 @@ class GeometryTo3DConverter(QObject):
         """
         # Extract lever angles from simulation
         lever_angles = {}
 
         if "lever_angles" in sim_state:
             lever_angles = sim_state["lever_angles"]
         else:
             # Extract from individual angle fields
             lever_angles = {
                 "fl": sim_state.get("fl_angle", 0.0),
                 "fr": sim_state.get("fr_angle", 0.0),
                 "rl": sim_state.get("rl_angle", 0.0),
                 "rr": sim_state.get("rr_angle", 0.0),
             }
 
         # Extract cylinder states (if available)
         cylinder_states = {}
         if "cylinder_states" in sim_state:
             cylinder_states = sim_state["cylinder_states"]
         elif "corners" in sim_state:
             # Try to extract from corners structure
             for corner, data in sim_state.get("corners", {}).items():
                 if "cylinder_state" in data:
                     cylinder_states[corner] = data["cylinder_state"]
 
+        user_params_m = {
+            "frameLength": self._frame_length,
+            "frameHeight": self._frame_height,
+            "frameBeamSize": self._frame_beam_size,
+            "leverLength": self._lever_length,
+            "cylinderBodyLength": self._cylinder_body_length,
+            "tailRodLength": self._tail_rod_length,
+        }
+
         return {
             "frame": self.get_frame_params(),
             "corners": self.get_all_corners_3d(lever_angles, cylinder_states),
-            # Add user-controllable parameters
-            "userParams": {
-                "frameLength": self._frame_length,
-                "frameHeight": self._frame_height,
-                "frameBeamSize": self._frame_beam_size,
-                "leverLength": self._lever_length,
-                "cylinderBodyLength": self._cylinder_body_length,
-                "tailRodLength": self._tail_rod_length,
-            },
+            "userParams": user_params_m,
+            "userParamsMeters": user_params_m,
         }
 
     def update_user_parameters(self, params: Dict[str, float], persist: bool = False):
         """Update multiple user parameters at once
 
         Args:
             params: Dictionary with parameter names and values
             persist: If True, persist changes to settings manager
         """
         changed = False
 
-        if "frameLength" in params and params["frameLength"] != self._frame_length:
-            self.frameLength = params["frameLength"]
+        frame_length = params.get("frameLengthM", params.get("frameLength"))
+        if frame_length is not None and frame_length != self._frame_length:
+            self.frameLength = float(frame_length)
             changed = True
 
-        if "frameHeight" in params and params["frameHeight"] != self._frame_height:
-            self.frameHeight = params["frameHeight"]
+        frame_height = params.get("frameHeightM", params.get("frameHeight"))
+        if frame_height is not None and frame_height != self._frame_height:
+            self.frameHeight = float(frame_height)
             changed = True
 
-        if (
-            "frameBeamSize" in params
-            and params["frameBeamSize"] != self._frame_beam_size
-        ):
-            self.frameBeamSize = params["frameBeamSize"]
+        beam_size = params.get("frameBeamSizeM", params.get("frameBeamSize"))
+        if beam_size is not None and beam_size != self._frame_beam_size:
+            self.frameBeamSize = float(beam_size)
             changed = True
 
-        if "leverLength" in params and params["leverLength"] != self._lever_length:
-            self.leverLength = params["leverLength"]
+        lever_length = params.get("leverLengthM", params.get("leverLength"))
+        if lever_length is not None and lever_length != self._lever_length:
+            self.leverLength = float(lever_length)
             changed = True
 
+        cylinder_length = params.get(
+            "cylinderBodyLengthM", params.get("cylinderBodyLength")
+        )
         if (
-            "cylinderBodyLength" in params
-            and params["cylinderBodyLength"] != self._cylinder_body_length
+            cylinder_length is not None
+            and cylinder_length != self._cylinder_body_length
         ):
-            self.cylinderBodyLength = params["cylinderBodyLength"]
+            self.cylinderBodyLength = float(cylinder_length)
             changed = True
 
-        if (
-            "tailRodLength" in params
-            and params["tailRodLength"] != self._tail_rod_length
-        ):
-            self.tailRodLength = params["tailRodLength"]
+        tail_length = params.get("tailRodLengthM", params.get("tailRodLength"))
+        if tail_length is not None and tail_length != self._tail_rod_length:
+            self.tailRodLength = float(tail_length)
             changed = True
 
-        if changed:
-            print(f"    GeometryBridge updated: {params}")
-
         # Persist changes to settings manager
         if persist:
             self.save_to_settings()
 
     def save_to_settings(self):
         """Save current geometry settings to persistent storage"""
-        # Collect settings data
-        settings_data = {
-            "frameLength": self._frame_length,
-            "frameHeight": self._frame_height,
-            "frameBeamSize": self._frame_beam_size,
-            "leverLength": self._lever_length,
-            "cylinderBodyLength": self._cylinder_body_length,
-            "tailRodLength": self._tail_rod_length,
-        }
-
-        # Update settings manager
-        SettingsManager.set_geometry_settings(settings_data)
+        if not self._settings_manager:
+            return
+
+        geometry_settings = self._settings_manager.get_category("geometry") or {}
+        geometry_settings.update(
+            {
+                "frame_length_m": self._frame_length,
+                "frame_height_m": self._frame_height,
+                "frame_beam_size_m": self._frame_beam_size,
+                "lever_length_m": self._lever_length,
+                "cylinder_body_length_m": self._cylinder_body_length,
+                "tail_rod_length_m": self._tail_rod_length,
+            }
+        )
 
-        print(f"    Geometry settings saved: {settings_data}")
+        self._settings_manager.set_category(
+            "geometry", geometry_settings, auto_save=True
+        )
 
     def export_geometry_params(self) -> Dict[str, Any]:
         """Export current geometry parameters as dictionary
 
         Returns:
             Dictionary with geometry parameters for export
         """
         return {
             "frameLength": self._frame_length,
             "frameHeight": self._frame_height,
             "frameBeamSize": self._frame_beam_size,
             "leverLength": self._lever_length,
             "cylinderBodyLength": self._cylinder_body_length,
             "tailRodLength": self._tail_rod_length,
         }
 
 
 # Convenience function for easy integration
 def create_geometry_converter(
     wheelbase: float = 2.0,
     lever_length: float = 0.315,
     cylinder_diameter: float = 0.08,
     settings_manager: Optional[Any] = None,
 ) -> GeometryTo3DConverter:
     """Create geometry converter with common parameters
 
     Args:
         wheelbase: Vehicle track width in meters
         lever_length: Suspension lever length in meters
         cylinder_diameter: Cylinder bore diameter in meters
         settings_manager: Optional SettingsManager instance for persistent settings
 
     Returns:
         Configured GeometryTo3DConverter
     """
     geometry = GeometryParams()
     geometry.wheelbase = wheelbase
     geometry.lever_length = lever_length
     geometry.cylinder_inner_diameter = cylinder_diameter
     geometry.enforce_track_from_geometry()  # Ensure consistency
 
-    converter = GeometryTo3DConverter(geometry)
+    manager = settings_manager or get_settings_manager()
+    converter = GeometryTo3DConverter(geometry, settings_manager=manager)
 
     # Load settings from manager if available
-    if settings_manager is not None:
-        settings = settings_manager.get_geometry_settings()
-        converter.update_user_parameters(settings, persist=False)
+    if manager is not None:
+        settings = manager.get_geometry_snapshot()
+        converter.update_user_parameters(
+            {
+                "frameLengthM": settings.get("frame_length_m"),
+                "frameHeightM": settings.get("frame_height_m"),
+                "frameBeamSizeM": settings.get("frame_beam_size_m"),
+                "leverLengthM": settings.get("lever_length_m"),
+                "cylinderBodyLengthM": settings.get("cylinder_body_length_m"),
+                "tailRodLengthM": settings.get("tail_rod_length_m"),
+            },
+            persist=False,
+        )
 
     return converter
