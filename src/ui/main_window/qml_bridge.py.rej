diff a/src/ui/main_window/qml_bridge.py b/src/ui/main_window/qml_bridge.py	(rejected hunks)
@@ -1,80 +1,103 @@
 """QML Bridge Module - Python↔QML communication
 
 Модуль управления взаимодействием между Python и QML.
 Отвечает за вызов QML функций, батч-обновления и синхронизацию состояния.
 
 Russian comments / English code.
 """
 from __future__ import annotations
 
 import logging
 from pathlib import Path
 from typing import TYPE_CHECKING, Any, Dict, Optional
 
 from PySide6.QtCore import Q_ARG, QMetaObject, Qt
 
 if TYPE_CHECKING:
     from .main_window import MainWindow
 
+from src.pneumo.enums import Line, Wheel
+from src.runtime.state import StateSnapshot
+
 
 class QMLBridge:
     """Мост между Python и QML
 
     Управляет:
     - Вызовами QML функций
     - Батч-обновлениями
     - Очередью изменений
     - ACK сигналами
 
     Static methods для делегирования из MainWindow.
     """
 
     logger = logging.getLogger(__name__)
 
     # QML update method mapping
     QML_UPDATE_METHODS: Dict[str, tuple[str, ...]] = {
         "geometry": ("applyGeometryUpdates", "updateGeometry"),
         "animation": (
             "applyAnimationUpdates",
             "updateAnimation",
             "applyAnimParamsUpdates",
             "updateAnimParams",
         ),
-        "lighting": ("applyLightingUpdates", "updateLighting"),
-        "materials": ("applyMaterialUpdates", "updateMaterials"),
-        "environment": ("applyEnvironmentUpdates", "updateEnvironment"),
-        "quality": ("applyQualityUpdates", "updateQuality"),
-        "camera": ("applyCameraUpdates", "updateCamera"),
-        "effects": ("applyEffectsUpdates", "updateEffects"),
+        "lighting": (
+            "applyLightingUpdates",
+            "updateLighting",
+        ),
+        "materials": (
+            "applyMaterialUpdates",
+            "updateMaterials",
+        ),
+        "environment": (
+            "applyEnvironmentUpdates",
+            "updateEnvironment",
+        ),
+        "quality": (
+            "applyQualityUpdates",
+            "updateQuality",
+        ),
+        "camera": (
+            "applyCameraUpdates",
+            "updateCamera",
+        ),
+        "effects": (
+            "applyEffectsUpdates",
+            "updateEffects",
+        ),
     }
 
     # ------------------------------------------------------------------
     # Queue Management
     # ------------------------------------------------------------------
     @staticmethod
-    def queue_update(window: MainWindow, key: str, params: Dict[str, Any]) -> None:
+    def queue_update(
+        window: MainWindow, key: str, params: Dict[str, Any]
+    ) -> None:
         """Поставить изменения в очередь для батч-отправки в QML
 
         Args:
             window: MainWindow instance
             key: Update category (geometry, lighting, etc.)
             params: Update parameters
         """
         if not params:
             return
 
         if key not in window._qml_update_queue:
             window._qml_update_queue[key] = {}
 
         QMLBridge._deep_merge_dicts(window._qml_update_queue[key], params)
 
         if not window._qml_flush_timer.isActive():
             window._qml_flush_timer.start(0)
 
     @staticmethod
     def flush_updates(window: MainWindow) -> None:
         """Сбросить накопленные batched-обновления в QML
 
         Strategy:
         1. Try pendingPythonUpdates property (fast)
         2. Fallback to individual function calls
